{"./":{"url":"./","title":"前言","keywords":"","body":"Spring Boot 培训教程 这是一套 Spring Boot 的快速入门培训教程，面向的学员是有一定的 Java 基础，会一些 Spring 传统开发（SSM）的初中级 Java 开发工程师。 其目的是通过2-3个月的时间，每周完成1章节的教程学习（可能在一个学习小组内需要辅导教员引导），达到能够应用 Spring Boot 进行开发的程度，向中级开发工程师进阶，进而打好后续学习 Spring Cloud 的基础。 虽然本教程提供了一个极简的 vue 入门学习章节，其目的是用来演示如何开发“前后端分离”的应用，但是本教程并不会将前端开发作为重点。相反，在这里，我们只关心后端如何使用 Spring Boot 进行开发。 本教程规划于2019年春，动笔于2019年10月30日，希望完结于2019年12月31日，实际完结于2020年2月7日，历时101天，我也坚持连续写作101天。 任何时候出发，都不晚，相信我，风景总是在路上。 --Kevin Zhang 本教程使用的 Spring Boot 版本为2.2.1-2.2.4； 写作过程中，Spring Boot 从2.2.1持续升级到了2.2.4，可见 Spring Boot 社区的活跃。 本教程的每一章节，尽量聚焦在当前讨论的知识点范围内，示例也设计为最简； 本教程不涉及 Spring Boot 的深层次实现机制和如何扩展 Spring Boot 框架； 已经能够熟练使用 Spring Boot 进行开发的同学，请绕道，这份教程不适用于你。 "},"第1章 Spring Boot介绍/SpringBoot.html":{"url":"第1章 Spring Boot介绍/SpringBoot.html","title":"第1章 Spring Boot介绍","keywords":"","body":"第1章 Spring Boot介绍 当前，我们广泛使用的 Spring 技术栈，包含了基本的 Spring Framework，Spring Boot，Spring Cloud 和 Spring Cloud Data Flow。正如 Spring 官方网站spring.io宣称的一样：Spring 就是现代 java 之源。 其主要的三大系列框架，架构了 Spring 完整的宇宙： Spring Boot：构建万物； Spring Cloud：协同万物； Spring Cloud Data Flow：连接万物。 Spring 官方是这么宣传的，它也是这么做的，通过十多年的努力，它确实做到了是java程序员名副其实的“源”（the source）。 连接万物。什么是连接？ 物联网中，5G是连接万物的基础。 中文社交网中，微信是连接人。 在Java程序开发中，Spring 就是连接的关键，就如它最早被叫做“胶水”一样。 "},"第1章 Spring Boot介绍/1.1spring.html":{"url":"第1章 Spring Boot介绍/1.1spring.html","title":"1.1 Spring介绍","keywords":"","body":"1.1 Spring介绍 当我们单独讲 Spring 时，一般是指 Spring Framework，就如下面的 maven 依赖所示，当前最新的版本为5.2.1（2019年11月2日release）。 org.springframework spring-core 5.2.1.RELEASE 1.1.1 Spring概述 Spring 是一个于2003 年兴起的一个轻量级的开源Java 开发框架，由其作者Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 Spring使用基本的JavaBean（POJO）来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 下面，为了简化并抓住重点，我们以Spring Framework 1.1.1版本第一次提供的reference为基础，来介绍Spring的分层架构。 Spring 框架（以版本1.1.1 为例）是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，如下图所示： 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IoC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map（现在的MyBatis）。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。 Spring Framework的核心思想是IoC（控制反转，依赖注入）和AOP（面向切面编程）。 控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。 在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。 面向方面的编程，即 AOP，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP 的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。 AOP 和 IOC 是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 AOP 方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring AOP 编写的应用程序代码是松散耦合的。 IoC 在 Spring 中体现在组件依赖注入，如 @Component， @Controller， @Service， @Repository 等注解。 AOP 在Spring 中的应用典型的有： 自动事务管理； 统一日志管理。 1.1.2 Spring的进化 随着互联网技术的发展，Spring也在不断的进化，从最早轻量级的支持J2EE到现在对高并发，多线程异步程序的支持，Spring也从版本1到版本5不断的更新自己走在技术的最前沿，下面我们从Spring3到Spring5 看看spring的发展变迁。 Spring 1 分层架构： Spring 2 分层架构： Spring 3 分层架构： Spring 4 分层架构： Spring 5 分层架构： 1.1.2.1 Spring 3.2.x和4.x的架构变化 从上面的图中可以看出，总体的层次结构没有太大变化，变化的是 Spring 4 去掉了 struts 模块(spring-struts包)。增加 WebSocket 模块(spring-websocket包)，增加了对 WebSocket、SockJS 以及 STOMP 的支持，它与 JSR-356 Java WebSocket API 兼容。另外，还提供了基于 SockJS（对 WebSocket 的模拟）的回调方案，以适应不支持 WebSocket 协议的浏览器。 同时增加了 messaging 模块(spring-messaging)，提供了对 STOMP 的支持，以及用于路由和处理来自 WebSocket 客户端的 STOMP 消息的注解编程模型。spring-messaging 模块中还 包含了 Spring Integration 项目中的核心抽象类，如 Message、MessageChannel、MessageHandler。 如果去看源代码的话，还可以发现还有一个新增的包，加强了 beans 模块，就是 spring-beans-groovy。应用可以部分或完全使用 Groovy 编写。借助于 Spring 4.0，能够使用 Groovy DSL 定义外部的 Bean 配置，这类似于 XML Bean 声明，但是语法更为简洁。使用Groovy还能够在启动代码中直接嵌入Bean的声明。 对JDK的支持：Java 8支持。当然也支持Java6和Java7，但最好在使用Spring框架3.X或4.X时，将JDK升级到Java7，因为有些版本至少需要Java7。使用Spring4.x时Java EE版本至少要6或以上，且需要JPA 2.0和Servlet 3.0 的支持，所以服务器，web容器需要做相应的升级。一个更具前瞻性的注意是，Spring4.0支持J2EE 7的适用级规范，比如JMS 2.0， JTA 1.2， JPA 2.1， Bean Validation 1.1和JSR-236并发工具包，在选择这些jar包时需要注意版本。 核心容器提升: 支持Bean的泛型注入，比如：@Autowired Repository customerRepository 使用元注解开发暴露指定内部属性的自定义注解。 通过 @Ordered注解或Ordered 接口对注入集合或数组的 Bean 进行排序。 @Lazy 注解可以用在注入点或 @Bean 定义上。 为开发者引入 @Description 注解。 引入 @Conditional 注解进行有条件的 Bean过滤。 基于 CGLIB 的代理类不需要提供默认构造器，因为 Spring 框架将 CGLIB 整合到内部了。 框架支持时区管理，比如 LocalContext Web提升 增加新的 @RestController 注解，这样就不需要在每个 @RequestMapping 方法中添加 @ResponseBody 注解。 添加 AsyncRestTemplate，在开发 REST 客户端时允许非阻塞异步支持。 为 Spring MVC 应用程序开发提供全面的时区支持。 1.1.2.2 Spring 5的架构变化 升级到 Java SE 8 和 Java EE 7。 直到Spring 4 仍支持一些弃用的 Java 版本，但 Spring 5 已从旧包袱中解放出来。为了充分利用 Java 8 特性，它的代码库已进行了改进，而且该框架要求将 Java 8 作为最低的 JDK 版本。 在 API 级别上，Spring 5 兼容 Java EE 8 技术，满足对 Servlet 4.0、Bean Validation 2.0 和全新的 JSON Binding API 的需求。对 Java EE API 的最低要求为 V7，该版本引入了针对 Servlet、JPA 和 Bean Validation API 的次要版本。 响应式编程模型 Spring 5 最令人兴奋的新特性是它的响应式编程模型。Spring 5 Framework 基于一种响应式基础而构建，而且是完全异步和非阻塞的。只需少量的线程，新的事件循环执行模型就可以垂直扩展。 新的spring-webflux模块，一个基于reactive的spring-webmvc，完全的异步非阻塞，旨在使用event-loop执行模型和传统的线程池模型。 1.1.3 Spring 5的新特性 Spring 5.0是在2013年发布Spring 4后的第一个大版本，5.0 M1在2016年7月28日发布，当前最新版本为5.2.1。随着Spring Boot 和 Spring Cloud的广泛使用，使用Spring 5的人数是越来越多，如果你之前使用过Spring 4，那么Spring 5有哪些新的特性呢？一起来看下吧 基本可以归为如下几类： JDK版本升级 Core框架修订，核心容器更新 Kotlin函数式编程 响应式编程模型 测试改进 额外库支持 停止维护一些特性 1.1.3.1 JDK版本升级 Spring 5的代码基于Java 8的语法规范，因此要想使用Spring 5，JDK的版本至少要在8.0以上。最开始的时候Spring 5.0 想使用Java 9，但是Java 9发布的时间比Spring 慢了18个月，然后Spring开发团队决定从Spring 5.0 中去除Java 9的依赖。 1.1.3.2 Core框架修订 基于Java8的反射增强，方法的参数在Spring 5中可以高效的被访问 核心的Spring接口提供了利用了Java 8 的默认接口实现，default方法，提供了一些可选的声明 @Nullable和@NotNull注解精确的标记了方法的参数和返回值，这样可以在编译的时候处理null值，而不至于在运行的时候抛出空指针异常，NullPointerExceptions。 在日志端，Spring 5.0提供了Common Logging的桥接模块，spring-jcl，代替了标准的Common Logging，同时它还可以自动的检测Log4J2.x，SLF4J，JUL(java.util.logging)，而不需要额外的依赖。 1.1.3.3 Kotlin函数式编程 Spring 5.0引入了JetBrains的Kotlin语言支持，Kotlin是一种支持函数式编程的面向对象编程语言。Kotlin也运行在JVM之上，有了Kotlin的支持，开发者可以使用Spring的函数式编程处理Web的入口点和Bean的注册。 比如你可以写成如下的代码风格。 在web的入口点的时候： { (\"/movie\" and accept(TEXT_HTML)).nest { GET(\"/\", movieHandler::findAllView) GET(\"/{card}\", movieHandler::findOneView) } (\"/api/movie\" and accept(APPLICATION_JSON)).nest { GET(\"/\", movieApiHandler::findAll) GET(\"/{id}\", movieApiHandler::findOne) } } 在注册Bean的时候： val context = GenericApplicationContext { registerBean() registerBean { Cinema(it.getBean()) } } 1.1.3.4 响应式编程模型 激动人心的Spring 5.0特性就是它的响应式Web编程 Reactive Streams(响应式流)是NetFlix ，Pivotal, Typesafe, Red Hat, Oracle, Twitter, 和 Spray.io共同开发的一套规范。它提供了一些通用的API, 实现的话可以自己控制，就像Hibernate之JPA，JPA是api，Hibernate是实现。 响应式流是Java9的正式模块，但是在Java8中，我们需要引入额外的依赖。Spring5.0的流式支持基于响应式流的API的Project Reactor Spring 5.0有个新的模块叫做spring-webflux，可以支持响应式的Http和WebSocket客户端。 通过Spring Webflux，你可以创建Webclient，它是响应式和非阻塞的RestTemplate的替代。如下是代码示范： WebClient webClient = WebClient.create(); Mono person = webClient.get() .uri(\"http://localhost:8080/movie/42\") .accept(MediaType.APPLICATION_JSON) .exchange() .then(response -> response.bodyToMono(Movie.class)); 1.1.3.5 测试改进 Spring 5.0完全支持Junit 5，在TestContext框架中，可以并行的执行测试。对于响应式的编程，Spring-test提供了WebTestClient来测试spring-webflux。WebTestClient，就像MockMvc不需要运行的服务器。 当然Spring 5.0还是支持Junit 4的，在未来的一段时间里Junit 4是都会存在的。 1.1.3.6 支持更多的库 Spring 5.0现在支持下面的库版本： Jackson 2.6+ EhCache 2.10+ / 3.0 GA Hibernate 5.0+ JDBC 4.0+ XmlUnit 2.x+ OkHttp 3.x+ Netty 4.1+ 1.1.3.7 停止维护的一些特性 在API层面上，Spring5.0不再支持下面的包了： beans.factory.access jdbc.support.nativejdbc spring-aspects模块的mock.staticmock web.view.tiles2M. 现在Tiles 3是最低要求的版本 orm.hibernate3和orm.hibernate4.现在支持Hibernate5 不再支持如下库： Portlet Velocity JasperReports XMLBeans JDO Guava 如果你在当前的项目中使用到了上面提到的这些库，那么最好不要升级到Spring5的版本 1.1.3.8 小结 响应式编程已经变得越来越流行，我们会看到越来越多的技术实现响应式的方案，对响应式编程感兴趣的可以多做更多的了解。 "},"第1章 Spring Boot介绍/1.2springBoot.html":{"url":"第1章 Spring Boot介绍/1.2springBoot.html","title":"1.2 Spring Boot简介","keywords":"","body":"1.2. Spring Boot简介 在 Java 后端框架繁荣的今天，Spring 框架无疑是最最火热，也是必不可少的开源框架，更是稳坐 Java 后端框架的龙头老大。 用过 Spring 框架的都知道 Spring 能流行是因为它的两把利器：IOC 和 AOP，IOC 可以帮助我们管理对象的依赖关系，极大减少对象的耦合性，而 AOP 的切面编程功能可以更方面的使用动态代理来实现各种动态方法功能（如事务、缓存、日志等）。 而要集成 Spring 框架，必须要用到 XML 配置文件，或者注解式的 Java 代码配置。无论是使用 XML 或者代码配置方式，都需要对相关组件的配置有足够的了解，然后再编写大量冗长的配置代码。 然后又有多少开发人员能精通这些配置呢？如果我们只提供一些配置参数让框架能自动配置这些组件，那是不是会更加容易。 基于简化 Spring 快速上手为目的，Spring Boot 框架诞生了！当然，Spring Boot之前，还有一个基于代码生成的叫做Spring Roo的开发工具。正如Spring Boot 宣称的那样“如果（骨架）代码可以生成，那就是不要生成代码，使用配置、自动装配方式，来的更优雅”。所以，Spring Roo早就被抛弃了，现在最火热的当然是，也必须是Spring Boot。 Spring Roo is an easy-to-use development tool for quickly building web applications in the Java programming language, which can be used as an standalone application or as an Eclipse or STS plugin. It allows you to build high-quality, high-performance, lock-in-free enterprise applications in just minutes. 1.2.1 Spring Boot概述 Spring Boot是 Spring 开源组织下的一个子项目，也是 Spring 组件一站式解决方案，主要是为了简化使用 Spring 框架的难度，简省繁重的配置。 Spring Boot提供了各种组件的启动器（starters），开发者只要能配置好对应组件参数，Spring Boot 就会自动配置，让开发者能快速搭建依赖于 Spring 组件的 Java 项目。 Spring Boot不但能创建传统的 war 包应用，还能创建独立的不依赖于任何外部容器（如：tomcat）的独立应用，使用 java -jar 命令就能启动。同时，Spring Boot也提供了一个命令行工具来执行 Spring 的脚本。 Spring Boot 的设计目标是： 为 Spring 应用开发提供一个更快、更容易上手的入门体验； 提供一系列在大型项目中经常用到的公共的非功能性特性，如：内嵌入服务器、安全、度量指标、健康检测、外部化配置； 零代码配置生成及零 XML 配置； 1.2.2 Spring Boot能做什么 独立运行 Spring Boot内嵌了各种 Servlet 容器，Tomcat、Jetty等，现在不再需要打成 war 包部署到容器中，Spring Boot 只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个 jar 包内。 对一个程序员来说，回归到入口main函数的感觉，简直是不能再棒了。 package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 简化 Maven 配置 例如只要依赖 spring-boot-starter-web 启动器，它包含所有 web 开发所有的依赖，就能拥有 Spring Web 的能力，极大简少了 maven 对依赖的配置。 自动配置 Spring Boot能根据当前类路径下的类或者 jar 包里面来的类来自动配置 Spring Bean，如添加一个 spring-boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。也可以在配置文件中添加相关配置来自定义装配，这个后面的课程会讲到，请关注后续内容。 无代码生成和XML配置 Spring Boot 配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是 Spring 4+ 的核心功能之一。 应用监控 Spring Boot提供一系列端点可以监控服务及应用，能对Spring 应用做健康检测。 1.2.3 Spring Boot 2的新特性 Spring Boot 依赖于Spring，而Spring Cloud 又依赖于Spring Boot，因此Spring Boot2.0的发布正式整合了Spring5.0 的很多特性，同样后面Spring Cloud 最新版本的发布也整合了最新的Spring Boot2.0内容。 1.2.3.1 基于 Java 8，支持 Java 9 也就是说Spring Boot2.0的最低版本要求为JDK8，据了解国内大部分的互联网公司系统都还跑在JDK1.6/7上，因此想要升级到Spring Boot2.0的同学们注意啦，同时支持了Java9，也仅仅是支持而已。 1.2.3.2 响应式编程 使用 Spring WebFlux/WebFlux.fn提供响应式 Web 编程支持， Webflux 是一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好，此功能来源于Spring5.0。 Spring Boot2.0也提供对响应式编程的自动化配置，如：Reactive Spring Data、Reactive Spring Security 等。 1.2.3.3 HTTP/2支持 在Tomcat, Undertow 和 Jetty 中均已支持 HTTP/2。 1.2.3.4 对Kotlin支持 引入对 Kotlin 1.2.x 的支持，并提供了一个 runApplication 函数，让你通过惯用的 Kotlin 来运行 Spring Boot 应用程序。 1.2.3.5 全新的执行器架构 全新的执行器架构，支持 Spring MVC, WebFlux 和 Jersey。 1.2.3.6 支持 Quartz Spring Boot1.0并没有提供对 Quartz 的支持，之前出现了各种集成方案，Spring Boot2.0给出了最简单的集成方式。 1.2.3.7 Security 大大的简化了安全自动配置。 1.2.3.8 Metrics Metrics 方面，Spring Boot 2引入了Micrometer，来统一metrics的规范，使得开发人员更好的理解和使用metrics的模块，而不需要关心对接的具体存储是什么。 1.2.3.9 监控方面 Spring Boot 2 增强了对 Micrometer 的集成。RabbitMQ、JVM 线程和垃圾收集指标会自动进行 instrument 监控，异步控制器(controller)也会自动添加到监控里。通过集成，还可以对 InfluxDB 服务器进行监控。 1.2.3.10 数据方面 db方面，默认引入了HikariCP，替代了之前的tomcat-pool作为底层的数据库连接池， 对比于tomcat-pool， HikariCP拥有更好的性能，总而言之就是提高了db的访问速度； JOOQ的支持； Redis方面， 默认引入了Lettuce, 替代了之前的jedis作为底层的redis链接方式； MongoDB\\Hibernate优化。 1.2.3.11 Thymeleaf 3 Spring Boot 2支持了Thymeleaf 3，Thymeleaf 3相对于Thymeleaf 2性能提升可不是一点点，因为2.0的性能确实不咋地，同时也使用了新的页面解析系统。 1.2.3.12 OAuth 2.0 同时也加入了 对于OAuth 2.0的支持， 使得开发人员更加友好的使用spring-security来完成权限模块的开发。 1.2.3.13 依赖组件的更新 Jetty 9.4 Tomcat 8.5 Flyway 5 Hibernate 5.2 Gradle 3.4 Thymeleaf 3.0 注意：最后还有一个小彩蛋，Spring Boot2.0支持了动态gif的启动logo打印，这纯粹是为了好玩。 "},"第1章 Spring Boot介绍/1.3springBootModules.html":{"url":"第1章 Spring Boot介绍/1.3springBootModules.html","title":"1.3 Spring Boot的主要模块","keywords":"","body":"1.3 Spring Boot的主要模块 学习 Spring Boot必须得了解它的核心模块，以对其形成整体的印象。 和 Spring框架一样，Spring Boot也是一个庞大的项目，也是由许多核心子模块组成的。 最权威的，也是最直接的是到Spring Boot在github上的源码，找到其代码模块划分，如下图： 下面我们大概来了解一下 Spring Boot 的核心模块。 1.3.1 spring-boot 这是 Spring Boot 的主模块，也是支持其他模块的核心模块，主要包含以下几点： 提供了一个启动 Spring 应用的主类，并提供了一个相当方便的静态方法，它的主要是作用是负责创建和刷新 Spring 容器的上下文； 内嵌式的并可自由选择搭配的 WEB 应用容器，如：Tomcat, Jetty, Undertow等； 对配置外部化的支持； 提供一个很方便的 Spring 容器上下文初始化器，包括合理记录日志默认参数的支持。 1.3.2 spring-boot-autoconfigure Spring Boot能根据类路径下的内容自动配置（启用）一些功能依赖（如数据库连接池、MongoDB、Redis等）。 Spring Boot提供的 @EnableAutoConfiguration 注解就是启用 Spring功能的自动配置。 自动配置功能可以推断用户可能需要加载哪些 Spring Bean, 如：如果类路径下有 HicariCP 这个连接池的包，此时并未提供任何有效连接池的配置，那么 Spring Boot就知道你可能需要一个连接池，并做相应配置。如果用户配置了其他连接池，那么 Spring Boot会放弃自动配置。 1.3.3 spring-boot-starters Starters，我们叫它启动器好了，它是包括一系列依赖的描述符。简单的说就是，它可以一站式的帮你打包 Spring 及相关技术应用，而不需要你到处找依赖和示例配置代码，它都帮你做好了。 例如，第一章我们在介绍 Spring Boot 的时候就说了 spring-boot-starter-web 这个启动器，你只要引用了这个启动器应用，就会自动配置 WEB 应用的能力。 spring-boot-starters 这个启动器这主要提供了 spring-boot, spring-context, spring-beans 这三个 Spring 模块而已。 1.3.4 spring-boot-cli Spring Boot CLI 是 Spring Boot Commad Line 的缩写，是 Spring Boot 命令行工具。在 Spring Boot CLI 中可以跑 Groovy 脚本，通过简单的 Java 语法就可以快速而又简单的学习 Spring Boot 原型。 它也能监控你的文件，一旦有变动就会自动重新编译和重新启动应用程序。 1.3.5 spring-boot-actuator 这是 Spring Boot 提供的执行端点，你可以更好的监控及和你的应用程序交互。这个模块提供了像健康端点、环境端点、Spring Bean端点等。 1.3.6 spring-boot-actuator-autoconfigure 这个原理同上，为 Spring Boot 执行端点提供自动配置。 1.3.7 spring-boot-test Spring Boot测试模块，为应用测试提供了许多非常有用的核心功能。 1.3.8 spring-boot-test-autoconfigure 这个原理同上，为 Spring Boot 测试模块提供自动配置。 1.3.9 spring-boot-tools 这个模块包含了Spring Boot的一些工具，如Maven插件、Loader等。 例如其中的spring-boot-loader可以用来构建一个单独可执行的 jar 包，使用 java -jar 就能直接运行。我们一般不会直接使用这个来打包，而是使用 Spring Boot提供的 Maven（spring-boot-maven-plugin）或者 Gradle 插件就行了。 1.3.10 spring-boot-devtools 开发者工具模块，主要为 Spring Boot 开发阶段提供一些特性，如修改了代码自动重启应用等。这个模块的功能是可选的，只限于本地开发阶段，当打成整包运行时这些功能会被禁用。 "},"第1章 Spring Boot介绍/1.4helloSpringBoot.html":{"url":"第1章 Spring Boot介绍/1.4helloSpringBoot.html","title":"1.4 Hello Spring Boot","keywords":"","body":"1.4 Hello Spring Boot 程序员都有“Hello world.”情结，我们在了解了Spring和Spring Boot的历史和特性之后，也以Spring Boot的“Hello world.”来感受我们后续将要学习的Spring Boot应用程序是如何开发的。 本小节的目的是为了给大家一个开发Spring Boot应用程序的初步印象，暂时没有开发环境，无法练习也没有关系，学习完第2章后返回来学习效果更好。 请参照本教程第2章的“开发环境配置”，完成本地开发环境的配置，然后再来“Hello Spring Boot.”。 1.4.1 创建项目 首先，我们创建一个Spring Starter工程，如下图所示： 输入项目名称、项目的GAV（maven依赖的坐标：Group、Artifact、Version）、Package等信息： 选择Spring Boot的版本，当前最新为2.2.0（截至2019年11月）： 其实，STS开发工具，是通过Eclipse插件连接到网络，根据我们之前给定的参数设定请求参数，然后在Spring官网生成项目骨架（starter.zip），这和在 start.spring.io 上生成项目骨架是完全一致的。 参考 start.spring.io 生成项目骨架，后台服务一定是相同的。 稍等片刻（如果网络不给力，有可能要等上好一阵子呢），maven会下载所有的依赖。 Spring官网为我们生成的pom.xml文件如下： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE com.example hello 0.0.1-SNAPSHOT HelloSpringBoot My First Spring Boot Project. 1.8 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin 需要注意的有几点： 第6-9行的spring-boot-starter-parent； 第22-25行的spring-boot-starter-web； 第42-45行的spring-boot-maven-plugin； 这些依赖，为我们大大简化了Spring应用程序的配置。当然，其中也隐藏了大量的魔法，在第3章中我们会简要的介绍这些魔法是怎么实现的，在这里，大家不要过度关注，不理解也不影响我们Say Hello to Spring Boot. 我们再来关注启动入口类HelloSpringBootApplication，这将是我们进入Spring Boot世界的第一道门。 package com.example.hello; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class HelloSpringBootApplication { public static void main(String[] args) { SpringApplication.run(HelloSpringBootApplication.class, args); } } 这里唯一陌生的，也是最需要关注的，当然就是@SpringBootApplication这个注解。它标识了这个类是个Spring Boot的应用程序。 这个类中有main方法，运行它看看效果： 虽然没有啥效果，但控制台打出的日志，表明，这个Spring Boot程序确实可以正确运行。 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) 2019-11-06 22:27:52.949 INFO 1704 --- [ main] c.e.hello.HelloSpringBootApplication : Starting HelloSpringBootApplication on NOTEBOOK-KEVIN with PID 1704 (C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot\\target\\classes started by Kevin in C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot) 2019-11-06 22:27:52.952 INFO 1704 --- [ main] c.e.hello.HelloSpringBootApplication : No active profile set, falling back to default profiles: default 2019-11-06 22:27:53.663 INFO 1704 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2019-11-06 22:27:53.671 INFO 1704 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2019-11-06 22:27:53.672 INFO 1704 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27] 2019-11-06 22:27:53.727 INFO 1704 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2019-11-06 22:27:53.728 INFO 1704 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 736 ms 2019-11-06 22:27:53.861 INFO 1704 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor' 2019-11-06 22:27:54.019 INFO 1704 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2019-11-06 22:27:54.021 INFO 1704 --- [ main] c.e.hello.HelloSpringBootApplication : Started HelloSpringBootApplication in 1.422 seconds (JVM running for 2.316) 1.4.2 编写Controller代码 下面，我们为这个程序添加一个Controller，输出“Hello Spring Boot.”这句话。 首先创建com.example.hello.controller包，然后在其下创建SayHelloController类，代码如下： package com.example.hello.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class SayHelloController { @RequestMapping(\"/hello\") public String sayHello() { return \"Hello Spring Boot.\"; } } 1.4.3 在IDE中运行 再次运行HelloSpringBootApplication这个类（当然，也可以说运行这个Spring Boot应用/程序），在控制台中输出的日志，已经包含DispatcherServlet这个Spring MVC的前端分发器类了。 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) 2019-11-06 22:33:48.882 INFO 7872 --- [ main] c.e.hello.HelloSpringBootApplication : Starting HelloSpringBootApplication on NOTEBOOK-KEVIN with PID 7872 (C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot\\target\\classes started by Kevin in C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot) 2019-11-06 22:33:48.891 INFO 7872 --- [ main] c.e.hello.HelloSpringBootApplication : No active profile set, falling back to default profiles: default 2019-11-06 22:33:49.558 INFO 7872 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2019-11-06 22:33:49.564 INFO 7872 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2019-11-06 22:33:49.565 INFO 7872 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27] 2019-11-06 22:33:49.613 INFO 7872 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2019-11-06 22:33:49.614 INFO 7872 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 688 ms 2019-11-06 22:33:49.731 INFO 7872 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor' 2019-11-06 22:33:49.863 INFO 7872 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2019-11-06 22:33:49.865 INFO 7872 --- [ main] c.e.hello.HelloSpringBootApplication : Started HelloSpringBootApplication in 1.262 seconds (JVM running for 1.873) 2019-11-06 22:33:59.678 INFO 7872 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet' 2019-11-06 22:33:59.678 INFO 7872 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet' 2019-11-06 22:33:59.686 INFO 7872 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 8 ms 打开浏览器，访问localhost:8080/hello，可以正确得到前面Controller类中sayHello方法的输出： 恭喜你，你已经完成了你的第一个Spring Boot程序。 1.4.4 打包 当一个应用开发完成后，需要分发时，通常会将Spring Boot应用程序打包为一个jar包。 在STS中，选择Maven build... 在Maven build的目标（Goals）中输入clean package，为了更快的打包，勾选Skip Tests复选框。 正常情况下，稍等片刻，Maven就会完成打包操作，注意观察控制台输出的日志。 [INFO] BUILD SUCCESS表示Maven任务正确完成。 [INFO] Scanning for projects... [INFO] [INFO] --------------------------------------------------- [INFO] Building HelloSpringBoot 0.0.1-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- maven-clean-plugin:3.1.0:clean (default-clean) @ hello --- [INFO] Deleting C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot\\target [INFO] [INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ hello --- [INFO] Using 'UTF-8' encoding to copy filtered resources. [INFO] Copying 1 resource [INFO] Copying 0 resource [INFO] [INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ hello --- [INFO] Changes detected - recompiling the module! [INFO] Compiling 2 source files to C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot\\target\\classes [INFO] [INFO] --- maven-resources-plugin:3.1.0:testResources (default-testResources) @ hello --- [INFO] Not copying test resources [INFO] [INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ hello --- [INFO] Not compiling test sources [INFO] [INFO] --- maven-surefire-plugin:2.22.2:test (default-test) @ hello --- [INFO] Tests are skipped. [INFO] [INFO] --- maven-jar-plugin:3.1.2:jar (default-jar) @ hello --- [INFO] Building jar: C:\\sts-4.4.1.RELEASE\\workspace\\HelloSpringBoot\\target\\hello-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- spring-boot-maven-plugin:2.2.0.RELEASE:repackage (repackage) @ hello --- [INFO] Replacing main artifact with repackaged archive [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 3.251 s [INFO] Finished at: 2019-11-08T11:29:53+08:00 [INFO] ------------------------------------------------------------------------ [WARNING] The requested profile \"pom.xml\" could not be activated because it does not exist. 打开项目文件目录下的target子目录，其中hello-0.0.1-SNAPSHOT.jar就是打包好的项目可运行jar包。 其中还有一个很小的hello-0.0.1-SNAPSHOT.jar.original文件，就是项目编译的文件。 而hello-0.0.1-SNAPSHOT.jar是spring-boot-maven-plugin插件帮我们把依赖jar包和内嵌tomcat打包到一起了的fat jar。 打开hello-0.0.1-SNAPSHOT.jar这个fat jar文件，查看其BOOT-INF\\lib目录，可以看到其依赖的各种jar包。 1.4.5 独立运行程序 Spring Boot打包出来的jar文件支持独立运行，执行java -jar，运行Hello Spring Boot程序。 java -jar hello-0.0.1-SNAPSHOT.jar 在命令提示符窗口中，可以看到这个Spring Boot程序正确启动了。 打开浏览器，访问localhost:8080/hello，同样可以正确得到前面Controller类中sayHello方法的输出。 如果当前端口（例如8080）被占用，需要在启动时指定服务器端口，可以通过--server.port=80来指定。 java -jar hello-0.0.1-SNAPSHOT.jar --server.port=80 更多Spring Boot的配置项，会在本教程的后续章节陆续介绍。 后续，我们会一步一步地介绍在实际工作中，如何使用Spring Boot集成我们常用的开发框架/类库。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-hello "},"第1章 Spring Boot介绍/1.5homework.html":{"url":"第1章 Spring Boot介绍/1.5homework.html","title":"1.5 课后作业","keywords":"","body":"1.5 课后作业 简要描述Spring框架是什么？能做什么？ 简要描述Spring框架的版本变迁。 简要描述Spring Boot出现的历史背景，它是什么？能做什么？能给程序员带来什么好处？ 在完成第2章 开发环境配置的学习之后，再回来做这道题：开发并运行（要求以独立jar包的方式运行）第一个Spring Boot程序，输出“我要好好学习，天天向上。”这样一句话，并观察程序运行过程。 "},"第2章 开发环境配置/IDE.html":{"url":"第2章 开发环境配置/IDE.html","title":"第2章 开发环境配置","keywords":"","body":"第2章 开发环境配置 工欲利其事，必先利其器。 为了更好的有序推进学习进度，在本教程中，将使用如下的开发环境，各位同学在学习过程中最好与以下开发工具的版本保持一致。 序号 软件 版本 说明 1 JDK 8u201 java 开发套件 2 Maven 3.6.0 项目构建，依赖管理 3 STS 4.4.1.RELEASE 基于eclipse的整合Spring插件的开发环境 4 Windows 10 操作系统 5 Tomcat 8.5.47 独立的外置Web容器 "},"第2章 开发环境配置/2.1jdk.html":{"url":"第2章 开发环境配置/2.1jdk.html","title":"2.1 安装JDK","keywords":"","body":"2.1 安装JDK 首先去Oracle官网下载 Java SE Development Kit 8u201。 然后双击运行下载回来的jdk-8u201-windows-x64.exe文件。 指定安装路径，例如，我将JDK安装到 C:\\Java\\jdk1.8.0_201\\ 下。需要注意的是，JDK安装目录尽量不要含中文和（或）空格。 进行安装。 安装完JDK后，安装程序会弹出Oracle用户许可提醒信息，接受即可。 继续安装JRE，建议jre也安装到一个不含中文和（或）空格的目录中。 JRE安装中。 安装完成。 设置JAVA_HOME环境变量。 将JAVA加入path，方面后续通过命令行使用jdk。 验证jdk是否正确安装：打开命令窗口，输入‘java -version'，查看安装的jdk版本信息，如正确显示jdk版本信息，则jdk成功安装并配置正确。 "},"第2章 开发环境配置/2.2maven.html":{"url":"第2章 开发环境配置/2.2maven.html","title":"2.2 安装配置Maven","keywords":"","body":"2.2 安装配置Maven Maven是Apache下的一个开源项目，它基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档，是一个优秀的、被广泛使用的软件项目管理工具软件。 基本上，国内所有的规模以上软件公司，使用Java语言开发的软件，都是用Maven进行项目管理。 Maven 除了以程序构建能力为特色之外，还提供许多高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。 使用Maven可以很方便的对项目的依赖进行管理，并支持脚本的继承。对于一个由多个子项目组成的项目来说，子项目可以继承父项目的构建脚本，从而方便统一管理并有效地减少了构建脚本的冗余。 首先到Apache Maven官网下载apache-maven-3.6.0-bin.zip。 将下载回来的zip文件，解压。例如解压到C:\\Java\\apache-maven-3.6.0目录下。 为Windows配置环境变量M2_HOME，指向C:\\Java\\apache-maven-3.6.0目录。 编辑Windows的path环境变量，添加%M2_HOME%\\bin配置项，方便后续通过命令行窗口执行mvn命令。 由于使用maven创建的项目默认使用jdk5，不能满足开发需求。我们需要对maven做统一配置，以避免每次新建项目时都需要重复设置一次。 在maven主目录的conf目录下打开配置文件settings.xml，找到profiles段（大约在182行），在其内添加一个profile段，代码如下： jdk-1.8 true 1.8 1.8 1.8 1.8 由于maven中央仓库在国外，网络访问速度很慢，为了加快依赖包下载，强烈建议为maven设置国内仓库镜像，比较快的国内镜像仓库推荐阿里云。 在配置文件settings.xml文件中找到mirrors段（大约在146行），在其内添加一段mirror，代码如下： nexus-aliyun * Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public "},"第2章 开发环境配置/2.3sts.html":{"url":"第2章 开发环境配置/2.3sts.html","title":"2.3 安装配置STS","keywords":"","body":"2.3 安装配置STS STS是Spring官方在Eclipse IDE for Enterprise Java Developers的基础上整合了Spring开发插件后的开发工具发行版，使用这个发行版进行Spring相关应用开发非常方便，强烈推荐。 首先去Spring官网，下载Spring整合开发工具Spring Tools 4 for （Eclipse STS Spring Tool Suite）。 将下载回来的jar文件存放到例如C:\\，然后在命令行窗口（如果解压安装在C:\\，需要“以管理员身份运行”命令窗口）执行安装命令： java -jar spring-tool-suite-4-4.4.1.RELEASE-e4.13.0-win32.win32.x86_64.self-extracting.jar 将STS解压到当前目录 为STS创建工作空间目录，例如C:\\sts-4.4.1.RELEASE\\workspace，然后启动STS集成开发工具。 由于Windows系统的默认字符集是GBK，我们需要为工作空间指定UTF-8字符集。 在STS中配置外部maven，以保持开发环境内外配置及调用一致。 为STS指定Maven配置文件，以使用前面设置的JDK8及阿里云仓库镜像。 "},"第2章 开发环境配置/2.4mysql.html":{"url":"第2章 开发环境配置/2.4mysql.html","title":"2.4 安装MySQL和管理工具","keywords":"","body":"2.4 安装MySQL和管理工具 在Windows 10下安装MySQL 5.7.19，需要提前安装微软的VC++2013依赖库vcredist_x64，可在微软官方网站下载。 接下来就可以安装MySQL了。 选择“只安装服务器”。 确认安装。 安装完成。 准备配置MySQL服务器。 选择配置MySQL服务器类型。 配置服务器为开发服务器，以减少对计算机资源的占用。 设置root用户密码，尽量使用足够复杂的密码。 配置MySQL为Windows系统服务。 完成安装。 安装MySQL管理工具，如navicat。 打开navicat验证MySQL是否正确安装。 "},"第2章 开发环境配置/2.5validation.html":{"url":"第2章 开发环境配置/2.5validation.html","title":"2.5 验证开发环境","keywords":"","body":"2.5 验证开发环境 在STS中新建一个Spring Starter项目。 在新建Spring Starter项目中，使用默认配置。 选择Spring Boot的starter，这里我们输入“web”进行快速定位和选择，然后单击Finish按钮。 STS会根据我们前面给定的项目信息，联网到https://start.spring.io创建最初始的Spring Boot项目。 我们可以进一步检查pom文件，观察其内容如下： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.0.RELEASE com.example demo 0.0.1-SNAPSHOT demo Demo project for Spring Boot 1.8 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin 检查启动类DemoApplication，代码如下： package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 编写HelloController，响应“/hello”请求。 package com.example.demo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping(\"/hello\") public String sayHello() { return \"Hello Spring Boot.\"; } } 通过启动类DemoApplication启动项目。 注意观察控制台中输出的SpringBoot信息，其中包含SpringBoot版本号的启动logo。 打开Chrome浏览器，http://localhost:8080/hello ，可正确显示前面HelloController中hello方法输出的字符串“Hello Spring Boot.”。 通过上述步骤，就已经准备好了Spring Boot的开发环境。 "},"第2章 开发环境配置/2.6postman.html":{"url":"第2章 开发环境配置/2.6postman.html","title":"2.6 安装Postman","keywords":"","body":"2.6 安装Postman 在后端系统的开发测试过程中，浏览器可以很好地模拟get请求，但是post请求需要携带数据，这个时候就需要一个顺手的工具来模拟前端发起的请求。 Postman在发送网络HTTP请求方面就是一个专业的工具。 到https://www.getpostman.com/downloads/下载对应操作系统的Postman，然后双击Postman-win64-7.12.0-Setup.exe安装。 打开Postman，新建一个请求，选择类型为POST，输入地址，添加Body的form-data，然后发送请求。 经测试，能够返回正确的结果，验证安装成功。 该后台接口的功能是将新创建的User对象保存到MongoDB中同时将该User对象返回。 "},"第2章 开发环境配置/2.7homework.html":{"url":"第2章 开发环境配置/2.7homework.html","title":"2.7 课后作业","keywords":"","body":"2.7 课后作业 检查安装的jdk版本，确保是JDK 8，输出其版本号。 检查Maven版本，确保其使用了国内阿里云镜像仓库。 使用图形化管理工具在MySQL中创建一个数据库，创建一张表，并插入两条数据。 验证开发环境，能够正确运行一个最简单的Spring Boot程序。 "},"第3章 Spring Boot原理剖析/SpringBootHow.html":{"url":"第3章 Spring Boot原理剖析/SpringBootHow.html","title":"第3章 Spring Boot原理剖析","keywords":"","body":"第3章 Spring Boot原理剖析 Spring Boot拥有很多的魔法，大部分基于这样一条原则“约定大于配置”：通过固定的目录结构和优先级，大大简化了程序的开发工作量。同时，Spring Boot也为“个性化”的项目或“个性化”的人提供了配置选项。对我们向客户交付软件产品而言，遵循Spring Boot的“约定”是明智之选。 Spring Boot的启动类和核心注解，是其“自动配置”的的基础。 本章，我们会从项目结构、启动类与核心注解和自动配置原理三个方面简要介绍Spring Boot的原理。需要进一步学习的同学，我推荐“Spring Boot编程思想（核心篇）”这本书，对在项目中针对Spring Boot框架扩展大有裨益。 "},"第3章 Spring Boot原理剖析/3.1structure.html":{"url":"第3章 Spring Boot原理剖析/3.1structure.html","title":"3.1 项目结构","keywords":"","body":"3.1 项目结构 Spring官方为我们生成的项目，都具有固定的项目结构。下面，我们以上一章提供的“Hello Spring Boot”项目为例，来介绍Spring Boot的项目结构。 3.1.1 Maven配置文件 pom.xml文件，maven项目的配置依赖管理文件。其中包含了Spring Boot版本、各种starter和spring-boot-maven-plugin插件。 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE com.example hello 0.0.1-SNAPSHOT HelloSpringBoot My First Spring Boot Project. 1.8 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin spring-boot-starter-parent：是 Spring Boot的版本仲裁中心，其指定了Spring Boot的版本； starter启动器：Spring Boot的各种模块依赖，基于自动配置，为我们做了大量的配置依赖工作； spring-boot-maven-plugin插件： 能够以Maven的方式为应用提供Spring Boot的支持，即为Spring Boot应用提供了执行Maven操作的可能。 能够将Spring Boot应用打包为可执行的jar或war文件，然后以通常的方式运行Spring Boot应用。 这里特别说明一下spring-boot-maven-plugin提供的5个Maven Goals： spring-boot:repackage，默认goal。在mvn package之后，再次打包可执行的jar/war，同时保留mvn package生成的jar/war为.origin； spring-boot:run，运行Spring Boot应用； spring-boot:start，在mvn integration-test阶段，进行Spring Boot应用生命周期的管理； spring-boot:stop，在mvn integration-test阶段，进行Spring Boot应用生命周期的管理； spring-boot:build-info，生成Actuator使用的构建信息文件build-info.properties。 3.1.2 src/main/java 代码主目录，Spring Boot的启动类就在这里。例如，com.example.hello.HelloSpringBootApplication。 启动类管理了其下的各个package的默认扫描，例如扫描其下package中的Controller。 根据项目开发规范，一般而言，其实体类(entity) 、数据访问类(Dao) 、服务类(Service) 、前端控制器(Controller) 、常量接口类(constant) 和一些工具类(utils) 都应该放置在这里。 3.1.3 src/main/resources 各种资源，如配置文件application.properties都应该放在这里。如果你的程序使用了MyBatis，则其mapper文件也应该放在这里的某个子目录下。 静态资源文件存放在static子目录中。如果你的Spring Boot应用是个前后端分离的项目，为了简化部署（只有一台服务器，服务用户人数在50人左右的简单应用），可以将前端vue的对应文件放置在这里，然后使用java -jar xxx.jar就可以运行这个程序了。 动态模板文件存放在templates子目录中。例如项目中的Thymeleaf 模板文件。 3.1.4 src/test/java 顾名思义，这里是单元测试代码的栖身之处。 以第1章 Spring Boot介绍中的“Hello Spring”项目为例，HelloSpringBootApplicationTests这个测试类就存放在这个目录下。 package com.example.hello; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class HelloSpringBootApplicationTests { @Test void contextLoads() { } } "},"第3章 Spring Boot原理剖析/3.2baseConfig.html":{"url":"第3章 Spring Boot原理剖析/3.2baseConfig.html","title":"3.2 基本配置","keywords":"","body":"3.2 基本配置 本小节，分析Spring Boot的基本配置，了解其配置项，方便后续在开发过程中正确配置Spring Boot应用程序。 3.2.1 父级依赖 我们在几乎在所有的Spring Boot项目中，都会看到spring-boot-starter-parent这样的父级依赖。 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE 父级依赖，确定了Spring Boot项目的主版本和 默认依赖： java版本默认使用1.8； 编码格式默认使用utf-8； 提供Dependency Management进行项目依赖的版本管理； 默认的资源过滤与插件管理。 其后的一些启动器（starter），就不需要指定版本了。 org.springframework.boot spring-boot-starter-web 例如上面的web依赖，只需要指定spring-boot-starter-web即可。 但是，在机缘巧合的情况下，我们的项目（很有可能是遗留项目）已经有了parent，那该怎么办呢？ Spring一贯做法是”约定大于配置“，但总会为特殊情况下留下挪腾的空间：使用dependencyManagement方式import pom： org.springframework.boot spring-boot-dependencies 2.2.1.RELEASE pom import 然后，就可以安心地使用项目中的（或组织要求的）parent了。 3.2.2 application.properties Spring Boot使用了一个全局的配置文件application.properties，可以存在于项目的几个地方，其优先级从高到低依次是： 项目根目录config文件夹里面（优先级最高）； 项目根目录； src/main/resources/config/文件夹里面（classpath:/config）； src/main/resources/（classpath:/）（优先级最低）。 Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改，例如修改内嵌的tomcat端口： server.port=8081 server.tomcat.uri-encoding=UTF-8 Spring Boot中可供修改的配置，可参考官方文档或本教程附录2 Spring Boot配置大全。 优先级高的配置内容会覆盖优先级低的配置内容。 级别高的配置会覆盖级别低的相同配置，级别高的配置没有的项，级别低有的项会同样生效。 也就是说，无论级别高低，配置都会生效，只是相同的配置被级别高的配置覆盖。 特别说明的是：在运行时，使用cmd命令行指定特定的配置文件，其优化级最高，优先于应用中的配置文件。 java -jar hello-0.0.1-SNAPSHOT.jar --spring.config.location=D:/work/application.properties 存放在配置文件中的自定义配置，还可以在项目中引用。 例如，我们在application.properties文件中有如下两个自定义配置项： server.port=8081 server.tomcat.uri-encoding=UTF-8 net.xprogrammer.author=Kevin Zhang net.xprogrammer.book=Spring Boot Quickstart. 然后直接在需要使用的地方通过注解@Value(value=\"${config.name}\")就可以绑定到你想要的属性上面。 package com.example.hello.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class SayHelloController { @Value(\"${net.xprogrammer.author}\") private String author; @Value(\"${net.xprogrammer.book}\") private String book; @RequestMapping(\"/hello\") public String sayHello() { return \"Hello Spring Boot. Author=\" + author + \", Book=\" + book; } } 如上面第9-13行，就绑定了application.properties文件中的两个自定义配置项。 其执行结果如下： 3.2.3 application.yml 在 Spring Boot 中，配置文件有两种不同的格式：一个是 properties ，另一个是 yaml 。 application.yml的作用和application.properties一样，用法也一样，只是书写和看起来更方便。 比如上小节中的配置信息，翻译为yaml表示为： server: port: 8081 tomcat: uri-encoding: UTF-8 3.2.4 Profile 在进行实际开发的时候，分为本地环境、测试环境和生产环境，这就需要配置多个配置文件，如端口号等。我们当然可以每更换一个环境就改一次配置，但是十分繁琐。 在Spring Boot中，可以通过Profile（概要文件）实现多场景下的配置切换，方便开发过程中进行测试和生产环境的部署。 下面将大致介绍一下如何使用Spring Boot Profile配置不同环境的配置文件。 例如，开发环境的服务器端口为8080，测试环境中的端口为8081，以这个最简单的场景来描述Profile是如何使用的。 在src/main/resources/下创建 application.properties、application-dev.properties、application-test.properties3个文件。 application.properties文件内容如下：（启用dev profile，这个时候，服务器端口为8080） spring.profiles.active=dev application-dev.properties文件内容如下： server.port=8080 application-test.properties文件内容如下： server.port=8081 如果application.properties文件内容为spring.profiles.active=test则，服务器端口为8081。 3.2.5 Web容器配置 Spring Boot支持内嵌使用Tomcat、Jetty和Undertow三种web容器，其默认配置为Tomcat。 Tomcat：默认的，也是Java程序员最熟悉的容器； Jetty：高并发轻量级服务器 ； Undertow： 红帽公司开源的非常轻量并性能最好的服务器。 在application.properties文件中可为web容器指定一些配置。 server.port=8080 server.context-path=/ # tomcat相关设置 server.tomcat.uri-encoding=UTF-8 只需要引入spring-boot-start-web依赖，默认采用的Tomcat作为容器，其默认配置如下： server.tomcat.accept-count=100 # Maximum queue length for incoming connection requests when all possible request processing threads are in use. server.tomcat.accesslog.buffered=true # Whether to buffer output such that it is flushed only periodically. server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be absolute or relative to the Tomcat base dir. server.tomcat.accesslog.enabled=false # Enable access log. server.tomcat.accesslog.file-date-format=.yyyy-MM-dd # Date format to place in the log file name. server.tomcat.accesslog.pattern=common # Format pattern for access logs. server.tomcat.accesslog.prefix=access_log # Log file name prefix. server.tomcat.accesslog.rename-on-rotate=false # Whether to defer inclusion of the date stamp in the file name until rotate time. server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for the IP address, Hostname, protocol, and port used for the request. server.tomcat.accesslog.rotate=true # Whether to enable access log rotation. server.tomcat.accesslog.suffix=.log # Log file name suffix. server.tomcat.additional-tld-skip-patterns= # Comma-separated list of additional patterns that match jars to ignore for TLD scanning. server.tomcat.background-processor-delay=10s # Delay between the invocation of backgroundProcess methods. If a duration suffix is not specified, seconds will be used. server.tomcat.basedir= # Tomcat base directory. If not specified, a temporary directory is used. server.tomcat.internal-proxies=10\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\ 192\\\\.168\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\ 169\\\\.254\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\ 127\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\ 172\\\\.1[6-9]{1}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\ 172\\\\.2[0-9]{1}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}|\\\\ 172\\\\.3[0-1]{1}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\ 0:0:0:0:0:0:0:1\\\\ ::1 # Regular expression that matches proxies that are to be trusted. server.tomcat.max-connections=10000 # Maximum number of connections that the server accepts and processes at any given time. server.tomcat.max-http-post-size=2MB # Maximum size of the HTTP post content. server.tomcat.max-swallow-size=2MB # Maximum amount of request body to swallow. server.tomcat.max-threads=200 # Maximum amount of worker threads. server.tomcat.min-spare-threads=10 # Minimum amount of worker threads. server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original port value. server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named \"X-Forwarded-Proto\". server.tomcat.protocol-header-https-value=https # Value of the protocol header indicating whether the incoming request uses SSL. server.tomcat.redirect-context-root=true # Whether requests to the context root should be redirected by appending a / to the path. server.tomcat.remote-ip-header= # Name of the HTTP header from which the remote IP is extracted. For instance, `X-FORWARDED-FOR`. server.tomcat.resource.allow-caching=true # Whether static resource caching is permitted for this web application. server.tomcat.resource.cache-ttl= # Time-to-live of the static resource cache. server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI. 要引入Jetty容器，使用如下Maven配置： org.springframework.boot spring-boot-starter-web spring-boot-starter-tomcat org.springframework.boot org.springframework.boot spring-boot-starter-jetty Jetty容器的默认配置如下： server.jetty.acceptors=-1 # Number of acceptor threads to use. When the value is -1, the default, the number of acceptors is derived from the operating environment. server.jetty.accesslog.append=false # Append to log. server.jetty.accesslog.date-format=dd/MMM/yyyy:HH:mm:ss Z # Timestamp format of the request log. server.jetty.accesslog.enabled=false # Enable access log. server.jetty.accesslog.extended-format=false # Enable extended NCSA format. server.jetty.accesslog.file-date-format= # Date format to place in log file name. server.jetty.accesslog.filename= # Log filename. If not specified, logs redirect to \"System.err\". server.jetty.accesslog.locale= # Locale of the request log. server.jetty.accesslog.log-cookies=false # Enable logging of the request cookies. server.jetty.accesslog.log-latency=false # Enable logging of request processing time. server.jetty.accesslog.log-server=false # Enable logging of the request hostname. server.jetty.accesslog.retention-period=31 # Number of days before rotated log files are deleted. server.jetty.accesslog.time-zone=GMT # Timezone of the request log. server.jetty.max-http-post-size=200000B # Maximum size of the HTTP post or put content. server.jetty.selectors=-1 # Number of selector threads to use. When the value is -1, the default, the number of selectors is derived from the operating environment. 要引入Undertow，使用如下Maven配置： org.springframework.boot spring-boot-starter-web spring-boot-starter-tomcat org.springframework.boot org.springframework.boot spring-boot-starter-undertow Undertow典型的配置，使用application.yml配置（顺便熟悉一下yaml配置方式）： # 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程 # 不要设置过大，如果过大，启动项目会报错：打开文件数过多 server: undertow: io-threads: 16 # 阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程 # 它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8 worker-threads: 256 # 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理 # 每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可 buffer-size: 1024 # 每个区分配的buffer数量 , 所以pool的大小是buffer-size * buffers-per-region buffers-per-region: 1024 # 是否分配的直接内存(NIO直接分配的堆外内存) direct-buffers: true Undertow容器的默认配置如下： server.undertow.accesslog.dir= # Undertow access log directory. server.undertow.accesslog.enabled=false # Whether to enable the access log. server.undertow.accesslog.pattern=common # Format pattern for access logs. server.undertow.accesslog.prefix=access_log. # Log file name prefix. server.undertow.accesslog.rotate=true # Whether to enable access log rotation. server.undertow.accesslog.suffix=log # Log file name suffix. server.undertow.buffer-size= # Size of each buffer. server.undertow.direct-buffers= # Whether to allocate buffers outside the Java heap. The default is derived from the maximum amount of memory that is available to the JVM. server.undertow.eager-filter-init=true # Whether servlet filters should be initialized on startup. server.undertow.io-threads= # Number of I/O threads to create for the worker. The default is derived from the number of available processors. server.undertow.max-http-post-size=-1B # Maximum size of the HTTP post content. When the value is -1, the default, the size is unlimited. server.undertow.worker-threads= # Number of worker threads. The default is 8 times the number of I/O threads. 3.2.6 定制banner 为了发挥娱乐精神，Spring Boot启动信息中的banner也是可以定制的。 我个人觉得，这就是一个彩蛋。 "},"第3章 Spring Boot原理剖析/3.3annotation.html":{"url":"第3章 Spring Boot原理剖析/3.3annotation.html","title":"3.3 启动类与核心注解","keywords":"","body":"3.3 启动类与核心注解 在我们实际的工作中，一般都会使用前后端分离机构来构建业务应用系统。一个典型的Spring Boot后台应用以restful方式提供服务。 在Spring Boot后台应用中，我们通常会看到一个含有main方法的启动类被SpringApplication.run方法运行。了解这个启动类，有助于我们对Spring Boot应用加深理解。 3.3.1 启动类 标注@SpringBootApplication注解的类，就是Spring Boot应用程序的启动类。这个启动类中包含main方法。 Spring Boot通过SpringApplication这个类的run方法来加载这个类，运行Spring Boot应用。 package com.example.hello; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class HelloSpringBootApplication { public static void main(String[] args) { SpringApplication.run(HelloSpringBootApplication.class, args); } } run方法做了两件事： 创建SpringApplication对象；在对象初始化时保存事件监听器，容器初始化类以及判断是否为web应用，保存包含main方法的主配置类。 调用run方法；准备spring的上下文，完成容器的初始化，创建，加载等。会在不同的时机触发监听器的不同事件。 /** * Static helper that can be used to run a {@link SpringApplication} from the * specified source using default settings. * @param primarySource the primary source to load * @param args the application arguments (usually passed from a Java main method) * @return the running {@link ApplicationContext} */ public static ConfigurableApplicationContext run(Class primarySource, String... args) { return run(new Class[] { primarySource }, args); } /** * Static helper that can be used to run a {@link SpringApplication} from the * specified sources using default settings and user supplied arguments. * @param primarySources the primary sources to load * @param args the application arguments (usually passed from a Java main method) * @return the running {@link ApplicationContext} */ public static ConfigurableApplicationContext run(Class[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } /** * Create a new {@link SpringApplication} instance. The application context will load * beans from the specified primary sources (see {@link SpringApplication class-level} * documentation for details. The instance can be customized before calling * {@link #run(String...)}. * @param primarySources the primary bean sources * @see #run(Class, String[]) * @see #SpringApplication(ResourceLoader, Class...) * @see #setSources(Set) */ public SpringApplication(Class... primarySources) { this(null, primarySources); } 可以通过阅读Spring Boot源码（如上面的代码片段）和运行时跟踪代码，进一步了解其运行机制。 3.3.2 核心注解 @SpringBootApplication注解就是Spring Boot的核心注解。 几乎所有的Spring Boot应用，都是用@SpringBootApplication这个注解标注的。 /** * Indicates a {@link Configuration configuration} class that declares one or more * {@link Bean @Bean} methods and also triggers {@link EnableAutoConfiguration * auto-configuration}, {@link ComponentScan component scanning}, and * {@link ConfigurationPropertiesScan configuration properties scanning}. This is a * convenience annotation that is equivalent to declaring {@code @Configuration}, * {@code @EnableAutoConfiguration}, {@code @ComponentScan}. * * @author Phillip Webb * @author Stephane Nicoll * @author Andy Wilkinson * @since 1.2.0 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ @AliasFor(annotation = EnableAutoConfiguration.class) Class[] exclude() default {}; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default {}; /** * Base packages to scan for annotated components. Use {@link #scanBasePackageClasses} * for a type-safe alternative to String-based package names. * * Note: this setting is an alias for * {@link ComponentScan @ComponentScan} only. It has no effect on {@code @Entity} * scanning or Spring Data {@link Repository} scanning. For those you should add * {@link org.springframework.boot.autoconfigure.domain.EntityScan @EntityScan} and * {@code @Enable...Repositories} annotations. * @return base packages to scan * @since 1.3.0 */ @AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\") String[] scanBasePackages() default {}; /** * Type-safe alternative to {@link #scanBasePackages} for specifying the packages to * scan for annotated components. The package of each class specified will be scanned. * * Consider creating a special no-op marker class or interface in each package that * serves no purpose other than being referenced by this attribute. * * Note: this setting is an alias for * {@link ComponentScan @ComponentScan} only. It has no effect on {@code @Entity} * scanning or Spring Data {@link Repository} scanning. For those you should add * {@link org.springframework.boot.autoconfigure.domain.EntityScan @EntityScan} and * {@code @Enable...Repositories} annotations. * @return base packages to scan * @since 1.3.0 */ @AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\") Class[] scanBasePackageClasses() default {}; /** * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce * bean lifecycle behavior, e.g. to return shared singleton bean instances even in * case of direct {@code @Bean} method calls in user code. This feature requires * method interception, implemented through a runtime-generated CGLIB subclass which * comes with limitations such as the configuration class and its methods not being * allowed to declare {@code final}. * * The default is {@code true}, allowing for 'inter-bean references' within the * configuration class as well as for external calls to this configuration's * {@code @Bean} methods, e.g. from another configuration class. If this is not needed * since each of this particular configuration's {@code @Bean} methods is * self-contained and designed as a plain factory method for container use, switch * this flag to {@code false} in order to avoid CGLIB subclass processing. * * Turning off bean method interception effectively processes {@code @Bean} methods * individually like when declared on non-{@code @Configuration} classes, a.k.a. * \"@Bean Lite Mode\" (see {@link Bean @Bean's javadoc}). It is therefore behaviorally * equivalent to removing the {@code @Configuration} stereotype. * @since 2.2 * @return whether to proxy {@code @Bean} methods */ @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true; } 通过阅读@SpringBootApplication的源码，发现其由3个注解构成： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 如果我们将@SpringBootApplication注解替换为上面3个注解，效果一样。 package com.example.hello; import org.springframework.boot.SpringApplication; import org.springframework.boot.SpringBootConfiguration; import org.springframework.boot.autoconfigure.AutoConfigurationExcludeFilter; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.context.TypeExcludeFilter; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.ComponentScan.Filter; import org.springframework.context.annotation.FilterType; //@SpringBootApplication @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public class HelloSpringBootApplication { public static void main(String[] args) { SpringApplication.run(HelloSpringBootApplication.class, args); } } 3.3.2.1 @ComponentScan @ComponentScan这个注解在Spring中很重要，它的功能其实就是自动扫描并加载符合条件的组件（比如@Component、@Controller、@RestController、@Service和@Repository等）或者bean定义，最终将这些bean定义加载到Spring IoC容器中。 我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定（通常情况下，我们都不会指定basePackages），则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。这也就是为什么我们一般都是将启动类放到应用的“根包”中，然后在其下再放置各个模块/功能的包。 @ComponentScan告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。 例如，如果你有个类用@Controller注解标识了，那么，如果不加上@ComponentScan自动扫描该controller，那么该Controller就不会被Spring扫描到，也就不会装入Spring容器（IoC）中，因此你配置的这个Controller也没有意义。 下面列出@ComponentScan注解的参数，说明其作用： basePackageClasses：对basepackages()指定扫描注释组件包类型安全的替代。 excludeFilters：指定不适合组件扫描的类型。 includeFilters：指定哪些类型有资格用于组件扫描。 lazyInit：指定是否应注册扫描的beans为lazy初始化。 nameGenerator：用于在Spring容器中的检测到的组件命名。 resourcePattern：控制可用于组件检测的类文件。 scopedProxy：指出代理是否应该对检测元件产生，在使用过程中会在代理风格时尚的范围是必要的。 scopeResolver：用于解决检测到的组件的范围。 useDefaultFilters：指示是否自动检测类的注释 @ComponentScan注解在Spring Boot应用启动类中的存在形式为： @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) 所以，我们同样可以在@SpringBootApplication注解上为其配置参数，以控制组件扫描行为。 /** * Configures component scanning directives for use with @{@link Configuration} classes. * Provides support parallel with Spring XML's {@code } element. * * Either {@link #basePackageClasses} or {@link #basePackages} (or its alias * {@link #value}) may be specified to define specific packages to scan. If specific * packages are not defined, scanning will occur from the package of the * class that declares this annotation. * * Note that the {@code } element has an * {@code annotation-config} attribute; however, this annotation does not. This is because * in almost all cases when using {@code @ComponentScan}, default annotation config * processing (e.g. processing {@code @Autowired} and friends) is assumed. Furthermore, * when using {@link AnnotationConfigApplicationContext}, annotation config processors are * always registered, meaning that any attempt to disable them at the * {@code @ComponentScan} level would be ignored. * * See {@link Configuration @Configuration}'s Javadoc for usage examples. * * @author Chris Beams * @author Juergen Hoeller * @author Sam Brannen * @since 3.1 * @see Configuration */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Repeatable(ComponentScans.class) public @interface ComponentScan { /** * Alias for {@link #basePackages}. * Allows for more concise annotation declarations if no other attributes * are needed &mdash; for example, {@code @ComponentScan(\"org.my.pkg\")} * instead of {@code @ComponentScan(basePackages = \"org.my.pkg\")}. */ @AliasFor(\"basePackages\") String[] value() default {}; /** * Base packages to scan for annotated components. * {@link #value} is an alias for (and mutually exclusive with) this * attribute. * Use {@link #basePackageClasses} for a type-safe alternative to * String-based package names. */ @AliasFor(\"value\") String[] basePackages() default {}; /** * Type-safe alternative to {@link #basePackages} for specifying the packages * to scan for annotated components. The package of each class specified will be scanned. * Consider creating a special no-op marker class or interface in each package * that serves no purpose other than being referenced by this attribute. */ Class[] basePackageClasses() default {}; /** * The {@link BeanNameGenerator} class to be used for naming detected components * within the Spring container. * The default value of the {@link BeanNameGenerator} interface itself indicates * that the scanner used to process this {@code @ComponentScan} annotation should * use its inherited bean name generator, e.g. the default * {@link AnnotationBeanNameGenerator} or any custom instance supplied to the * application context at bootstrap time. * @see AnnotationConfigApplicationContext#setBeanNameGenerator(BeanNameGenerator) */ Class nameGenerator() default BeanNameGenerator.class; /** * The {@link ScopeMetadataResolver} to be used for resolving the scope of detected components. */ Class scopeResolver() default AnnotationScopeMetadataResolver.class; /** * Indicates whether proxies should be generated for detected components, which may be * necessary when using scopes in a proxy-style fashion. * The default is defer to the default behavior of the component scanner used to * execute the actual scan. * Note that setting this attribute overrides any value set for {@link #scopeResolver}. * @see ClassPathBeanDefinitionScanner#setScopedProxyMode(ScopedProxyMode) */ ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; /** * Controls the class files eligible for component detection. * Consider use of {@link #includeFilters} and {@link #excludeFilters} * for a more flexible approach. */ String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN; /** * Indicates whether automatic detection of classes annotated with {@code @Component} * {@code @Repository}, {@code @Service}, or {@code @Controller} should be enabled. */ boolean useDefaultFilters() default true; /** * Specifies which types are eligible for component scanning. * Further narrows the set of candidate components from everything in {@link #basePackages} * to everything in the base packages that matches the given filter or filters. * Note that these filters will be applied in addition to the default filters, if specified. * Any type under the specified base packages which matches a given filter will be included, * even if it does not match the default filters (i.e. is not annotated with {@code @Component}). * @see #resourcePattern() * @see #useDefaultFilters() */ Filter[] includeFilters() default {}; /** * Specifies which types are not eligible for component scanning. * @see #resourcePattern */ Filter[] excludeFilters() default {}; /** * Specify whether scanned beans should be registered for lazy initialization. * Default is {@code false}; switch this to {@code true} when desired. * @since 4.1 */ boolean lazyInit() default false; /** * Declares the type filter to be used as an {@linkplain ComponentScan#includeFilters * include filter} or {@linkplain ComponentScan#excludeFilters exclude filter}. */ @Retention(RetentionPolicy.RUNTIME) @Target({}) @interface Filter { /** * The type of filter to use. * Default is {@link FilterType#ANNOTATION}. * @see #classes * @see #pattern */ FilterType type() default FilterType.ANNOTATION; /** * Alias for {@link #classes}. * @see #classes */ @AliasFor(\"classes\") Class[] value() default {}; /** * The class or classes to use as the filter. * The following table explains how the classes will be interpreted * based on the configured value of the {@link #type} attribute. * * {@code FilterType}Class Interpreted As * {@link FilterType#ANNOTATION ANNOTATION} * the annotation itself * {@link FilterType#ASSIGNABLE_TYPE ASSIGNABLE_TYPE} * the type that detected components should be assignable to * {@link FilterType#CUSTOM CUSTOM} * an implementation of {@link TypeFilter} * * When multiple classes are specified, OR logic is applied * &mdash; for example, \"include types annotated with {@code @Foo} OR {@code @Bar}\". * Custom {@link TypeFilter TypeFilters} may optionally implement any of the * following {@link org.springframework.beans.factory.Aware Aware} interfaces, and * their respective methods will be called prior to {@link TypeFilter#match match}: * * {@link org.springframework.context.EnvironmentAware EnvironmentAware} * {@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware} * {@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware} * {@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware} * * Specifying zero classes is permitted but will have no effect on component * scanning. * @since 4.2 * @see #value * @see #type */ @AliasFor(\"value\") Class[] classes() default {}; /** * The pattern (or patterns) to use for the filter, as an alternative * to specifying a Class {@link #value}. * If {@link #type} is set to {@link FilterType#ASPECTJ ASPECTJ}, * this is an AspectJ type pattern expression. If {@link #type} is * set to {@link FilterType#REGEX REGEX}, this is a regex pattern * for the fully-qualified class names to match. * @see #type * @see #classes */ String[] pattern() default {}; } } 3.3.2.2 @EnableAutoConfiguration @EnableAutoConfiguration简单概括一下就是，借助@Import的支持，收集和注册特定场景相关的bean定义。 而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器中来。 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class[] exclude() default {}; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default {}; } 如上面的@EnableAutoConfiguration所示，其中最关键的要属@Import(AutoConfigurationImportSelector.class)，借助AutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助Spring Boot应用将所有符合条件的@Configuration配置都加载到当前Spring Boot创建并使用的IoC容器中来进行统一管理。 3.3.2.3 @SpringBootConfiguration @SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到Spring容器中，并且实例名就是方法名。 /** * Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * * Application should only ever include one {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}. * * @author Phillip Webb * @author Andy Wilkinson * @since 1.4.0 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration { /** * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce * bean lifecycle behavior, e.g. to return shared singleton bean instances even in * case of direct {@code @Bean} method calls in user code. This feature requires * method interception, implemented through a runtime-generated CGLIB subclass which * comes with limitations such as the configuration class and its methods not being * allowed to declare {@code final}. * * The default is {@code true}, allowing for 'inter-bean references' within the * configuration class as well as for external calls to this configuration's * {@code @Bean} methods, e.g. from another configuration class. If this is not needed * since each of this particular configuration's {@code @Bean} methods is * self-contained and designed as a plain factory method for container use, switch * this flag to {@code false} in order to avoid CGLIB subclass processing. * * Turning off bean method interception effectively processes {@code @Bean} methods * individually like when declared on non-{@code @Configuration} classes, a.k.a. * \"@Bean Lite Mode\" (see {@link Bean @Bean's javadoc}). It is therefore behaviorally * equivalent to removing the {@code @Configuration} stereotype. * @return whether to proxy {@code @Bean} methods * @since 2.2 */ @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true; } "},"第3章 Spring Boot原理剖析/3.4startFlow.html":{"url":"第3章 Spring Boot原理剖析/3.4startFlow.html","title":"3.4 启动过程","keywords":"","body":"3.4 启动过程 跟踪SpringApplication的run方法是我们观察Spring Boot应用是如何启动的主要方法，该方法的主要流程大体可以归纳如下： 1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情： 根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。 推断并设置main方法的定义类。 2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。 3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。 4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。 5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。 6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。 7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。 8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。 9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。 10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。 11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。 12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。 13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理） 去除事件通知点后，整个流程如下： "},"第3章 Spring Boot原理剖析/3.5homework.html":{"url":"第3章 Spring Boot原理剖析/3.5homework.html","title":"3.5 课后作业","keywords":"","body":"3.5 课后作业 解释Spring Boot配置文件（application.properties）的作用，并同时用application.properties和application.yml配置服务器端口为8888。 用内嵌Undertow服务器的方式，开发“Hello Spring Boot”应用程序，并用application.yml配置文件以Profile形式设置开发服务器端口为3525，测试服务器端口为6998。 解释Spring Boot配置文件（application.properties）的存放魏治及对应的优先级。 了解Spring Boot的核心注解。 了解Spring Boot应用的启动过程。 "},"第4章 Spring Boot Web开发/SpringBootWeb.html":{"url":"第4章 Spring Boot Web开发/SpringBootWeb.html","title":"第4章 Spring Boot Web开发","keywords":"","body":"第4章 Spring Boot Web开发 Spring Boot针对Web应用开发，从开发、测试和部署都做了全面地支持，堪称完美。 spring-boot-starter-web是Spring Boot对Web开发提供支持的启动器，主要包括开发RESTful服务的支持、参数校验、使用 Tomcat/Jetty/Undertow作为内嵌容器器等功能。 通常情况下，我们会通过Spring Boot使用Spring MVC模块来支持web开发。 在众多的web MVC框架中，Spring MVC是独树一帜的：方便、高效、够用、和Spring原生集成。所以在和前辈Struts、官方Java Serve Faces的竞争中脱颖而出，几乎成了当前Java EE应用中事实上的MVC标准。 本章，我们会先介绍Spring MVC的特点，结合Spring Boot如何方便地开发RESTful风格地应用。 然后介绍Spring推荐地、替代JSP的模板引擎Thymeleaf，并做简单整合示例。 最后介绍传统Servlet、Listener、Filter和JSP技术如何在Spring Boot中使用，以便兼容以前的遗留应用。 "},"第4章 Spring Boot Web开发/4.1mvc.html":{"url":"第4章 Spring Boot Web开发/4.1mvc.html","title":"4.1 Spring MVC介绍","keywords":"","body":"4.1 Spring MVC介绍 以前，我们大量的使用JSP+Servlet技术开发web应用。通过使用jstl技术（ Java server pages standarded tag library，即JSP标准标签库）封装一些常用组件，简化前端jsp页面的开发。 那个时候时间过得很慢， 慢到只能用一种技术规范， 开发web应用一辈子。 现在，我们更多的是使用前后端分离的MVVM技术来构建web应用。例如前端使用vue，后端使用rest方式（Representational State Transfer）开发业务功能接口，供前端通过ajax方式调用。 MVVM：Model-View-ViewModel的简写，它本质上就是MVC 的改进版。 无论是在以前还是现在，使用Spring开发web应用，首选的都是Spring MVC开发框架。 Spring MVC并不知道前端使用的视图技术，所以不会强迫您只使用 JSP 技术。实际上在Spring Boot 2.0框架中，Spring MVC推荐使用Thymeleaf模板技术。 Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 Spring 的 Web MVC 框架是围绕 DispatcherServlet 前端分发器设计的，它把请求分派给处理程序，同时带有可配置的处理程序映射、视图解析、本地语言（国际化，多语言支持）、主题解析以及上载文件等支持。默认的处理程序是非常简单的 Controller 接口，只有一个方法 ModelAndView handleRequest(request, response)。Spring 提供了一个控制器层次结构，可以派生子类。如果应用程序需要处理用户输入表单，那么可以继承 AbstractFormController。如果需要把多页输入处理到一个表单，那么可以继承 AbstractWizardFormController。 4.1.1 常用注解 Spring MVC在发展过程中也经历了一段“黑暗”时间：非常繁杂的xml配置，简直就是“xml hell”（xml配置地狱，指繁杂到失控的xml配置信息）。后来，使用上注解以后，才简洁易用起来。 所以，要想了解会用Spring MVC就必须掌握其最常用的注解。 4.1.1.1 @Controller 在SpringMVC 中，控制器Controller 负责处理由前端分发器DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。 在Spring MVC中定义一个Controller不需要继承某个父类，也无需实现某个接口。你只需要使用@Controller 标记一个类是Controller即可。 前端分发器DispatcherServlet将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。 各位，是否还记得Spring Boot启动类的注解@SpringBootApplication，这个注解是个复合注解，其中包含@ComponentScan会扫描到启动类包及其子包下的Controller控制器类，并将其加载到Spring容器中。 @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { ... } 4.1.1.2 @RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。 value， method： value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等； consumes，produces： consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params，headers： params： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 4.1.1.2.1 @PathVariables 用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。 @Controller public class TestController { @RequestMapping(value=\"/product/{productId}\",method = RequestMethod.GET) public String getProduct(@PathVariable(\"productId\") String productId){ System.out.println(\"Product Id : \" + productId); return \"hello\"; } @RequestMapping(value=\"/javabeat/{regexp1:[a-z-]+}\", method = RequestMethod.GET) public String getRegExp(@PathVariable(\"regexp1\") String regexp1){ System.out.println(\"URI Part 1 : \" + regexp1); return \"hello\"; } } 4.1.1.2.2 @RequstParams 用于在Spring MVC后台控制层获取参数，类似一种是request.getParameter(\"name\")，它有三个常用参数：defaultValue = \"0\", required = false, value = \"isApp\"；defaultValue 表示设置默认值，required通过boolean值设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。 多数情况下@RequestParam可以省略。 @RequestMapping(\"genUsers\") public String genUsers(@RequestParam int count) { //public String genUsers(int count) { for (int i=2; i 4.1.1.3 @ResponseBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 返回的数据不是html页面，而是其他某种格式的数据时（如json、xml等）使用。 4.1.1.4 @ModelAndView 用来存储处理完后的结果数据，以及显示该数据的视图。从名字上看ModelAndView中的Model代表模型，View代表视图，这个名字就很好地解释了该类的作用。业务处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后让该ModelAndView返回该Spring MVC框架。框架通过调用配置文件中定义的视图解析器，对该对象进行解析，最后把结果数据显示在指定的页面上。 public ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)throws Exception{ ... Map model = new HashMap(); if(courtName != null){ model.put(\"courtName\",courtName); model.put(\"reservations\",reservationService.query(courtName)); } return new ModelAndView(\"reservationQuery\",model); } 4.1.1.5 @RestController @RestController是一个复合注解，其作用等同于@Controller + @ResponseBody。 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController { /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) * @since 4.0.1 */ @AliasFor(annotation = Controller.class) String value() default \"\"; } 这个注解，大量地用在前后端分离的应用中。 4.1.2 Spring MVC剖析 要想彻底掌握Spring MVC，就必须深入其设计、运行机制，才能做到“知其然，也知其所以然”。 当然，彻底掌握任何一个框架，都是通过阅读官方文档（绝大多数时候是英文的）和源码来完成的。 最早，Spring MVC大部分是和JSP一起使用的，这里我们也以JSP为例，以便于讲解其运行机理。 4.1.2.1 加载过程 Spring MVC应用在启动过程中会创建两个Spring容器：基础容器（含@Repository，@Service，@Component等组件）和控制器容器（含@Controller）。 控制器容器容器“继承”自基础容器，所以在我们写的Controller里面可以注入@Service和@Component组件（当然，也可以注入@Repository，只是基于事务管理绝对不推荐这样做），而@Service组件中不能注入@Controller组件。 从依赖倒置原则来讲，@Service组件绝不应该依赖@Controller组件。 项目中，我们写在Controller中的标注了@RequestMapping的方法（如下面代码片段的getUser方法），在启动时会被扫描后装入DispatcherServlet的handlerMappings属性中。 @RestController @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @RequestMapping(\"get/{id}\") public String getUser(@PathVariable int id){ return userService.selectUser(id).toString(); } ... DispatcherServlet的handlerMappings属性中存放了Spring MVC Web应用的所有路径映射处理器。 @SuppressWarnings(\"serial\") public class DispatcherServlet extends FrameworkServlet { ... /** List of HandlerMappings used by this servlet. */ @Nullable private List handlerMappings; ... HandlerMapping接口的最常用实现就是RequestMappingHandlerMapping类，具体继承层级如下图： 当然，启动过程还会在DispatcherServlet对象中加载ViewResolver、MultipartResolver等对象，这里我们不过多介绍。感兴趣的同学可以通过断点Debug的方式详细观察DispatcherServlet的加载过程。 4.1.2.2 前端分发器 DispatcherServlet就是Spring MVC的前端分发器。 在运行时，从前端（一般都是浏览器发起一个http请求）过来的请求，被DispatcherServlet截获后，就调用doDispatch方法，寻求合适的处理器（参考下面代码片段中的第17行，mappedHandler = getHandler(processedRequest)）处理这个请求。 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) { return; } } if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); } processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); } finally { if (asyncManager.isConcurrentHandlingStarted()) { // Instead of postHandle and afterCompletion if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else { // Clean up any resources used by a multipart request. if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } } } 更详细的处理过程，请在运行时跟踪doDispatch了解更多。 4.1.2.3 控制器方法 在Controller中的标注了@RequestMapping的方法就是控制器方法，也叫处理器（handler）。 如前所述，web应用启动时，会将所有的处理器扫描到DispatcherServlet的handlerMappings属性中，供其doDispatch方法匹配合适的处理器，然后执行处理器中的逻辑。 控制器方法（处理器）一般完成前端数据的准备封装工作，然后调用服务层方法完成特定的业务逻辑功能处理。 @RequestMapping(\"get/{id}\") public String getUser(@PathVariable int id){ return userService.selectUser(id).toString(); } 如上，getUser方法就是控制器方法，在运行时就是一个处理器。 4.1.2.4 视图解析器 视图解析器决定了控制器方法返回的视图如何处理，比如InternalResourceViewResolver就是用JSP视图技术的解析器。 其构造器方法，会为其设置视图的前缀和后缀。 public InternalResourceViewResolver(String prefix, String suffix) { this(); setPrefix(prefix); setSuffix(suffix); } 在下面的配置片段场景中，如果控制器方法中返回“hello”字符串，则Spring MVC框架会找到/WEB-INF/views/hello.jsp这个页面，来渲染给浏览器。 4.1.2.5 动态资源 传统上，动态资源就是JSP文件。 一般而言，我们都会为DispatcherServlet配置拦截所有的前端请求，在控制器（Controller）方法返回的视图（View）中加载业务数据（Model）。 dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:META-INF/spring/springmvc-context.xml 1 dispatcherServlet / 4.1.2.6 静态资源 服务器上的视图（页面）资源，不都是JSP文件，还包括JavaScript文件、图片、CSS样式文件等，这些就是静态资源。静态资源都是在客户浏览器端加载的，显然并不需要DispatcherServlet拦截处理，更不能解析到/WEB-INF/views/arrow.png这样的错误位置上。 Spring MVC为静态资源提供了过滤机制。所有过滤掉的静态资源，DispatcherServlet直接放行。 4.1.2.7 一个完整的请求过程 前面，我们已经大致了解了Spring的运行机制，下面以浏览器发起http请求到接收到返回结果的全过程来加深理解Spring MVC的处理流程。 Spring MVC的Spring容器及前端分发器加载SpringMVC.xml配置文件，完成Spring MVC的初始化； 浏览器发起一个http请求（Request），被DispatcherServlet拦截到； DispatcherServlet查询handlerMappings匹配一个handler； 调用handler； handler调用服务层对应的方法，完成业务逻辑处理； 业务逻辑返回的结果被handler包装到一个ModelAndView中； DispatcherServlet通过ViewResolver获取解析视图； 将Model上的数据加载到View上； View（JSP页面）向浏览器返回http响应（Response）。 4.1.3 传统Spring MVC示例 为了更好的观察Spring MVC的配置、加载、运行机制，我们以一个用JSP页面的Spring MVC项目为例，来介绍我们前面介绍到的一些知识点。 本示例，使用的8.5版本的Tomcat。 创建maven项目，选择maven-archetype-webapp骨架。 在pom文件中添加Spring MVC的依赖。 org.springframework spring-webmvc 5.2.1.RELEASE 为项目配置web.xml： spring-mvc-jsp SpringMVC org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:spring-context.xml 1 SpringMVC / index.jsp 为Spring MVC前端分发器DispatcherServlet指定的配置文件为classpath:spring-context.xml。 这个文件中配置了组件扫描路径（12行）、注解驱动（13行）和静态资源过滤（14行）。 为JSP视图解析器InternalResourceViewResolver配置了前缀、后缀属性。 创建一个控制器，提供一个控制器方法（请求处理器），服务项目上下文的/sayHello请求路径，返回一个ModelAndView： Model中存储了模拟服务层返回的sayHello + who + \".\"内容，其键值为sayHello； View指定为/hello，根据视图解析器配置换算成真实文件为/WEB-INF/views/hello.jsp。 package com.example.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class HelloController { @RequestMapping(\"/sayHello\") public ModelAndView sayHello(String who) { ModelAndView mv = new ModelAndView(); //模拟调用Service方法，返回问候语sayHello String sayHello = \"Greeting! Hello \"; mv.addObject(\"sayHello\", sayHello + who + \".\"); mv.setViewName(\"/hello\"); return mv; } } 编写hello.jsp文件，接收Model中携带的sayHello业务对象值（Model）。 并在其中插入一张图片，演示静态资源的使用。 Say Hello to WHO. /images/RoyElephant.png\" width=\"128\" height=\"128\" /> ${sayHello} 运行，测试，正确返回期望的结果。 更进一步：可以在Debug模式下，设置断点，观察其内部数据。如DispatcherServlet的handlerMappings这个List里面注册了我们在控制器里面写的“请求处理器”sayHello(String)这个方法。 以及我们在前面配置的视图处理器InternalResourceViewResolver。 可以清晰地看到当前请求所对应的处理器。 更多源码跟踪解读，请读者自行完成。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-mvc-jsp "},"第4章 Spring Boot Web开发/4.2thymeleaf.html":{"url":"第4章 Spring Boot Web开发/4.2thymeleaf.html","title":"4.2 Thymeleaf介绍","keywords":"","body":"4.2 Thymeleaf介绍 开发传统Java WEB应用时，如上一小节说介绍的，我们可以使用JSP页面模板语言。但是由于JSP的众多缺点，在SpringBoot中已经不推荐使用了。 SpringBoot官方推荐使用Thymeleaf模板语言。 Thymeleaf是一种用于Web和独立环境的现代服务器端的Java模板引擎。 Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中，并将HTML在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。 Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。 当前，在实际工作中，一般都是通过Spring Boot使用Spring MVC，为前端（如vue页面，或手机app）提供服务调用接口。Spring Boot的spring-boot-starter-web启动器为开发者提供了大量的基于约定的配置。 在添加spring-boot-starter-thymeleaf启动器的情况下，Spring Boot使用Thymeleaf作为前端模板。 下面我们结合项目代码来学习如何在Spring Boot中使用Thymeleaf这个模板引擎。 首先创建一个web+thymeleaf的Spring Boot应用。 pom文件中最重要的两个starter依赖如下： org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 创建一个Controller，复用上一小节中的HelloController代码。 package com.example.thymeleaf.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class HelloController { @RequestMapping(\"/sayHello\") public ModelAndView sayHello(String who) { ModelAndView mv = new ModelAndView(); //模拟调用Service方法，返回问候语sayHello String sayHello = \"Greeting! Hello \"; mv.addObject(\"sayHello\", sayHello + who + \".\"); mv.setViewName(\"/hello\"); return mv; } } 将一张图片（例如RoyElephant.png）拷贝到项目的src/main/resources/static/images目录下（需要在static下先创建images目录）。 在/src/main/resources/templates目录下创建一个hello.html文件，其使用了Thymeleaf模板语法。 Say Hello to WHO. 是Thymeleaf的命名空间，通过引入该命名空间就可以在html中使用Thymeleaf标签语言。在html中用th关键字来标注。 注意上面代码中的th:src和th:text，这些th标签会使这个页面在服务器端使用Thymeleaf模板技术进行最后的html文件输出。 打开浏览器，访问 http://localhost:8080/sayHello?who=Kevin ，可以看到，Thymeleaf能够正常工作。 Spring Boot在使用Spring MVC的时候约定了如下两位目录位置： 静态资源位置：src/main/resources/static，其下存放图片、css、js等内容； 模板文件位置：/src/main/resources/templates，其下存放使用th（thymeleaf）标签的html文件。 由于在实际工作中，前后端分离架构的广泛使用，Thymeleaf作为Spring MVC的一种服务端模板技术，能用到的机会还是比较少的。所以我们在这里仅仅是简单得介绍Spring Boot如何使用这个模板技术，更多Thymeleaf的用法，请在需要的时候查阅官方文档了解（拷贝其中得代码，供你的项目使用）。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-thymeleaf "},"第4章 Spring Boot Web开发/4.3legacy.html":{"url":"第4章 Spring Boot Web开发/4.3legacy.html","title":"4.3 使用Servlet、Listener和Filter","keywords":"","body":"4.3 使用Servlet、Listener和Filter 在某些特定的业务场景下，我们可能会对已有的遗留项目进行改造、集成。而这些项目是使用传统Java web技术开发的，其中大量涉及了JSP和Servlet规范，而我们并不能去彻底改造它们，只能集成延用。 或者，我们也会遇到在Spring Boot应用中新开发Servlet之类的需求。 Spring Boot为这些古老的技术规范提供了一定的支持，能够完美的沿用遗留的业务逻辑代码或新建业务逻辑代码（Servlet）。 本小节，我们通过在Spring MVC中使用Thymeleaf技术来学习如何在Spring Boot中使用传统的Servlet、Listener和Filter技术。 4.3.1 Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口，一种古老的技术）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 最新的Servlet规范是4.01(JSR 369)，但是当前使用最多的是 JavaEE7 Servlet 3.1 (JSR 340)。Tomcat 8.0开始支持Servlet 3.1规范。 在Spring Boot中使用遗留Sevlet，可以通过ServletRegistrationBean注册。 @Bean public ServletRegistrationBean registerServlet() { ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean( new HelloServlet(), \"/helloServlet\"); servletRegistrationBean.addInitParameter(\"firstName\", \"Kevin\"); servletRegistrationBean.addInitParameter(\"lastName\", \"Zhang\"); return servletRegistrationBean; } 当然，也可以使用Servlet 3.0+规范的注解方式来开发Servlet，然后配置组件扫描，将其注册到Servlet容器（例如，Tomcat）中。 如上图所示，Servlet 3.0+规范开始提供了这 3 个注解来代替： @WebServlet => 代替 servlet 配置； @WebFilter => 代替 filter 配置； @WebListener => 代替 listener 配置。 package com.example.legacy.servlet; import java.io.IOException; import javax.servlet.annotation.WebInitParam; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(name = \"anotherServlet\", urlPatterns = \"/anotherServlet\", asyncSupported = true, initParams = { @WebInitParam(name = \"firstName\", value = \"Roy\"), @WebInitParam(name = \"lastName\", value = \"Zhang\") }) public class AnotherServlet extends HttpServlet { private static final long serialVersionUID = 2734212784679009034L; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException { String firstName = getServletConfig().getInitParameter(\"firstName\"); String lastName = getServletConfig().getInitParameter(\"lastName\"); resp.getOutputStream().println(\"First Name is \" + firstName); resp.getOutputStream().println(\"Last Name is \" + lastName); } } 正确运行后的效果如下图所示： 需要注意的是，为了安全考虑，内嵌服务器不会直接执行 Servlet 3.0 里面的 javax.servlet.ServletContainerInitializer 接口，或者 Spring 中的 org.springframework.web.WebApplicationInitializer 接口，否则会导致终止 Spring Boot 应用。 所以，如果使用的是 Spring Boot 内嵌服务器，需要在配置类（Spring Boot的启动类也是一个配置类，简单示例中可以将其添加到启动类）上添加额外的 @ServletComponentScan 注解来开启 Servlet 组件扫描功能。如果使用的是独立的服务器，则不需要添加，会使用服务器内部的自动发现机制。 4.3.2 Listerner 监听器用于监听Web应用中某些对象的创建、销毁、增加，修改，删除等动作，然后作出相应的处理。当监听范围的对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计网站在线人数、系统加载时进行信息初始化、统计网站的访问量等等。 Servlet规范中的监听器可分为三类： ServletContext对象的监听器； HttpSession对象的监听器； ServletRequest对象的监听器。 例如，下面是一个ServletContext监听器示例，其监听了Servlet容器的建立和销毁事件。 package com.example.legacy.listener; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; public class HelloListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent servletContextEvent) { System.out.println(\"helloListener: ServletContext Initialized.\"); } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println(\"helloListener: ServletContext Destroyed.\"); } } 在Spring Boot中，和Servlet类似，可以用ServletListenerRegistrationBean将其注册到web容器中。 @Bean public ServletListenerRegistrationBean registerListener() { ServletListenerRegistrationBean listenerRegistrationBean = new ServletListenerRegistrationBean( new HelloListener()); listenerRegistrationBean.setOrder(1); return listenerRegistrationBean; } 其运行效果，如下图所示： 4.3.3 Filter 过滤器可以动态地拦截请求和响应，以转换或使用包含在请求或响应中的信息。 可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前会调用所有附加的 Servlet 过滤器。 Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的： 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 根据规范建议的各种类型的过滤器： 身份验证过滤器（Authentication Filters）。 数据压缩过滤器（Data compression Filters）。 加密过滤器（Encryption Filters）。 触发资源访问事件过滤器。 图像转换过滤器（Image Conversion Filters）。 日志记录和审核过滤器（Logging and Auditing Filters）。 MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。 标记化过滤器（Tokenizing Filters）。 XSL/T 过滤器（XSL/T Filters），转换 XML 内容。 在以前，过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。 当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。 Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。 例如，下面是一个过滤器的代码。 package com.example.legacy.filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"helloFilter init.\"); String firstName = filterConfig.getInitParameter(\"firstName\"); String lastName = filterConfig.getInitParameter(\"lastName\"); System.out.println(\"First Name is \" + firstName); System.out.println(\"Last Name is \" + lastName); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"helloFilter processing.\"); chain.doFilter(request, response); } } 在Spring Boot中，用FilterRegistrationBean将其注册到web容器中。 @Bean public FilterRegistrationBean registerFilter() { FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean( new HelloFilter()); filterRegistrationBean.setName(\"helloFilter\"); filterRegistrationBean.setOrder(1); filterRegistrationBean.addUrlPatterns(\"/\"); filterRegistrationBean.addInitParameter(\"firstName\", \"Kevin\"); filterRegistrationBean.addInitParameter(\"lastName\", \"Zhang\"); return filterRegistrationBean; } 其运行效果，如下图所示： 4.3.4 JSP JSP 与 PHP、ASP、ASP.NET 等语言类似，是一种运行在服务端的视图技术语言。 JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。 JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序，其根本是⼀个简化的 Servlet 设计。JSP文件后缀名为 *.jsp 。 JSP开发的WEB应用可以跨平台使用，既可以运行在 Linux 上也能运行在 Windows 上。 当前，越来越多的项目使用前后端分离技术构建，JSP使用场景越来也少。但是，在某些特殊场景下，需要将使用JSP技术（一般也会同时使用Servlet技术）的遗留系统整合到Spring Boot应用中来，例如整合BIRT开源报表。 在Spring Boot中，使用JSP，首先需要在pom文件中添加 JSP编译器。 org.apache.tomcat.embed tomcat-embed-jasper 然后，为Spring MVC配置JSP视图解析器的前缀后缀。 spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp 接下来，创建/src/main/webapp/WEB-INF/jsp目录，并在其下创建一个JSP文件hello.jsp。 Say Hello to WHO. /images/RoyElephant.png\" width=\"128\" height=\"128\" /> ${sayHello} 在/src/main/resources/static/images下放置图片文件RoyElephant.png，供JSP文件访问静态资源演示用。 最后，创建一个Controller，拦截http请求，并通过JSP页面返回结果。 package com.example.legacy.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class HelloController { @RequestMapping(\"/sayHello\") public ModelAndView sayHello(String who) { ModelAndView mv = new ModelAndView(); //模拟调用Service方法，返回问候语sayHello String sayHello = \"Greeting! Hello \"; mv.addObject(\"sayHello\", sayHello + who + \".\"); mv.setViewName(\"/hello\"); return mv; } } 最后返回的页面结果如下图所示： 4.3.5 Spring Boot集成示例 创建一个Spring Boot项目，选中Spring MVC依赖。 由于需要使用JSP，就要在pom文件中增加tomcat-embed-jasper这个JSP编译器。 org.springframework.boot spring-boot-starter-web org.apache.tomcat.embed tomcat-embed-jasper 在配置文件application.properties中，为JSP视图解析器设置前缀后缀属性。 spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp 创建JSP文件hello.jsp和控制器HelloController。在/src/main/resources/static/images下放置图片文件RoyElephant.png。 创建HelloServlet、HelloFilter和HelloListener类（代码请参考本小节前面的示例代码）。 在启动类中注册上面创建的HelloServlet、HelloFilter和HelloListener类。 在启动类中添加@ServletComponentScan注解，以扫描AnotherServlet类。 启动应用程序，观察运行结果。 访问 localhost:8080/helloServlet ，检查Servlet输出结果。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-legacy "},"第4章 Spring Boot Web开发/4.4homework.html":{"url":"第4章 Spring Boot Web开发/4.4homework.html","title":"4.4 课后作业","keywords":"","body":"4.4 课后作业 使用Spring MVC+Thymeleaf开发一个“用户注册”项目。 在“用户注册”项目中集成JSP、Servlet、Listener和Filter，了解如何兼容遗留系统。 结合“附录1 前后端分离的vue急速入门”的学习，使用vue技术改写“用户注册”项目。 "},"第5章 Spring Boot数据访问/DataAccess.html":{"url":"第5章 Spring Boot数据访问/DataAccess.html","title":"第5章 Spring Boot数据访问","keywords":"","body":"第5章 Spring Boot数据访问 Spring Boot在数据访问方面，做了大量的封装、整合、集成工作。 在Spring Boot官方start.spring.io 中的SQL分类下有16个starter，为开发人员提供了数据库访问方方面面的支持，极大的简化了开发配置工作。 从常见数据库的驱动依赖到JDBC API（通过JdbcTemplate）再到MyBatis持久ORM框架，都提供了完善的starter支持。还进一步提供了Spring Data项目在SQL方面的支持。 Spring Data的任务是为数据访问提供一个熟悉的、一致的、基于Spring的编程模型，同时仍然保留底层数据存储的特殊特性。 它使使用数据访问技术、关系数据库和非关系数据库、map-reduce框架以及基于云的数据服务变得容易。这是一个伞形项目（umbrella project），包含许多特定于给定数据库的子项目。这些项目是通过与这些令人兴奋的技术背后的许多公司和开发人员合作开发的。 本章，我们会从最简单的JdbcTemplate开始介绍，然后介绍MyBatis集成及其分页插件。出于分享的目的，最后简要介绍了MyBatis加强框架（MyBatis-Plus），感兴趣的同学可以参照其官方文档进行系统性学习。 本章不介绍Spring Data JPA方面的内容，虽然其是一个非常强大的框架，提供了非常多的“基于约定”的数据库操作。但正是因为其封装“厚实”，不便于开发过程中对其进行细微调整，也不便于DBA对整个组织、整个项目的数据库架构设计进行规范化管理，所以我们在实际项目总使用得非常少。 当然，后续我们介绍Spring Boot对NoSQL方面的支持时，会使用Spring Data Redis、Spring Data MongoDB这些启动器的。 "},"第5章 Spring Boot数据访问/5.1jdbc.html":{"url":"第5章 Spring Boot数据访问/5.1jdbc.html","title":"5.1 Spring Boot集成JdbcTemplate","keywords":"","body":"5.1 Spring Boot集成JdbcTemplate 原生的jdbc操作并不友好：需要自己加载驱动、创建连接、写数据库查询/薪资/修改/删除的SQL（或调用存储过程）、自己控制事务、完成从数据库返回的ResultSet（java.sql.ResultSet）中取数（字段值）并且再把这些数存放到对象中。整个过程比较复杂，经常重复，并且没有什么技术含量。 针对这种情况，各种ORM（ Object Relational Mapping， 对象关系映射）技术应运而生，解决关系数据库到java对象的匹配问题。在这个领域中，经常使用到的有JPA、Hibernate、MyBatis等ORM框架。 当然，在大部分项目情况下，我们都会直接使用更加强大的持久化框架来访问数据库，比如MyBatis、Hibernate或者Spring Data JPA，但有的时候在项目中也会直接用到原生jdbc来操作数据库。我现在能够想到的唯一原因，就是原生jdbc直接、小巧、不引入第三方库。 但是，在Spring应用中，直接使用jdbc方式已经几乎见不到了。为了方便，Spring对数据库的操作在jdbc上面做了更深层次的封装（也是非常薄的一层封装）。 Spring封装提供的JdbcTemplate就是一个操作数据库的便捷工具。我们可以借助JdbcTemplate来执行所有数据库操作，例如插入，更新，删除和从数据库中检索数据，并且有效避免直接使用jdbc带来的繁琐编码。 JdbcTemplate主要提供以下五种类型的方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句。 update、batchUpdate方法：用于执行新增、修改、删除等语句。 query方法及queryForXXX方法：用于执行查询相关的语句。 call方法：用于执行数据库存储过程和函数相关的语句。 下面我们在Spring Boot应用中引入JdbcTemplate方式操作数据，看看如何将JdbcTemplate技术集成到Spring Boot中去。 5.1.1 新建项目 使用Spring Starter工具新建Spring Boot项目。 注意要选中JDBC API、MySQL Driver和Spring Web的依赖。 JDBC API依赖对应的starter是：spring-boot-starter-jdbc。 项目的pom文件，如下： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE com.example jdbc-template 0.0.1-SNAPSHOT jdbc-template JdbcTemplate Example. 1.8 org.springframework.boot spring-boot-starter-jdbc org.springframework.boot spring-boot-starter-web mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin 项目的配置文件application.yml中配置数据库连接信息。 # mysql数据源配置 spring: datasource: url: jdbc:mysql://localhost:3306/spring_boot_course?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver 需要注意的是：在我们的练习环境中使用的是MySQL 5.7数据库，Spring Boot使用当前的jdbc驱动（8.0.18）application.yml配置需要注意如下两点： url需要设置时区参数，例如jdbc:mysql://localhost:3306/spring_boot_course?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8； jdbc驱动，需要使用com.mysql.cj.jdbc.Driver。 5.1.2 新建Entity类 实体类，一般对应了数据库中的表，其中的每一个属性，对应了表中的一个字段。 package com.example.jdbctemplate.entity; public class User { private Integer id; private String userName; private String passWord; private String realName; （省略getter、setter） @Override public String toString() { return \"User{\" + \"id=\" + id + \", userName='\" + userName + '\\'' + \", passWord='\" + passWord + '\\'' + \", realName='\" + realName + '\\'' + '}'; } } 对应表user的MySQL DDL如下： DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(32) NOT NULL AUTO_INCREMENT, `userName` varchar(32) NOT NULL, `passWord` varchar(50) NOT NULL, `realName` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 插入1条数据，供测试： INSERT INTO `user` VALUES ('1', 'Kevin', '123456', '长的帅'); 5.1.3 新建DAO类 DAO类是通过JdbcTemplate存取数据的关键，并且通过@Repository注解将其纳入Spring容器管理，供其他Spring组件（bean）使用，一般都是注入到Service类中。 package com.example.jdbctemplate.dao; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import com.example.jdbctemplate.entity.User; @Repository public class UserDAO { @Autowired JdbcTemplate jdbcTemplate; public User getUser(int id) { String sql = \"select * from user where id=\" + id; return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<>(User.class)); } } 注意上面代码中的第13-14行，其中直接注入了JdbcTemplate对象，供操作SQL用。 第17-18行，就是使用JdbcTemplate对象完成了一次查询，并且将数据库查询结果（一行数据）封装（BeanPropertyRowMapper）到了一个对象（实体类User对象）中。 JdbcTemplate对象是从哪里来的？那就是Spring Boot Starter（启动器）的魔法了。 在本项目中，spring-boot-starter-jdbc自动在Spring容器中注册了JdbcTemplate对象。 5.1.4 新建Service类 服务类中注入DAO类，在向外提供的服务中需要用数据库操作时，调用DAO对象的对应方法，即可和数据库交互。 package com.example.jdbctemplate.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.example.jdbctemplate.dao.UserDAO; import com.example.jdbctemplate.entity.User; @Service public class UserService { @Autowired UserDAO userDAO; public User getUser(int id) { return userDAO.getUser(id); } } 5.1.5 新建Controller类 新建一个控制器类，在接收到用户请求/user/get/1时通过Service对象中的DAO对象对应方法访问数据库中id=1的这条记录，并通过ResponseBody返回。 package com.example.jdbctemplate.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.jdbctemplate.service.UserService; @RestController @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @RequestMapping(\"get/{id}\") public String getUser(@PathVariable int id) { return userService.getUser(id).toString(); } } 5.2.6 运行验证 运行该项目的启动类JdbcTemplateApplication，在浏览器中访问http://localhost:8080/user/get/1，验证是否可以正确的查询到数据库中的记录。 以上就是如何在Spring Boot中集成JdbcTemplate，使用最简单最原始的SQL与数据库交互的示例。 在大多数情况下，我们都会选择一些ORM技术来与数据库进行交互，下一小节，我们会介绍MyBatis这个ORM框架。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-jdbc "},"第5章 Spring Boot数据访问/5.2myBatis.html":{"url":"第5章 Spring Boot数据访问/5.2myBatis.html","title":"5.2 Spring Boot集成MyBatis","keywords":"","body":"5.2 Spring Boot集成MyBatis MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 官方参考文档，有中文版，描述非常详细，在这里，能解决你的所有疑问。 由于MyBatis在系统复杂性、便捷性和可控性方面找到了一个较好平衡。能够满足DBA对数据库的架构设计，也能满足开发人员对复杂SQL的编写，同时又能满足技术经理/架构师对SQL调优的需求。所以，最近几年来，MyBatis使用得越来越广泛。 要想掌握MyBatis，必须熟悉其几个重要的概念： mapper：映射器，里面存放了增删改查等映射语句和其对应的java接口（在运行时使用 动态代理），通常情况下，我们指一个mapper是在说这个mapper的xml文件和其对应的接口java文件。MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器（mapper）的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 namespace：命名空间。在之前版本的 MyBatis 中，命名空间的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。命名空间的作用有两个。 利用更长的完全限定名来将不同的语句隔离开来，同时将mapper的xml文件和java接口绑定。 将命名空间置于合适的 Java 包命名空间之中，代码会变得更加整洁，也有利于你更方便地使用 MyBatis。 resultType：返回结果类型。例如如一个按照id查询的select语句返回表中一条记录，MyBatis通过mapper，在java中将其映射成一个对象返回。 MyBatis中的概念较多，对应使用到的文件也较多，为了更加形象的理解MyBatis的配置对应关系，我们通过如下Spring Boot项目的MyBatis配置关系示意图，来学习如何正确地将MyBatis的各种元素有机的联系起来。 如上图所示： 红色mapper 2.1指定了项目中mapper映射xml文件（例如上图中的2.1* UserMapper.xml文件，其中存放了select等语句）存放的位置（大多数项目都习惯于将其存放于resources/mapping文件夹下）； 红色namespace命名空间 2.2将本mapper映射xml文件和对应的java接口文件（2.2*）连接起来； 蓝色1.1的type-aliases-package指定了1.2resultType的简写方法（上图中的，1.2User会被MyBatis解释成com.example.mybatis.entity.User）； 蓝色返回类型1.2User（实际上是com.example.mybatis.entity.User）对应的是1.4包下的entity实体类1.3User； 绿色3.1selectUser是一个select查询，其对应的java接口文件中的方法为3.1**selectUser方法，返回类型为蓝色1.2User； 绿色3.1selectUser这个select查询，使用了一个3.2id参数，对应java接口文件3.1 selectUser方法参数3.2id； 紫色4.1@MapperScan(\"com.example.mybatis.mapper\")注解指定了mapper的java接口文件扫描的包位置4.1*，上图中，红色2.2UserMapper接口文件就存放在其中。 application.yml配置文件中（红色2.1）设定了mapper的xml文件存放位置； Spring Boot配置类（本例中将其配置到了Spring Boot的启动类上了）中，设定了mapper的java接口文件扫描位置。在项目启动时，MyBatis将扫描（扫描@Repository注解）到的mapper的java接口文件和mapper的xml动态代理成我们真正用到的Dao类，完成数据库的访问，并返回映射后的java对象，完成ORM（对象关系映射）过程。 Spring Boot通过starter使用MyBatis是非常方便的。 在pom.xml文件中添加mybatis-spring-boot-starter启动器，和MySQL数据的jdbc驱动，就可以使用MyBatis了。 org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.1 mysql mysql-connector-java runtime 需要注意的是：在我们的练习环境中使用的是MySQL 5.7数据库，Spring Boot使用当前的jdbc驱动（8.0.18）application.yml配置需要注意如下两点： url需要设置时区参数，例如jdbc:mysql://localhost:3306/spring_boot_course?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8； jdbc驱动，需要使用com.mysql.cj.jdbc.Driver。 5.2.1 创建项目 首先在STS中创建一个Spring Boot项目，选中的starter有： Spring Web; MySQL Driver; MyBatis Framework. 其pom.xml文件内容如下： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE com.example mybatis 0.0.1-SNAPSHOT MyBatis MyBatis Example. 1.8 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.1 mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin 5.2.2 修改配置文件 在application.yml文件中配置数据库连接信息： # mysql数据源配置 spring: datasource: url: jdbc:mysql://localhost:3306/spring_boot_course?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver # mybatis 配置信息 mybatis: mapper-locations: classpath:mapping/*Mapper.xml type-aliases-package: com.example.mybatis.entity 5.2.3 启动类 启动类，也是一个配置类（@SpringBootApplication是个复合注解），可在上配置MyBatis的扫描注解。 package com.example.mybatis; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\"com.example.mybatis.mapper\") public class MyBatisApplication { public static void main(String[] args) { SpringApplication.run(MyBatisApplication.class, args); } } 其中第8行是添加的MyBatis的mapper扫描包位置。 项目中通常会包含多个业务功能模块，mapper会放置在各自功能模块下的mapper包中，请参考如下代码配置多个扫描包位置： @MapperScan({\"com.example.mybatis.admin.mapper\",\"com.example.mybatis.report.mapper\"}) 5.2.4 实体类 实体类，一般对应了数据库中的表。 package com.example.mybatis.entity; public class User { private Integer id; private String userName; private String passWord; private String realName; （省略getter、setter和toString方法） 对应表user的MySQL DDL如下： DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(32) NOT NULL AUTO_INCREMENT, `userName` varchar(32) NOT NULL, `passWord` varchar(50) NOT NULL, `realName` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 插入1条数据，供测试： INSERT INTO `user` VALUES ('1', 'Kevin', '123456', '长的帅'); 5.2.5 映射器（mapper） mapper的xml文件： select * from user where id = #{id} mapper的java接口文件： package com.example.mybatis.mapper; import org.springframework.stereotype.Repository; import com.example.mybatis.entity.User; @Repository public interface UserMapper { User selectUser(int id); } 注意第7行的注解，标注了这是个受MyBatis管理的DAO类。 5.2.6 服务类 服务类完成业务功能。一般企业应用，都会在服务类中注入DAO来操作数据库。 package com.example.mybatis.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.example.mybatis.entity.User; import com.example.mybatis.mapper.UserMapper; @Service public class UserService { @Autowired UserMapper userMapper; public User selectUser(int id){ return userMapper.selectUser(id); } } 其中第11-12行，就注入了UserMapper这个DAO。 5.2.7 控制器类 控制器类与前端交互，并调用服务类完成业务操作。 package com.example.mybatis.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.mybatis.service.UserService; @RestController @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @RequestMapping(\"get/{id}\") public String getUser(@PathVariable int id){ return userService.selectUser(id).toString(); } } 其中第14-15行，就注入了服务类UserService。 5.2.8 运行验证 运行该项目的启动类MyBatisApplication，在浏览器中访问http://localhost:8080/user/get/1，验证是否可以正确的查询到数据库中的记录。 以上，就是Spring Boot如何集成使用MyBatis的方法。至于进一步的MyBatis进阶使用，会包括在后续的分页插件、MyBatis Plus章节介绍。 更加详细的MyBatis中的SQL映射应该怎么写，请参考官方文档。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-mybatis "},"第5章 Spring Boot数据访问/5.3pageHelper.html":{"url":"第5章 Spring Boot数据访问/5.3pageHelper.html","title":"5.3 MyBatis分页","keywords":"","body":"5.3 MyBatis分页 一旦谈及ORM持久化，就必须涉及其查询结果集的分页问题。 在MyBatis中，一旦涉及分页，基本上都会想到PageHelper这个开源分页插件项目 如果你也在用 MyBatis，建议尝试该分页插件（PageHelper），这一定是最方便使用的分页插件。分页插件支持任何复杂的单表、多表分页。 物理分页：支持常见的 12 种数据库： Oracle,MySql,MariaDB,SQLite,DB2,PostgreSQL,SqlServer 等； 支持多种分页方式： 支持常见的RowBounds(PageRowBounds)，PageHelper.startPage 方法调用， Mapper 接口参数调用； QueryInterceptor 规范： 使用 QueryInterceptor 规范，开发插件更轻松。 PageHelper会使用ThreadLocal获取到同一线程中的变量信息。各个线程之间的Threadlocal不会相互干扰，也就是Thread1中的ThreadLocal1只能获取到Tread1中的变量的信息，不会获取到Thread2中的信息。在多线程环境下，各个Threadlocal之间相互隔离，可以实现不同Thread使用不同的数据源或在不同的Thread中执行不同的SQL语句。 所以，PageHelper利用这一点通过拦截器获取到同一线程中预编译好的SQL语句，然后将SQL语句包装成具有分页功能的SQL语句，并将其再次赋值给下一步操作，这样实际执行的SQL语句就是有了分页功能的SQL语句。 下面，我们先简单介绍在传统Spring中如何使用分页插件，然后再以一个Spring Boot项目来学习其简化的“启动器（starter）”用法。 为什么要用传统Spring方式来介绍？ 因为这样能更好的理解其配置内容的详细信息。 5.3.1 引入分页插件 在 pom.xml 中添加如下依赖： com.github.pagehelper pagehelper 5.1.10 5.3.2 配置拦截器插件 特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置： params=value1 分页插件参数介绍： 分页插件提供了多个可选参数，这些参数使用时，按照上面配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 下面几个参数都是针对默认dialect情况下的参数。使用自定义dialect实现时，下面的参数没有任何作用。 helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby 特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用SqlServer2005 的方式进行分页。 你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNumpages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 5.3.3 Spring Boot集成方式 准备工作：复用上小节的User数据库表和Entity对象。在User表中，插入101条记录。 首先创建一个Spring Boot项目，选中的starter有： Spring Web; MySQL Driver; MyBatis Framework. 然后手动添加pagehelper-spring-boot-starter，以使用PageHelper分页插件。 其pom文件为： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.1.RELEASE com.example.mybatis pagehelper 0.0.1-SNAPSHOT PageHelper MyBatis PageHelper Example. 1.8 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.1 com.github.pagehelper pagehelper-spring-boot-starter 1.2.12 mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin 上面的pom.xml文件中，第32-37行，就是使用PageHelper分页插件的启动器依赖。 5.3.3.1 配置PageHelper参数 使用application.yml为PageHelper配置参数： # 分页插件配置 pagehelper: helper-dialect: mysql reasonable: true support-methods-arguments: true params: count=countsql # mysql数据源配置 spring: datasource: url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver username: root password: 123456 配置参数说明： 属性 作用 说明 helper-dialect 指定数据库 可以不配置，插件会自动检测数据库的类型 reasonable 分页合理化参数，默认值为false 当该参数设置为 true 时，pageNumpages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params 用于从对象中根据属性名取值 可以配置pageNum,pageSize,count,pageSizeZero,reasonable。不配置映射的用默认值。 support-methods-arguments 默认值false 分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 5.3.3.2 创建查询方法 在UserMapper.xml文件中添加查询所有用户的SQL语句。 select * from user 在UserMapper.java文件中添加对应的接口方法。 List selectAllUsers(); 5.3.3.3 服务层方法 在UserService.java文件中创建方法。 public List selectAllUsers(){ return userMapper.selectAllUsers(); } 5.3.3.4 控制层方法 在UserController.java文件中创建处理器getAllUsers方法，访问地址为/user/getAll。 @RequestMapping(\"getAll\") public String getAllUsers(){ int count = 0; List users = userService.selectAllUsers(); if (null != users && users.size() > 0) { count = users.size(); } return \"Find \" + count + \" users.\"; } 在没有分页的情况下，访问 http://localhost:8080/user/getAll 服务器返回“ Find 101 users. ”消息。 5.3.3.5 使用分页 在UserController.java处理器getAllUsers方法的基础上，添加分页设置。 创建方法getPagedAllUsers，访问地址为/user/getPagedAll。 @RequestMapping(\"getPagedAll\") public String getPagedAllUsers(){ int count = 0; PageHelper.startPage(1, 10); List users = userService.selectAllUsers(); if (null != users && users.size() > 0) { count = users.size(); } return \"Using PageHelper. Find \" + count + \" users.\"; } 其中关键的语句为PageHelper.startPage(1, 10);。 访问 http://localhost:8080/user/getPagedAll 服务器返回“Using PageHelper. Find 10 users.”消息。 进一步的，PageHelper的用法，请参考其官方文档。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-pagehelper "},"第5章 Spring Boot数据访问/5.4myBatisPlus.html":{"url":"第5章 Spring Boot数据访问/5.4myBatisPlus.html","title":"5.4 MyBatis-Plus","keywords":"","body":"5.4 MyBatis-Plus MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 MyBatis-Plus愿景： 我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。 5.4.1 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 5.4.2 支持的数据库 mysql 、 mariadb 、 oracle 、 db2 、 h2 、 hsql 、 sqlite 、 postgresql 、 sqlserver 达梦数据库 、 虚谷数据库 、 人大金仓数据库 5.4.3 框架结构 更多关于该工具的信息，包括文档、示例、源码等，请访问官方网站 MyBatis-Plus获取。 "},"第5章 Spring Boot数据访问/5.5homework.html":{"url":"第5章 Spring Boot数据访问/5.5homework.html","title":"5.5 课后作业","keywords":"","body":"5.5 课后作业 在Spring Boot中集成JdbcTemplate，完成一个最简单的数据库操作。 在Spring Boot中集成MyBatis并使用PageHelper分页插件，完成一个最简单的数据库操作。 阅读MyBatis-Plus的官方文档，加深对MyBatis-Plus的了解。 了解Spring Data JPA，尝试在Spring Boot中集成Spring Data JPA，完成一个最简单的数据库操作。 "},"第6章 Spring Boot事务/SpringBootTransaction.html":{"url":"第6章 Spring Boot事务/SpringBootTransaction.html","title":"第6章 Spring Boot事务","keywords":"","body":"第6章 Spring Boot事务 事务管理是企业级应用程序开发中不可或缺的技术，在我们绝大多数的项目中，都会使用到数据库来存储业务数据。几乎所有的数据库操作，都需要事务处理，以保证数据的完整一致性。 事务最终是在数据库层面实现的，而Spring只是以一种比较优雅的方式对其进行封装支持。 在Spring中，既支持编程式事务，又支持声明式事务。 在大多数情况下，声明式事务比编程式事务更方便好用。 随着企业业务的发展，系统也从单体应用向分布式系统扩展。分布式系统虽然拥有优秀的可扩展性，但是事务处理却是一大挑战。Spring Boot支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决一般用途的分布式事务。但是使用分布式事务会增加请求的响应时间，影响系统的TPS，在一些特殊场景下，会利用消息的补偿机制来处理分布式的事务。 本章主要介绍Spring事务处理方法，最后简要介绍如何处理分布式事务。 "},"第6章 Spring Boot事务/6.1transaction.html":{"url":"第6章 Spring Boot事务/6.1transaction.html","title":"6.1 事务介绍","keywords":"","body":"6.1 事务介绍 数据库事务（transaction）是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个数据库事务。 本小节，介绍事务有关的重要概念，希望读者能够认真思考，以便了解Spring是怎样管理事务的。 6.1.1 事务的ACID特性 在任何地方讲到事务，都会提到事务的ACID特性。 事务的ACID特性是由关系数据库系统（DBMS）来实现的，DBMS采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所作的更新，如果某个事务在执行过程中发生错误，就可以根据日志撤销事务对数据库已做的更新，使得数据库同滚到执行事务前的初始状态。 对于事务的隔离性，DBMS是采用锁机制来实现的。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。 6.1.1.1 原子性（Atomicity） 所谓的原子性就是说，在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误时，所有的操作就都会被回滚，整个事务就像从没被执行过一样。 6.1.1.2 一致性（Consistency） 事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。 6.1.1.3 隔离性（Isolation） 所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务所感知。 6.1.1.4 持久性（Durability） 所谓的持久性，就是说一但事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此，数据不会丢失。 6.1.2 传播行为 事务的传播行为（propagation behavior）决定了事务和事务之间如何协作。在程序中当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新的事务，并在自己的事务中运行。Spring定义了七种传播行为： 传播行为 含义 PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。 PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。 PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。 PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务。 Spring在org.springframework.transaction.annotation.Propagation枚举类中定义了上述七个表示传播行为的枚举值： public enum Propagation { REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED), SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS), MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY), REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW), NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED), NEVER(TransactionDefinition.PROPAGATION_NEVER), NESTED(TransactionDefinition.PROPAGATION_NESTED); } 在程序中，通过@Transactional注解的propagation属性设置事务传播行为。 @Transactional(propagation = Propagation.REQUIRED) 6.1.3 隔离级别 隔离级别是指若干个并发的事务之间的隔离程度，与我们开发的时候主要相关的场景包括：脏读取、重复读、幻读。 隔离级别 含义 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别。 ISOLATION_READ_UNCOMMITTED 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 ISOLATION_READ_COMMITTED 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 ISOLATION_REPEATABLE_READ 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的。 我们可以看org.springframework.transaction.annotation.Isolation枚举类中定义了五个表示隔离级别的值： public enum Isolation { DEFAULT(TransactionDefinition.ISOLATION_DEFAULT), READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED), READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED), REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ), SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); } DEFAULT（默认）：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。 READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，与因此很少使用该隔离级别。 READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ（可重复读）：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。 SERIALIZABLE：所有的事务一次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 在程序中，通过@Transactional注解的isolation属性设置事务的隔离级别。 @Transactional(isolation=Isolation.DEFAULT) 6.1.4 脏读 脏读是指一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下： update account set money=money+100 where name=’B’;（此时A通知B） update account set money=money-100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 6.1.5 不可重复读 不可重复取是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一个数据，而事务T2立马修改了这个数据并且提交给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。 不可重复去和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能冲突。 6.1.6 虚读（幻读） 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点与脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如用count查询数据的个数）。 "},"第6章 Spring Boot事务/6.2usingTransaction.html":{"url":"第6章 Spring Boot事务/6.2usingTransaction.html","title":"6.2 事务的使用","keywords":"","body":"6.2 事务的使用 Java EE中访问数据的技术众多，包含了从最基础的JDBC到各种方便快捷的ORM技术，如JTA、Hibernate、MyBatis等。Spring面对众多的数据访问技术，在事务管理API上定义了一个抽象的PlatformTransactionManager接口来隔离事务底层的复杂性，让应用程序开发人员不需要了解底层的事务API就可以得心应手的使用事务管理机制。 Spring在PlatformTransactionManager接口上提供了几类常用的事务管理器： DataSourceTransactionManager CciLocalTransactionManager JtaTransactionManager WebLogicJtaTransactionManager WebSphereUowTransactionManager 我们经常用的MyBatis，通常都是使用的DataSourceTransactionManager这个事务管理器。 6.2.1 编程式事务 编程式事务是指程序员通过程序代码，明确的控制事务的提交、撤回操作，整个过程非常繁杂。现在已经很少使用了，你可能会在一些遗留系统中看到这种用法。 例如下面的“转账”原生JDBC事务代码片段，在Spring出现之前，我们经常用到这样的方式来管理事务。 Connection con = null; try{ con = JdbcUtils.getConnection(); con.setAutoCommit(false); AccountDao dao = new AccountDao(); dao.updateBalance(con,from,-money); //给from减去相应金额 dao.updateBalance(con,to,+money); //给to加上相应金额 con.commit(); //提交事务 } catch (Exception e) { try { con.rollback(); //事务回滚 } catch (SQLException e1) { e.printStackTrace(); } throw new RuntimeException(e); } Spring当然支持编程式事务（虽然强烈不推荐），但也提供了相应的封装。你可以使用TransactionTemplate或者底层的PlatformTransactionManager。对于编程式事务管理，Spring推荐使用TransactionTemplate。 参考如下“转账”代码片段，了解Spring是如何使用TransactionTemplate对编程式事务提供支持的。 @Autowired TransactionTemplate transactionTemplate; @Autowired AccountDao dao; ... //开启“转账”事务 boolean result = transactionTemplate.execute(new TransactionCallback() { @Override public Boolean doInTransaction(TransactionStatus status) { try { dao.updateBalance(con,from,-money); //给from减去相应金额 dao.updateBalance(con,to,+money); //给to加上相应金额 } catch (Exception e) { status.setRollbackOnly(); logger.error(e.getMessage(), e); return false; } return true; } }); 使用PlatformTransactionManager方式的转账”代码片段如下： @Autowired PlatformTransactionManager transactionManager; @Autowired AccountDao dao; ... DefaultTransactionDefinition def = new DefaultTransactionDefinition();//定义事务 def.setReadOnly(false); def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);//隔离级别 def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);//传播策略 TransactionStatus status = transactionManager.getTransaction(def); try { dao.updateBalance(con,from,-money); //给from减去相应金额 dao.updateBalance(con,to,+money); //给to加上相应金额 transactionManager.commit(status);//提交事务 } catch (Exception e) { transactionManager.rollback(status);//回滚事务 throw new RuntimeException(e); } 6.2.2 声明式事务 声明式事务是建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明（或通过基于@Transactional注解的方式），便可以将事务规则应用到业务逻辑中。 事务是典型的切面，声明式事务也是AOP的一个典型应用。 显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。 声明式事务管理有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 下面，以我们常用的MyBatis环境为例，说明声明式事务是如何使用的。 xmlns:tx=\"http://www.springframework.org/schema/tx\" ... classpath:mybatis-config.xml MyBatis自动参与到Spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可。 基于注解的事务管理，只需要在需要事务的类或方法上添加 @Transactional 注解即可。 当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该注解来覆盖类级别的定义。 @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。 Spring在很早以前，也提供配置扫描匹配的方式使用事务，例如如下配置xml片段。 上面配置中的txAdvice配置了事务需要添加到哪些方法上去，并为其指定了事务的传播策略（当然，也可以为其定义事务隔离级别）为REQUIRED。txService切面定义了在哪些包下的类需要应用这个切面。第10行的advisor，将切面和事务方法结合起来，这样，Spring将对com.example.service包下的所有类上的update开头的方法使用REQUIRED事务管理，使用数据库默认的事务隔离配置（Spring默认使用数据库的事务隔离级别）。 6.2.3 类级别事务 在类上使用 @Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT,readOnly=true)注解，表示这个类中的所有public方法都需要事务支持。事务传播策略为REQUIRED，事务隔离级别为DEFAULT。 通常，事务标注在服务层类上面。比如下面代码片段中的UserService类。 @Service @Transactional(readOnly = true) public class UserService { ... 6.2.4 方法级事务 方法级事务标注，同样使用@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT,readOnly=true)注解，并且方法级注解会覆盖类级别注解配置。也就是说方法级事务标注优先于类级别事务标注。 比较常见的一种做法是，在方法级事务标注上使用读写事务。比如下面代码片段中的saveUser方法。 @Service @Transactional(readOnly = true) public class UserService { @Autowired UserMapper userMapper; ... @Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT,readOnly=false) public void saveUser(User user) { userMapper.saveUser(user); } } 6.2.5 Spring Boot中使用事务 Spring Boot为事务的使用做了极大的简化，默认对JDBC、JPA、MyBatis开启了事务管理。 Spring Boot中自动配置事务管理的类是TransactionAutoConfiguration，其依赖于JtaAutoConfiguration、HibernateJpaAutoConfiguration、DataSourceTransactionManagerAutoConfiguration、Neo4jDataAutoConfiguration等。 @Configuration(proxyBeanMethods = false) @ConditionalOnClass(PlatformTransactionManager.class) @AutoConfigureAfter({ JtaAutoConfiguration.class, HibernateJpaAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, Neo4jDataAutoConfiguration.class }) @EnableConfigurationProperties(TransactionProperties.class) public class TransactionAutoConfiguration { ... 我们查看DataSourceTransactionManagerAutoConfiguration可以看到其开启了对声明式事务的支持。 @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ JdbcTemplate.class, PlatformTransactionManager.class }) @AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE) @EnableConfigurationProperties(DataSourceProperties.class) public class DataSourceTransactionManagerAutoConfiguration { @Configuration(proxyBeanMethods = false) @ConditionalOnSingleCandidate(DataSource.class) static class DataSourceTransactionManagerConfiguration { @Bean @ConditionalOnMissingBean(PlatformTransactionManager.class) DataSourceTransactionManager transactionManager(DataSource dataSource, ObjectProvider transactionManagerCustomizers) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(dataSource); transactionManagerCustomizers.ifAvailable((customizers) -> customizers.customize(transactionManager)); return transactionManager; } } } 所以，我们在Spring Boot中使用MyBatis时，就已经支持声明式事务了。 在实际工作中，只需要在类或方法上使用@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT,readOnly=true)注解就可以委托Spring来管理事务了。 例如如下“用户”服务的类，使用@Transactional注解就能完成所有的事务管理工作。 package com.example.mybatis.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Isolation; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; import com.example.mybatis.entity.User; import com.example.mybatis.mapper.UserMapper; @Service @Transactional(readOnly = true) public class UserService { @Autowired UserMapper userMapper; public User selectUser(int id){ return userMapper.selectUser(id); } public List selectAllUsers(){ return userMapper.selectAllUsers(); } @Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT,readOnly=false) public void saveUser(User user) { userMapper.saveUser(user); } } 6.2.6 事务使用最佳实践 在实际项目中，事务是切面到服务层（服务类的服务方法，其中包含了具体的业务逻辑）上。所有的服务编排，都应该在服务层完成：原子服务是一个方法，组合服务也是一个方法。 不允许将@Transactional标注到DAO上； 不允许将@Transactional标注到Controller上； Controller中的handler方法中，只允许调用一个Service方法； 绝对不允许在Controller中的handler方法中编排服务，因为编排服务本身就是业务逻辑，属于服务层。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-transaction "},"第6章 Spring Boot事务/6.3distributedTransaction.html":{"url":"第6章 Spring Boot事务/6.3distributedTransaction.html","title":"6.3 分布式事务","keywords":"","body":"6.3 分布式事务 本小节对分布式事务做概念级的一般性介绍，供读者了解分布式事务概念及常见实现方法。通常情况下，分布式事务都是由平台级架构设计来做的，一般工作中只是遵循架构规范来完成编码实现，所以这里也不做代码示例。 分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 6.3.1 CAP理论 CAP理论是由Eric Brewer在2000年的PODC会议上提出的，该理论在两年后被证明成立：“一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项”。 Consistency：一致性。在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。 对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性。 Availability：可用性。可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是“有限时间内”和“返回结果”。 “有限时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，“有限的时间内”是指系统设计之初就设计好的运行指标，通常不同系统之间有很大的不同，无论如何，对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。 “返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。 Partition tolerance：分区容错性。分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。 网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。 对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。 6.3.2 分布式事务产生的原因 6.3.2.1 数据库分库分表 当数据库单表产生的数据超过1000万条（一般参考值，根据数据库表结构不同而不同），那么就要考虑分库分表，具体分库分表的原理在此不做解释。简单的说就是原来的一个数据库变成了多个数据库。这时候，如果一个操作既访问“数据库01”，又要访问“数据库02”，而且要保证数据的一致性，那么就要用到分布式事务。 6.3.2.2 应用服务化/微服务化 所谓的服务化/微服务化，就是业务按照功能服务进行拆分，以支持系统的扩展。比如原来单机支撑了整个电商网站，现在对整个网站进行拆分，分离出了订单中心、用户中心、库存中心。对于订单中心，有专门的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，库存中心也会有专门的数据库存储库存信息。这时候如果要同时对订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，为了保证数据一致性，就需要用到分布式事务。 以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了，就导致了分布式事务。 6.3.3 TCC-补偿型事务解决方案 TCC指的是Try(尝试)、Confirm（确认）、Cancle（取消）。其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段： Try 阶段主要是对业务系统做检测及资源预留。 Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。 Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 举个例子，假入 Bob 要向 Smith 转账，思路大概是： 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。 优点： 跟两阶段提交（2PC）比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些。 缺点： 缺点还是比较明显的，在2，3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。 6.3.4 基于可靠消息的最终一致性解决方案 基于可靠消息的最终一致性解决方案通常叫做“消息事务”，就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用。它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性。 基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。 我们以订单业务为例，来介绍基于可靠消息的最终一致性分布式事务解决方案。 订单系统流程图： 创建订单之前，创建预发送消息，保存到消息表中，此时消息状态为：未发送； 创建订单，如果创建订单失败则将消息表预发送消息删除； 创建订单成功后，修改消息表预发送消息状态为发送中，并发送消息至MQ； 如果发送消息失败，则订单回滚并删除消息表消息；发送成功则万事大吉。 产品系统流程图： 从MQ消息中间件中监听并消费消息，将json消息转为订单对象； 根据消息编号查询该消息是否已被消费，保证幂等性； 如果消息未被消费（即存在此消息），则产品表扣减库存；如果已经消费（不存在此消息），则不做处理； 产品表扣减库存成功，则删除此消息；扣减失败，则不做处理； 定时任务会定时扫描消息表中超时未被消费的消息，然后尝试重发，如果超过最大重试次数后仍未被消费，则记录日志并通知工作人员进行人工补偿操作。 基于可靠消息的分布式事务虽然不能保证结果的强一致，但是可以通过可靠消息使得结果最终一致。 6.3.5 基于Atomikos的分布式事务解决方案 XA ： XA是一个规范或是一个事务的协议。XA协议由Tuxedo首先提出的，并交给X/Open组织，作为资源管理器（数据库）与事务管理器的接口标准。 ​ XA规范定义了： TransactionManager： 这个TransactionManager可以通过管理多个ResourceManager来管理多个Resouce，也就是管理多个数据源。 XAResource： 针对数据资源封装的一个接口。 两段式提交：多数据源事务提交的机制。 JTA(Java Transaction Manager)： 是Java规范，是XA在Java上的实现。 TransactionManager ： 常用方法，可以开启，回滚，获取事务... XAResouce：资源管理，通过Session来进行事务管理，commit(xid)... XID：每一个事务都分配一个特定的XID。 JTA是如何实现多数据源的事务管理呢？主要的原理就是两阶段提交。 Atomikos是实现JTA事务管理的第三方管理工具。 在业务规模较小的情况下，使用Atomikos是一个可选方案。 "},"第6章 Spring Boot事务/6.4homework.html":{"url":"第6章 Spring Boot事务/6.4homework.html","title":"6.4 课后作业","keywords":"","body":"6.4 课后作业 了解事务的ACID特性，事务隔离级别，事务传播策略。 在使用MyBatis的Spring Boot应用中，使用事务并解释其内部实现原理。 了解分布式系统CAP原理。 了解分布式事务的几种实现。 扩展作业：尝试在网上进一步阅读，完成一个“基于可靠消息的最终一致性事务解决方案”。 "},"第7章 Spring Boot集成Redis/Redis.html":{"url":"第7章 Spring Boot集成Redis/Redis.html","title":"第7章 Spring Boot集成Redis","keywords":"","body":"第7章 Spring Boot集成Redis 在多数业务场景下，我们的客户端（浏览器或手机App）会多次请求服务器上相同的数据，特别是在大规模并发面向C端用户的场景下。例如淘宝商品描述页面，无论是张三访问还是李四访问，只要在商品有效期内（如一周内），其获取的信息都是相同的。在这种情况下，如果每次访问都从数据库（例如价格）、文件（例如商品图片）中读取数据，这样对系统资源的消耗是巨大的。 在计算机领域，一种行之有效的方法就是利用内存速度远远快于磁盘速度的特点设计的缓存解决方案。 Spring Boot对市面上常见的缓存方案都提供了良好的支持。例如EhCache、Redis等。 由于我们在项目中经常大量使用Redis，所以，本章讲解Redis的安装、配置及使用。最后还讲解了如何安装配置Redis集群，并用代码示例了如何在Spring Boot中访问Redis集群服务器。 "},"第7章 Spring Boot集成Redis/7.1redisOverview.html":{"url":"第7章 Spring Boot集成Redis/7.1redisOverview.html","title":"7.1 Redis简介","keywords":"","body":"7.1 Redis简介 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets）与范围查询，bitmaps，hyperloglogs和地理空间（geospatial）索引半径查询。 Redis 内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions）和不同级别的磁盘持久化（persistence），并通过Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。 正是因为上述特性，在企业环境中，Redis被大量使用。 Redis是以源码方式发布的，在Linux、Mac下都需要本地编译后使用。官方并不支持Windows版本，而且在生产环境下也少有见到在Windows下使用Redis的。 在学习过程中，为了简化环境起见，我们选择在Windows下安装Redis预编译版本。 根据Redis官方文档所述，其支持8中数据类型，本小节我们介绍经常使用到的前5种数据类型。 Binary-safe strings. Lists: collections of string elements sorted according to the order of insertion. They are basically linked lists. Sets: collections of unique, unsorted string elements. Sorted sets, similar to Sets but where every string element is associated to a floating number value, called score. The elements are always taken sorted by their score, so unlike Sets it is possible to retrieve a range of elements (for example you may ask: give me the top 10, or the bottom 10). Hashes, which are maps composed of fields associated with values. Both the field and the value are strings. This is very similar to Ruby or Python hashes. Bit arrays (or simply bitmaps): it is possible, using special commands, to handle String values like an array of bits: you can set and clear individual bits, count all the bits set to 1, find the first set or unset bit, and so forth. HyperLogLogs: this is a probabilistic data structure which is used in order to estimate the cardinality of a set. Don't be scared, it is simpler than it seems... See later in the HyperLogLog section of this tutorial. Streams: append-only collections of map-like entries that provide an abstract log data type. They are covered in depth in the Introduction to Redis Streams. 7.1.1 安装 在https://github.com/microsoftarchive/redis/releases 这里下载Windows预编译版本的Redis，为了简便起见，我们选择解压包文件。 下载后，将其解压到用户目录中，例如C:\\Users\\Kevin\\Redis-x64-3.2.100。 双击redis-server.exe运行Redis服务器，可以看到Redis服务在6379端口上已经开放了。 7.1.2 测试 双击redis-cli.exe启动Redis客户端，确定其已经连接到本地Redis服务。 7.1.2.1 字符串的增删改查 输入命令set name 'Kevin'在Redis中增加一个Key-Vaule记录，并使用get name查询对应的值，如下： 输入命令set name 'Roy'，将name更新为Roy，然后再查询其值，如下： 输入命令del name，删除name的值，然后使用查询get name，返回nil。 我们用exists name命令检查name这个key是否再Redis中存在，返回0表示不存在，也就是说上面的删除命令是正确执行了的。 7.1.2.2 List集合的增删改查 Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 一个列表最多可以包含 2^32 - 1 个元素（40多亿）。 输入命令lpush userList 'Kevin' 'Roy'，Redis返回2，说明其存入了两个值。 输入命令lrange userList 0 -1，可以查询到userList这个List中的所有元素。 输入命令rpush userList 'GoodMan'，往List的尾部增加一个元素。 输入命令lpush userList 'Wonderful'，往List的头部增加一个元素。 然后查询所有的List元素，确认Wonderful增加在头部，GoodMan追加在尾部。 输入命令lset userList 1 'Roy Zhang'，将List中的第2个元素（Roy）更新为“Roy Zhang”，查询List确认是否正确修改。 输入命令lrem userList 0 'Wonderful'，删除List中的第1个元素，并查询确认。 7.1.2.3 Set集合的增删改查 Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1（40多亿）。 输入命令sadd userSet 'Kevin' 'Roy' 'GoodMan'，往userSet中添加3个元素。 然后执行命令smembers userSet命令，查询userSet这个Set集合中的元素。 输入命令srem userSet 'GoodMan'，删除userSet中的“GoodMan”元素。 输入命令sadd userSet 'Wonderful'，往userSet这个Set集合中添加“Wonderful”元素。查询后发现新加入的元素添加到了第2位，当然，只是显示问题，Set中的元素本来就没有顺序。 输入命令sadd userSet 'Kevin'，Redis返回0，是因为userSet中本来就有“Kevin”这个元素，所有无法再次添加。 7.1.2.4 Hash集合的增删改查 Redis Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）。 输入命令hset userHset 'user1' 'Kevin'创建Key为userHset的hash集合，往其中添加一条记录：字段为user1，值为Kevin，Redis返回添加成功的记录数为1。 输入命令hset userHset 'user2' 'Roy'，往userHset中添加第2条记录。 使用命令hlen userHset查询Hash集合的记录数，此处应该返回2条。 输入命令hkeys userHset查询Hash集合中所有的字段（Key）。 输入命令hvals userHset查询Hash集合中所有的值（Value）。 输入命令hgetall userHset查询userHset这个哈希集合中的所有字段和值（Key Value）。 输入命令hget userHset 'user1'查询userHset这个哈希集合中Key为user1所对应的值（Value）。 输入命令hset userHset 'user1' 'Kevin Zhang'更新userHset这个哈希集合中Key为user1所对应的值（Value），注意Redis返回0，说明删除操作并不会往Redis中增加记录。 然后使用命令hget userHset 'user1'查询user1，检查值是否被更改。 输入命令hdel userHset user1在userHset这个哈希集合中删除user1和对应的值（当前为Kevin Zhang），Redis返回1，说明删除了一个Key-Value值对。 然后使用命名hgetall userHset检查是否删除成功。 7.1.2.5 Sorted Set集合的增删改查 Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的，但分数(score)却可以重复。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2^32 - 1（40多亿）。 输入命令zadd userZset 1 'Kevin'，为userZset添加成员Kevin，分数为1。 输入命令zadd userZset 2 'Roy'，为userZset添加成员Roy，分数为2。 输入命令zrange userZset 0 -1按照分数从小到大查询集合中的元素。 输入命令zrevrange userZset 0 -1按照分数从大到小查询集合中的元素。 输入命令zscore userZset 'Kevin'查询Kevin这个元素的分数。 输入命令zrem userZset 'Kevin'删除集合中的Kevin这个元素。 "},"第7章 Spring Boot集成Redis/7.2redisIntegration.html":{"url":"第7章 Spring Boot集成Redis/7.2redisIntegration.html","title":"7.2 集成Redis","keywords":"","body":"7.2 集成Redis Spring Boot为集成Redis提供了方便的启动器（Starter），在Spring Boot的自动配置中我们可以看到是通过RedisCacheConfiguration来进行配置的。 在项目中，只需要添加spring-boot-starter-data-redis就可以集成使用Redis了。 org.springframework.boot spring-boot-starter-data-redis 首先新建一个项目，选中Spring Data Redis(Access+Driver)依赖。 然后，在Spring Test类中注入StringRedisTemplate模板类，添加一个测试方法，调用模板类对象操作Redis。 package com.example.redis; import static org.junit.jupiter.api.Assertions.assertEquals; import javax.annotation.Resource; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.StringRedisTemplate; @SpringBootTest class SpringBootRedisApplicationTests { @Resource private StringRedisTemplate strTemplate; @Test public void testRedis() { strTemplate.opsForValue().set(\"name\", \"Kevin\"); String name = strTemplate.opsForValue().get(\"name\"); assertEquals(\"Kevin\", name); } } 运行测试用例： 检查其是否通过测试，JUnit测试，绿色条为测试通过。 在Redis命令行中检查name的值，是否为“Kevin”。 以上就是Spring Boot中集成Redis并使用模板类操作Redis的示例。 通过查阅Spring Boot源码，在RedisTemplate这个类文件中可以非常清晰的看到其对Reidis不同的数据类型提供了不同的操作方法。 由于Redis中我们最经常操作的是数据类型是字符串类型的，所以Spring Boot专门扩展了一个字符串相关的模板类StringRedisTemplate extends RedisTemplate。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-redis "},"第7章 Spring Boot集成Redis/7.3redisSession.html":{"url":"第7章 Spring Boot集成Redis/7.3redisSession.html","title":"7.3 Session共享","keywords":"","body":"7.3 Session共享 在正常情况下，用户访问一个无状态的http请求，服务器为了记住这个用户，会在服务器端启动（这个session第一次访问服务器）/加载一个session，并通过session id来保持用户端和服务器端的“状态”，比如该用户是否已经登录，是否已经分配了对应的角色，是否具有操作某些资源（菜单）的权限等。 服务端的Session在Servlet规范中就是HttpSession：服务器在内存中创建HttpSession，应用程序在这个session对象中保存对象，每次请求来了，判断session对象中存放的值，根据这个值做对应的事（调用后续业务逻辑：登录，或业务操作）。 在单机服务器环境下，上述机制运行得很好，例如Tomcat天生就能解决上面的所有问题。 随着业务的发展，单机性能不能满足系统对并发、响应时间方面的需求，这时，我们就会通过横向扩展搭建服务器集群。为了保证客户访问的一致性（通过一个域名地址访问），我们可以利用一些软件（Nginx）或硬件（F5）来做负载均衡，将前端接收到的访问请求根据负载均衡策略分发到后台的服务器集群中的某一台服务器上。这样，就会导致同一个用户在不同的时间访问的实际服务器是不同的，而不同的服务器内存中的session不能共享，带来一些不希望看到的后果：比如，用户在A服务上登录了，第二次请求被分发到B服务器上，B服务器的session判断用户并没有登录，跳转到登录页面，要求用户登录。这样的体验是错误的，不符合预期的，当然也是非常糟糕的。 在集群/分布式环境下，如何保证各个服务器实例之间的session共享同步，就成了一个必须解决的问题。 Spring Boot提供了自动化的session共享机制，结合Redis可以非常方便地解决这个问题。其设计原理非常简单：就是把原本存放在各个服务器（如tomcat）内存中地session拿出来，集中存放在一个独立地Redis服务器（可以是高可用集群）上，每个服务器都访问这个独立地Redis服务器，这样无论用户的请求被负载均衡器分发到集群中的哪一个服务器上，都访问的是同一个session。 7.3.1 下载并配置Nginx 到官网 http://nginx.org/en/download.html 下载稳定版 nginx/Windows-1.16.1，然后解压到用户目录（C:\\Users\\Kevin\\nginx-1.16.1）下。 编辑C:\\Users\\Kevin\\nginx-1.16.1\\conf\\nginx.conf文件，在http节点下添加upstream，名字为tomcat，并在server的location的proxy_pass下，代理转发到upstream，并为其配置超时参数。 upstream tomcat{ server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=1; } server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://tomcat; proxy_connect_timeout 1; proxy_read_timeout 1; proxy_send_timeout 1; } 这样，就配置好了一个简单的负载均衡器，我们可以通过http://localhost访问后面两台tomcat服务器（分别在端8080和8081上，权重都为1，也就是说每台服务器承载50%的流量）。 7.3.2 开发示例代码 继续使用上一小节创建的Spring Boot工程，添加Session共享支持。 org.springframework.session spring-session-data-redis org.springframework.boot spring-boot-starter-data-redis org.springframework.boot spring-boot-starter-web 在application.properties中配置Redis服务器信息。 spring.redis.database=0 spring.redis.host=localhost spring.redis.port=6379 spring.redis.password= 创建一个RedisSessionController控制器，在访问/redis/save时将信息存放到session中。 package com.example.redis.controller; import javax.servlet.http.HttpSession; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/redis\") public class RedisSessionController { @Value(\"${server.port}\") String port; @RequestMapping(\"/save\") public String save(HttpSession session) { session.setAttribute(\"name\", \"Kevin\"); return \"success\"; } @RequestMapping(\"/get\") public String get(HttpSession session) { String name = (String) session.getAttribute(\"name\"); return name + \", from Server Port: \" + port; } } 在同一个session的后续访问/redis/get时，从session中取出之前存放的name值，并给出当前服务器的端口，以指示是从哪个服务器访问的。 7.3.3 测试 双击C:\\Users\\Kevin\\Redis-x64-3.2.100\\redis-server.exe运行Redis服务器。 在STS中把项目导出为可运行jar包，然后打开两个命令行终端，分别执行如下语句，启动两个tomcat服务器，将示例项目分别运行于8080和8081端口。 java -jar redis-0.0.1-SNAPSHOT.jar --server.port=8080 java -jar redis-0.0.1-SNAPSHOT.jar --server.port=8081 双击C:\\Users\\Kevin\\nginx-1.16.1\\nginx.exe运行Nginx负载均衡服务器。 打开浏览器，访问 http://localhost/redis/save 将Kevin值存放到session中的name这个key中。 访问 http://localhost/redis/get 检查当前session中存放的name值。当前是由8081服务器提供服务。 刷新浏览器，同一session将访问到另外一台服务器（端口为8080），能正确获取session中的name值。 正常情况下，刷新浏览器，会由8080和8081两台tomcat服务器交替提供服务。 由于我们配置的两台tomcat服务器的负载均衡权重都是1，正常情况下刷新一次就可以访问到另外一台服务器，如果没有访问到另外一台服务器，读者可以尝试这多刷新几次，就可以看到上面的测试结果。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-redis "},"第7章 Spring Boot集成Redis/7.4redisCluster.html":{"url":"第7章 Spring Boot集成Redis/7.4redisCluster.html","title":"7.4 Redis集群","keywords":"","body":"7.4 Redis集群 Redis官方不支持Windows，所以，这一小节我们以macOS操作系统为例，来搭建Redis集群，Linux（如CentOS）下的集群搭建步骤和macOS相同。 本小节参考官方集群搭建文档说明来在本机上搭建三主三从的集群，端口分布为7001-7006。 Redis集群需要至少3个节点，主从复制集群至少需要6个节点。否则会提示如下错误信息： *** ERROR: Invalid configuration for cluster creation. *** Redis Cluster requires at least 3 master nodes. *** This is not possible with 2 nodes and 1 replicas per node. *** At least 6 nodes are required. 7.4.1 下载安装 在官方下载最新的稳定版Redis 5.0.7，将下载的文件redis-5.0.7.tar.gz拷贝到用户目录下。 打开终端，输入tar -zxf redis-5.0.7.tar.gz将其解压到/Users/kevin/redis-5.0.7目录。 进入Redis目录（/Users/kevin/redis-5.0.7）后输入make install编译安装Redis服务器。 你的mac可能会出现xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun错误，可以执行xcode-select --install命令，安装编译依赖环境。 7.4.2 单机配置 我们编译安装完Redis后，建议先配置单机环境，检查Redis服务器是否能正常工作。 为了方便文件分类存放，建议创建配置etc和数据库db目录。 mkdir etc mkdir db 在/Users/kevin/redis-5.0.7/etc/redis-single-7001.conf配置文件中配置Redis参数。 #修改为守护模式 daemonize yes #设置进程锁文件 pidfile /Users/kevin/redis-5.0.7/db/redis-7001.pid #ip地址 bind 127.0.0.1 #端口 port 7001 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /Users/kevin/redis-5.0.7/logs/redis-7001.log #设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump-7001.rdb #指定本地数据库路径 dir /Users/kevin/redis-5.0.7/db/ #指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中 appendonly no #指定更新日志条件，共有3个可选值： #no：表示等操作系统进行数据缓存同步到磁盘（快） #always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） #everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 在命令终端执行如下命令，在7001端口上启动Redis单机服务器。 /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-single-7001.conf 输入命令ps -ef | grep redis检查Redis是否在7001端口上启动。 kevin@KevindeMacBook-Pro src % ps -ef | grep redis 501 2048 1 0 9:12上午 ?? 0:00.84 /Users/kevin/redis-5.0.7/src/redis-server *:7001 501 2070 943 0 9:15上午 ttys000 0:00.00 grep redis 在命令终端执行命令redis-cli -h 127.0.0.1 -p 7001，启动Redis客户端，往Redis中添加一条记录并获取，检查是否正确保存和查询记录。 kevin@KevindeMacBook-Pro src % /Users/kevin/redis-5.0.7/src/redis-cli -h 127.0.0.1 -p 7001 127.0.0.1:7001> set name 'Kevin' OK 127.0.0.1:7001> get name \"Kevin\" 127.0.0.1:7001> 7.4.3 集群配置 本测试集群为6台在本地机器上的Redis服务器，只是端口号不同。 将redis-single-7001.conf配置文件拷贝为redis-7001.conf，并在文件末尾添加集群配置内容。 #开启集群 cluster-enabled yes #该节点的对应的节点配置文件 cluster-config-file redis-7001.conf #集群超时时间 cluster-node-timeout 5000 完整的配置文件如下： #修改为守护模式 daemonize yes #设置进程锁文件 pidfile /Users/kevin/redis-5.0.7/db/redis-7001.pid #ip地址 bind 127.0.0.1 #端口 port 7001 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /Users/kevin/redis-5.0.7/logs/redis-7001.log #设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump-7001.rdb #指定本地数据库路径 dir /Users/kevin/redis-5.0.7/db/ #指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中 appendonly no #指定更新日志条件，共有3个可选值： #no：表示等操作系统进行数据缓存同步到磁盘（快） #always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） #everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec #开启集群 cluster-enabled yes #该节点的对应的节点配置文件 cluster-config-file redis-7001.conf #集群超时时间 cluster-node-timeout 5000 拷贝redis-7001.conf为7002-7006，并修改文件中的所有的7001为对应端口，然后保存。 使用查找替换功能，将redis-7001.conf文件中的所有7001替换为7002，7003... 分别启动7001-7006服务器。 /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-7001.conf /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-7002.conf /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-7003.conf /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-7004.conf /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-7005.conf /Users/kevin/redis-5.0.7/src/redis-server /Users/kevin/redis-5.0.7/etc/redis-7006.conf 执行ps -ef | grep redis命令，检查六台Redis服务器是否正确启动。 kevin@KevindeMacBook-Pro src % ps -ef | grep redis 501 2209 1 0 10:14上午 ?? 0:01.43 /Users/kevin/redis-5.0.7/src/redis-server 127.0.0.1:7001 [cluster] 501 2212 1 0 10:15上午 ?? 0:01.35 /Users/kevin/redis-5.0.7/src/redis-server 127.0.0.1:7002 [cluster] 501 2229 1 0 10:19上午 ?? 0:00.14 /Users/kevin/redis-5.0.7/src/redis-server 127.0.0.1:7003 [cluster] 501 2231 1 0 10:19上午 ?? 0:00.13 /Users/kevin/redis-5.0.7/src/redis-server 127.0.0.1:7004 [cluster] 501 2233 1 0 10:19上午 ?? 0:00.10 /Users/kevin/redis-5.0.7/src/redis-server 127.0.0.1:7005 [cluster] 501 2235 1 0 10:19上午 ?? 0:00.09 /Users/kevin/redis-5.0.7/src/redis-server 127.0.0.1:7006 [cluster] 501 2237 943 0 10:20上午 ttys000 0:00.00 grep redis 执行命令redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1创建集群。 /Users/kevin/redis-5.0.7/src/redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 如果你严格按照本小节的步骤操作，很有可能要报错，错误信息如下： [ERR] Node 127.0.0.1:7001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0. 原因如上面错误提示“contains some key in database 0”，是因为我们之前的测试数据本地落盘后数据库中有记录了。解决办法是删除/Users/kevin/redis-5.0.7/db目录下的所有文件。 然后再次执行命令redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1创建集群。 输入yes确认信息后，Redis开始创建主从复制集群，耐心等待（时间应该少于2分钟），直到集群创建完成。 使用命令redis-cli -h 127.0.0.1 -p 7003 -c cluster nodes连接到任意集群节点服务器（这里我们连接的是7003端口的那台Redis服务器），检查集群节点情况。 kevin@KevindeMacBook-Pro src % redis-cli -h 127.0.0.1 -p 7003 -c cluster nodes 96566556628bcea7deff9f50cb8b59b77c2fad6b 127.0.0.1:7005@17005 slave acbb54dc08ee4525ee0b978b16c7b1495fe0fc90 0 1575081455088 5 connected 5ed24cb77a7775a9887ceeff19650393b70e08e5 127.0.0.1:7002@17002 master - 0 1575081456099 2 connected 5461-10922 f21ed6f9cce15836d288184d3db363fe7e4b1d71 127.0.0.1:7006@17006 slave 5ed24cb77a7775a9887ceeff19650393b70e08e5 0 1575081455086 6 connected 78d9c15de0020fb110aefe9fc8dad85bffad2e55 127.0.0.1:7004@17004 slave 6a6c66c8863a9718ced1a91d2cb08d5b82da384f 0 1575081454073 4 connected 6a6c66c8863a9718ced1a91d2cb08d5b82da384f 127.0.0.1:7003@17003 myself,master - 0 1575081454000 3 connected 10923-16383 acbb54dc08ee4525ee0b978b16c7b1495fe0fc90 127.0.0.1:7001@17001 master - 0 1575081454000 1 connected 0-5460 使用命令redis-cli --cluster check 127.0.0.1:7002检查集群情况。 kevin@KevindeMacBook-Pro src % redis-cli --cluster check 127.0.0.1:7002 127.0.0.1:7002 (5ed24cb7...) -> 0 keys | 5462 slots | 1 slaves. 127.0.0.1:7003 (6a6c66c8...) -> 0 keys | 5461 slots | 1 slaves. 127.0.0.1:7001 (acbb54dc...) -> 0 keys | 5461 slots | 1 slaves. [OK] 0 keys in 3 masters. 0.00 keys per slot on average. >>> Performing Cluster Check (using node 127.0.0.1:7002) M: 5ed24cb77a7775a9887ceeff19650393b70e08e5 127.0.0.1:7002 slots:[5461-10922] (5462 slots) master 1 additional replica(s) M: 6a6c66c8863a9718ced1a91d2cb08d5b82da384f 127.0.0.1:7003 slots:[10923-16383] (5461 slots) master 1 additional replica(s) S: f21ed6f9cce15836d288184d3db363fe7e4b1d71 127.0.0.1:7006 slots: (0 slots) slave replicates 5ed24cb77a7775a9887ceeff19650393b70e08e5 M: acbb54dc08ee4525ee0b978b16c7b1495fe0fc90 127.0.0.1:7001 slots:[0-5460] (5461 slots) master 1 additional replica(s) S: 78d9c15de0020fb110aefe9fc8dad85bffad2e55 127.0.0.1:7004 slots: (0 slots) slave replicates 6a6c66c8863a9718ced1a91d2cb08d5b82da384f S: 96566556628bcea7deff9f50cb8b59b77c2fad6b 127.0.0.1:7005 slots: (0 slots) slave replicates acbb54dc08ee4525ee0b978b16c7b1495fe0fc90 [OK] All nodes agree about slots configuration. >>> Check for open slots... >>> Check slots coverage... [OK] All 16384 slots covered. 7.4.4 集群测试 使用命令redis-cli -c -h 127.0.0.1 -p 7002启动Redis客户端，连接到集群中的7002服务器，往Redis集群中添加一条记录并获取，检查是否正确保存和查询记录。 kevin@KevindeMacBook-Pro src % redis-cli -c -h 127.0.0.1 -p 7002 127.0.0.1:7002> set name 'Kevin' OK 127.0.0.1:7002> get name \"Kevin\" 127.0.0.1:7002> 退出连接7002服务器的Redis客户端。使用命令redis-cli -c -h 127.0.0.1 -p 7005启动Redis客户端，连接到集群中的7005服务器，在Redis集群中获取刚才通过7002服务器添加的name=Kevin的那条记录。 kevin@KevindeMacBook-Pro src % redis-cli -c -h 127.0.0.1 -p 7005 127.0.0.1:7005> get name -> Redirected to slot [5798] located at 127.0.0.1:7002 \"Kevin\" 127.0.0.1:7002> 经检查，集群可以正常工作。 如果是生产环境下的Redis集群，不要忘了使用redis-benchmark -h 127.0.0.1 -p 7006 -c 100 -n 10000命令检查服务器性能。 100个并发连接，10000个请求，检测host为127.0.0.1端口为7006的redis服务器性能 如上图所示，在我的MacBook Pro（i5+8G内存）笔记本上，每秒能处理7万多个请求，超过98%的请求响应时间少于2毫秒。 7.4.5 Spring Boot使用Redis集群 在Spring Boot 1.x系列中，访问Redis使用的客户端是Jedis，但是到了Spring Boot 2.x使用的客户端是Lettuce。 关于Jedis跟Lettuce的区别如下： Lettuce 和 Jedis 的定位都是Redis的Client，所以他们都可以直接连接Redis Server。 Jedis在实现上是直接连接的Redis Server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接。 Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，因为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 所以，在Spring Boot 2.x中使用Redis集群，建议最好使用Lettuce连接Redis集群服务器。 在Spring Boot中访问单机Redis服务器和集群服务器，差别在于配置，最终代码都是使用StringRedisTemplate（或RedisTemplate）模板类来操作Redis数据。 在配置文件application.yml中添加Redis集群配置。 server: port: 8080 spring: redis: timeout: 6000ms cluster: max-redirects: 3 nodes: - 127.0.0.1:7001 - 127.0.0.1:7002 - 127.0.0.1:7003 - 127.0.0.1:7004 - 127.0.0.1:7005 - 127.0.0.1:7006 编写RedisController控制器类，测试访问和保存Redis集群服务器中值对记录。 package com.example.redis.controller; import javax.annotation.Resource; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/redis/cluster\") public class RedisController { @Resource private StringRedisTemplate strTemplate; @RequestMapping(\"/save\") public String save(String key, String value) { strTemplate.opsForValue().set(key, value); return \"success.\"; } @RequestMapping(\"/get\") public String get(String key) { String value = strTemplate.opsForValue().get(key); return value; } } 在浏览器中访问http://localhost:8080/redis/cluster/get?key=name这个地址，访问之前集群测试中放入到Redis集群中的name这个key对应的值。 在浏览器中访问http://localhost:8080/redis/cluster/save?key=age&value=18这个地址，将age=18这个Key-Value值对存入Redis集群中。 在浏览器中访问http://localhost:8080/redis/cluster/get?key=age这个地址，访问Redis集群服务器中的age这个key对应的值。 在命令终端中，连接到Redis集群的7005服务器，查询name和age，可以看到name存放在7002服务器的slot中，age存放在7001服务器的slot中。 kevin@KevindeMacBook-Pro src % redis-cli -c -h 127.0.0.1 -p 7005 127.0.0.1:7005> get name -> Redirected to slot [5798] located at 127.0.0.1:7002 \"Kevin\" 127.0.0.1:7002> get age -> Redirected to slot [741] located at 127.0.0.1:7001 \"18\" 通过redis-cli --cluster check 127.0.0.1:7002命令再次检查集群服务器，能够看到[OK] 2 keys in 3 masters.信息，就是我们上面通过命令存入Redis集群的name和通过Spring Boot应用存入的age这两条记录了。 kevin@KevindeMacBook-Pro src % redis-cli --cluster check 127.0.0.1:7002 127.0.0.1:7002 (5ed24cb7...) -> 1 keys | 5462 slots | 1 slaves. 127.0.0.1:7003 (6a6c66c8...) -> 0 keys | 5461 slots | 1 slaves. 127.0.0.1:7001 (acbb54dc...) -> 1 keys | 5461 slots | 1 slaves. [OK] 2 keys in 3 masters. 0.00 keys per slot on average. >>> Performing Cluster Check (using node 127.0.0.1:7002) M: 5ed24cb77a7775a9887ceeff19650393b70e08e5 127.0.0.1:7002 slots:[5461-10922] (5462 slots) master 1 additional replica(s) M: 6a6c66c8863a9718ced1a91d2cb08d5b82da384f 127.0.0.1:7003 slots:[10923-16383] (5461 slots) master 1 additional replica(s) S: f21ed6f9cce15836d288184d3db363fe7e4b1d71 127.0.0.1:7006 slots: (0 slots) slave replicates 5ed24cb77a7775a9887ceeff19650393b70e08e5 M: acbb54dc08ee4525ee0b978b16c7b1495fe0fc90 127.0.0.1:7001 slots:[0-5460] (5461 slots) master 1 additional replica(s) S: 78d9c15de0020fb110aefe9fc8dad85bffad2e55 127.0.0.1:7004 slots: (0 slots) slave replicates 6a6c66c8863a9718ced1a91d2cb08d5b82da384f S: 96566556628bcea7deff9f50cb8b59b77c2fad6b 127.0.0.1:7005 slots: (0 slots) slave replicates acbb54dc08ee4525ee0b978b16c7b1495fe0fc90 [OK] All nodes agree about slots configuration. >>> Check for open slots... >>> Check slots coverage... [OK] All 16384 slots covered. 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-redis "},"第7章 Spring Boot集成Redis/7.5homework.html":{"url":"第7章 Spring Boot集成Redis/7.5homework.html","title":"7.5 课后作业","keywords":"","body":"7.5 课后作业 配置开启一个Redis服务器，在Redis客户端练习五种数据类型的增删改查操作。 尝试配置（使用CentOS操作系统）一个Redis（版本5.0.7）集群，并使用Redis客户端测试其是否正确工作。 在Spring Boot项目中集成Redis，并做简单的Redis操作测试。 在Spring Boot项目中练习“使用Redis做Session共享”。 "},"第8章 Spring Boot集成MongoDB/MongoDB.html":{"url":"第8章 Spring Boot集成MongoDB/MongoDB.html","title":"第8章 Spring Boot集成MongoDB","keywords":"","body":"第8章 Spring Boot集成MongoDB MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB 不是芒果（Mango），mongo来自于humongous（巨大的；庞大的）这个单词的中间部分，象征着大数据，MongoDB顾名思义就是“大数据的数据库”，而不是什么“芒果数据库”。 由于MongoDB的各种特性，我们会经常在项目中用到这种数据库。 Flowable使用MongoDB处理历史数据以加快流程引擎的处理效率。 在数据清洗环节，先把格式不规范的数据落地到MongoDB中，清洗后再存入MySQL中。 本章，我们会简要介绍MongoDB的安装、配置和用法，然后再结合Spring Boot讲解如何在实际项目中集成MongoDB，以达到快速实现项目业务需求的目的。 "},"第8章 Spring Boot集成MongoDB/8.1mongoDBOverview.html":{"url":"第8章 Spring Boot集成MongoDB/8.1mongoDBOverview.html","title":"8.1 MongoDB简介","keywords":"","body":"8.1 MongoDB简介 MongoDB是用C++语言编写的非关系型数据库。特点是高性能、易部署、易使用，存储数据十分方便，主要特性有： 面向集合存储，易于存储对象类型的数据； 模式自由； 支持动态查询； 支持完全索引，包含内部对象； 支持复制和故障恢复； 使用高效的二进制数据存储，包括大型对象； 文件存储格式为BSON（一种JSON的扩展）； MongoDB有广泛的使用场景，是传统关系型数据的有效补充。 网站数据：MongoDB非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 缓存：由于性能很高，MongoDB也适合作为信息基础设施的缓存层。在系统重启之后，由MongoDB搭建的持久化缓存可以避免下层的数据源过载。 大尺寸、低价值的数据：使用传统的关系数据库存储一些数据时可能会比较贵，在此之前，很多程序员往往会选择传统的文件进行存储。 高伸缩性的场景：MongoDB非常适合由数十或者数百台服务器组成的数据库。 用于对象及JSON数据的存储：MongoDB的BSON数据格式非常适合文档格式化的存储及查询。 2018年6月，MongoDB在4.0版本中支持ACID事务，成为第一个支持强事务的NoSQL数据库，更加扩大了其使用的范围。 8.1.1 基本概念 在关系型数据库中，主要由数据库（database）、表（table）、记录（rows）三个层次概念组成。 在MongoDB数据库中，主要由数据库（database）、集合（collection）、文档对象（document）三个层次概念组成。 对比项 MongoDB MySQL/Oracle 表 集合 二维表table 表的一行数据 文档document 一条记录record 表字段 键key 字段field 字段值 值value 值value 主外键 无 PK，FK 灵活度扩展性 极高 差 MongoDB里的集合对应于关系型数据库里的表，但是集合中没有列、行和关系的概念，集合中只有文档，一个文档就相当于一条记录，这体现了模式自由的特点。 文档（document）是MongoDB中数据的基本单元，非常类似于关系型数据库系统中的行（但是比行要复杂的多）; 集合（collection）就是一组文档，如果说MongoDB中的文档类似于关系型数据库中的行，那么集合就如同表; 如下为官方给出的文档（document）示例，是典型的json数据。 { \"_id\": \"5cf0029caff5056591b0ce7d\", \"firstname\": \"Jane\", \"lastname\": \"Wu\", \"address\": { \"street\": \"1 Circle Rd\", \"city\": \"Los Angeles\", \"state\": \"CA\", \"zip\": \"90404\" }, \"hobbies\": [\"surfing\", \"coding\"] } 其使用的查询语言也非常方便，简单易懂。 > db.users.find({ \"address.zip\" : \"90404\" }) { \"_id\": \"5cf0029caff5056591b0ce7d\", \"firstname\": \"Jane\", \"lastname\": \"Wu\", \"address\":{}} { \"_id\": \"507f1f77bcf86cd799439011\", \"firstname\": \"Jon\", \"lastname\": \"Davis\", \"address\":{}} { \"_id\": \"5349b4ddd2781d08c09890f3\", \"firstname\": \"Jim\", \"lastname\": \"White\", \"address\":{}} { \"_id\": \"5bf142459b72e12b2b1b2cd\", \"firstname\": \"Jeff\", \"lastname\": \"Taylor\", \"address\":{}} { \"_id\": \"5cf003283b23d04a40d5f88a\", \"firstname\": \"Jerry\", \"lastname\": \"Miller\", \"address\":{}} { \"_id\": \"5bf142459b72e12b2b1b2cd\", \"firstname\": \"Jai\", \"lastname\": \"Williams\", \"address\":{}} { \"_id\": \"5cf0036deaa1742dd225ea35\", \"firstname\": \"Jess\", \"lastname\": \"Johnson\", \"address\":{}} { \"_id\": \"54495ad94c934721ede76d90\", \"firstname\": \"Jill\", \"lastname\": \"Brown\", \"address\":{}} { \"_id\": \"566eb3c704c7b31facbb0007\", \"firstname\": \"Janet\", \"lastname\": \"Jones\", \"address\":{}} { \"_id\": \"5a999cc461d36489a27f2563\", \"firstname\": \"Jan\", \"lastname\": 或者这样支持事务的复杂查询： session.start_transaction() order = { line_items : [ { item : 5, quantity: 6 } ] } db.orders.insertOne( order, session=session ); for x in order.line_items: db.inventory.update( { _id : x.item } , { $inc : { number : -1 * x.quantity } }, session=session ) session.commit_transaction() MongoDB的单个实例可以容纳多个独立的数据库，每一个数据库都有自己的集合和权限。 MongoDB自带简洁但功能强大的JavaScript Shell，这个工具对于管理MongoDB实例和操作数据作用非常大。 每一个文档都有一个特殊的键 “_id”，它在文档所处的集合中是唯一的，相当于关系数据库中的表的主键。 MongoDB支持的数据类型，如下表所示： 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 8.1.2 下载安装 MongoDB官方提供有Windows、Linux、macOS等操作系统的安装包下载。本小节使用Windows版本进行介绍。 到官方网站https://www.mongodb.com/download-center/community下载Windows x64最新4.2.1版本的MSI安装包。 双击下载的mongodb-win32-x86_64-2012plus-4.2.1-signed.msi安装文件，启动安装过程。 选择“完全”安装。 在“Install MongoDB Compass”安装步骤中，取消“Install MongoDB Compass”复选框，否则安装程序会到网上下载这个GUI管理工具，由于网络下载原因，会导致安装过程特别漫长。 剩余安装步骤，全部选择默认即可。 安装完毕后，检查Windows服务，确认MongoDB服务已经启动。 如果读者想使用官方GUI管理工具（MongoDB Compass），可以自行到https://www.mongodb.com/download-center/compass这里使用下载工具（如迅雷）快速下载，并自己安装。 8.1.3 安装管理工具 连接MongoDB有多种方式，除了可以使用MongoDB自带的最原始的命令窗口工具外，还可以使用功能强大的“NoSQL Manager for MongoDB”客户端GUI管理工具来连接MongoDB。 到mongodbmanager官网https://www.mongodbmanager.com/download下载Free版本的管理工具，按照正常步骤安装即可。 安装完毕后，打开管理工具，连接到本地MongoDB服务器。 通过GUI管理工具，可以方便地看到MongoDB安装完毕后，默认创建了admin、config和local等3个数据库。 在Database上右键，创建数据库test，并在test数据库中创建test_collection。 在test_collection中创建一个文档（document），内容为官方网站首页给出的示例数据。 保存后，在界面中可查看到数据已正确保存。 如果读者安装了MongoDB Compass，可以打开MongoDB Compass查看保存在MongoDB服务器中的数据。 个人感觉，其界面不如NoSQL Manager for MongoDB看起来方便。当然，读者可以选用自己顺手的GUI管理工具，或者直接使用命令行工具来管理，最终效果都是一样的。 8.1.4 常用命令 在资源管理器（C:\\Program Files\\MongoDB\\Server\\4.2\\bin）下找到mongo.exe，双击，打开MongoDB的命令行管理终端。 接下来，我们介绍一些MongoDB的命令，熟悉一下MongoDB的操作，更详细的MongoDB的操作，请参考官方文档。 显示所有的数据库： > show dbs; admin 0.000GB config 0.000GB local 0.000GB test 0.000GB 切换到前面创建的test数据库： > use test; switched to db test 创建一个名为user的集合： > db.createCollection(\"user\"); { \"ok\" : 1 } 显示数据库中所有的集合： > show collections; empty_collection test_collection user 在user集合中插入2个文档： > db.user.insert({\"id\":1,\"name\":\"Kevin\",\"age\":\"18\"}); WriteResult({ \"nInserted\" : 1 }) > db.user.insert({\"id\":2,\"name\":\"Roy\",\"age\":\"8\"}); WriteResult({ \"nInserted\" : 1 }) 查询user集合中的所有文档： > db.user.find(); { \"_id\" : ObjectId(\"5de3d41cb422c3774fecc6e8\"), \"id\" : 1, \"name\" : \"Kevin\", \"age\" : \"18\" } { \"_id\" : ObjectId(\"5de3d4cfb422c3774fecc6e9\"), \"id\" : 2, \"name\" : \"Roy\", \"age\" : \"8\" } 查询user集合中name=Kevin的文档： > db.user.find({\"name\":\"Kevin\"}); { \"_id\" : ObjectId(\"5de3d41cb422c3774fecc6e8\"), \"id\" : 1, \"name\" : \"Kevin\", \"age\" : \"18\" } 更新user集合中id=1的文档的name为Kevin Zhang，并添加属性smart，值为The Best，并查询所有记录检查更新结果： > db.user.update({\"id\":1}, {\"id\":1,\"name\":\"Kevin Zhang\",\"age\":\"18\",\"smart\":\"The Best\"}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.user.find(); { \"_id\" : ObjectId(\"5de3d41cb422c3774fecc6e8\"), \"id\" : 1, \"name\" : \"Kevin Zhang\", \"age\" : \"18\", \"smart\" : \"The Best\" } { \"_id\" : ObjectId(\"5de3d4cfb422c3774fecc6e9\"), \"id\" : 2, \"name\" : \"Roy\", \"age\" : \"8\" } 再添加一个文档（查询结果为3个文档），供后续删除练习用： > db.user.insert({\"id\":3,\"name\":\"Good Man\",\"age\":\"16\"}); WriteResult({ \"nInserted\" : 1 }) > db.user.find(); { \"_id\" : ObjectId(\"5de3d41cb422c3774fecc6e8\"), \"id\" : 1, \"name\" : \"Kevin Zhang\", \"age\" : \"18\", \"smart\" : \"The Best\" } { \"_id\" : ObjectId(\"5de3d4cfb422c3774fecc6e9\"), \"id\" : 2, \"name\" : \"Roy\", \"age\" : \"8\" } { \"_id\" : ObjectId(\"5de3d790b422c3774fecc6ea\"), \"id\" : 3, \"name\" : \"Good Man\", \"age\" : \"16\" } 删除id=3的文档，并查询检查，确认查询结果为2个文档： > db.user.remove({\"id\":3}); WriteResult({ \"nRemoved\" : 1 }) > db.user.find(); { \"_id\" : ObjectId(\"5de3d41cb422c3774fecc6e8\"), \"id\" : 1, \"name\" : \"Kevin Zhang\", \"age\" : \"18\", \"smart\" : \"The Best\" } { \"_id\" : ObjectId(\"5de3d4cfb422c3774fecc6e9\"), \"id\" : 2, \"name\" : \"Roy\", \"age\" : \"8\" } 通过GUI管理工具，查看数据库中集合文档的变化情况，可以清晰得看到test数据库中新增了1个user集合，这个集合中有2个文档，并且这两个文档的字段数不相同（有别于关系型数据库如MySQL，同一张表中字段必须相同）。 "},"第8章 Spring Boot集成MongoDB/8.2mongoDBIntegration.html":{"url":"第8章 Spring Boot集成MongoDB/8.2mongoDBIntegration.html","title":"8.2 集成MongoDB","keywords":"","body":"8.2 集成MongoDB Spring Boot对常见的数据源都通过“Spring Data”项目提供了支持，当然，MongoDB就是通过“Spring Data MongoDB”来支持的。所有的Spring Data子项目的使用方式都基本一致：使用模板（提供xxxTemplate类，如MongoTemplate、RedisTemplate）和类似于JPA的Repository类（如MongoRepository接口的SimpleMongoRepository实现类）。 8.2.1 创建项目 在STS中新建项目，选中Spring Web和Spring Data MongoDB依赖。 创建的项目中，依赖的启动器（starter）如下： org.springframework.boot spring-boot-starter-data-mongodb org.springframework.boot spring-boot-starter-web 在application.yml配置文件中配置MongoDB的连接信息，连接到本地MongoDB服务器。 spring: application: name: spirng-boot-mongodb data: mongodb: host: localhost port: 27017 database: test 后续，我们将使用在上一小节中创建的Test数据库中的User集合（Collection）来完成代码示例。 8.2.2 使用MongoTemplate 在entity包下创建User实体类，对应User集合中的文档。 public class User { private String id; private String name; private int age; ... 我们在示例中提供3个字段：id，name和age。 在service包下创建服务类UserService，其中提供针对User的增删改查功能。 package com.example.mongodb.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.data.mongodb.core.query.Criteria; import org.springframework.data.mongodb.core.query.Query; import org.springframework.data.mongodb.core.query.Update; import org.springframework.stereotype.Service; import com.example.mongodb.entity.User; @Service public class UserService { @Autowired private MongoTemplate mongoTemplate; public String save(String id, String name, int age) { User user = new User(); user.setId(id); user.setName(name); user.setAge(age); mongoTemplate.save(user); return \"success\"; } public List findAll() { return mongoTemplate.findAll(User.class); } public User get(String id) { Query query = new Query(Criteria.where(\"_id\").is(id)); return mongoTemplate.findOne(query, User.class); } public String update(String id, String name, int age) { User user = new User(); user.setId(id); user.setName(name); user.setAge(age); Query query = new Query(Criteria.where(\"_id\").is(id)); Update update = new Update().set(\"name\", name).set(\"age\", age); mongoTemplate.updateFirst(query, update, User.class); return \"success\"; } public String delete(String id, String name, int age) { User user = new User(); user.setId(id); user.setName(name); user.setAge(age); mongoTemplate.remove(user); return \"success\"; } } 上述代码中的17-18行注入MongoTemplate类，后续就使用这个模板类完成CRUD的操作。 控制器类，UserController提供了一些url与浏览器交互。 为了方便测试，我们这里不使用post提交表单的方式，而通过get方式附加url参数的形式和后台交互。 package com.example.mongodb.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.mongodb.entity.User; import com.example.mongodb.service.UserService; @RestController @RequestMapping(\"/mongodb/user/\") public class UserController { @Autowired UserService userService; @RequestMapping(\"/save\") public String save(String id, String name, int age) { return userService.save(id, name, age); } @RequestMapping(\"/findAll\") public List findAll() { return userService.findAll(); } @RequestMapping(\"/get\") public User get(String id) { return userService.get(id); } @RequestMapping(\"/update\") public String update(String id, String name, int age) { return userService.update(id, name, age); } @RequestMapping(\"/delete\") public String delete(String id, String name, int age) { return userService.delete(id, name, age); } } 运行这个Spring Boot应用，通过浏览器测试验证针对MongoDB的增删改查功能。 新增：http://localhost:8080/mongodb/user/save?id=1&name=Kevin&age=18，结果如下： 查找单一记录：http://localhost:8080/mongodb/user/get?id=1，结果如下： 再通过http://localhost:8080/mongodb/user/save?id=2&name=Roy&age=8，增加另外一条记录。 查找所有的记录：http://localhost:8080/mongodb/user/findAll，结果如下： 修改id=1的记录：http://localhost:8080/mongodb/user/update?id=1&name=Kevin%20Zhang&age=18，结果如下（注意查看第1条记录的name字段的值）： 删除记录：http://localhost:8080/mongodb/user/delete?id=1&name=Kevin%20Zhang&age=18，结果如下（id=1的那条记录已经被删除了）： 8.2.3 使用MongoRepository Spring Data提供了针对MongoDB的，与JPA规范保持一致的操作接口。 Supported keywords inside method names Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstname,findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age LessThanEqual findByAgeLessThanEqual … where x.age GreaterThan findByAgeGreaterThan … where x.age > ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age >= ?1 After findByStartDateAfter … where x.startDate > ?1 Before findByStartDateBefore … where x.startDate IsNull, Null findByAge(Is)Null … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname <> ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 在dao包下创建UserDAO接口，并给出符合上述命令规范的方法，如findByNameLike方法。 package com.example.mongodb.dao; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.mongodb.repository.MongoRepository; import com.example.mongodb.entity.User; public interface UserDAO extends MongoRepository { public Page findByNameLike(String name, Pageable pageable); } 创建控制器RepositoryController，注入UserDAO，添加控制器方法。 package com.example.mongodb.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.mongodb.dao.UserDAO; import com.example.mongodb.entity.User; @RestController @RequestMapping(\"/mongodb/repository/\") public class RepositoryController { @Autowired UserDAO userDAO; @RequestMapping(\"/createUser\") public User createUser(User user) { return userDAO.save(user); } @RequestMapping(\"/findByNameLike\") public Page findByNameLike(String name) { PageRequest pageable = PageRequest.of(0, 10); return userDAO.findByNameLike(name, pageable); } } 其中的createUser方法使用了org.springframework.data.repository.CrudRepository接口中的save方法。 其中findByNameLike方法使用的是我们遵循Spring Data JPA方法名规范在UserDAO类中提供的findByNameLike(name, pageable)方法。 运行程序，使用Postman测试，createUser服务接口： 检查MongoDB中的数据，确认其已经正确创建id为999的记录。 通过浏览器访问http://localhost:8080/mongodb/repository/findByNameLike?name=Good Man，检查是否正确返回查询到的数据。 通过Postman发起get请求，请求地址为http://localhost:8080/mongodb/repository/findByNameLike?name=Good Man，检查其返回的数据为id=999的记录。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-mongodb "},"第8章 Spring Boot集成MongoDB/8.3homework.html":{"url":"第8章 Spring Boot集成MongoDB/8.3homework.html","title":"8.3 课后作业","keywords":"","body":"8.3 课后作业 安装配置MongoDB 4.2.1及其管理工具，练习常用的MongoDB命令。 在Spring Boot项目中以MongoTemplate方式做CRUD练习。 在Spring Boot项目中以MongoRepository方式做CRUD练习。 扩展阅读：MongoDB中的事务（参考这里）。 "},"第9章 Spring Boot与异步消息/MQ.html":{"url":"第9章 Spring Boot与异步消息/MQ.html","title":"第9章 Spring Boot与异步消息","keywords":"","body":"第9章 Spring Boot与异步消息 在实际工作中，消息队列作为高并发系统的核心组件之一，能够帮助业务系统解耦、提升开发效率和增强系统稳定性。主要具有以下优势： 削峰填谷（主要解决瞬时写压力大于应用服务吞吐能力导致的消息丢失、系统奔溃等问题）； 系统解耦（解决不同重要程度、不同服务级别系统之间的依赖，避免出现系统“一死全死”的局面）； 提升性能（当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统）； 蓄流压测（线上有些链路不好做压力测试，可以通过堆积一定量消息后再放开来进行压力测试）。 目前主流的MQ有ActiveMQ、RabbitMQ、RocketMQ和Kafka。 特性 ActiveMQ RabbitMQ RocketMQ kafka 开发语言 java erlang java scala 单机吞吐量 万级 万级 10万级 10万级 时效性 ms级 us级 ms级 ms级以内 可用性 高(主从架构) 高(主从架构) 非常高(分布式架构) 非常高(分布式架构) 功能特性 成熟的产品，在很多公司得到应用，有较多的文档，各种协议支持较好 基于erlang开发，所以并发能力很强，性能极好，延时很低，管理界面较丰富 由阿里巴巴设计，历经多次天猫双十一海量消息考验。现在是Apache顶级项目。MQ功能比较完备，扩展性佳 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广 本章我们先介绍异步消息的相关概念，然后再依次介绍如何在Spring Boot中集成使用ActiveMQ、RocketMQ、RabbitMQ和Kafka这四种主流的消息中间件。 "},"第9章 Spring Boot与异步消息/9.1jms.html":{"url":"第9章 Spring Boot与异步消息/9.1jms.html","title":"9.1 有关消息的概念","keywords":"","body":"9.1 有关消息的概念 本小节介绍一些有关消息的概念，为理解学习后续集成常用消息中间件的知识打下基础。 9.1.1 基本概念 JMS（Java消息服务，JSR 343: Java Message Service 2.0）是Java平台上有关“面向消息中间件（MOM）”的技术规范，它便于处于消息系统中的Java应用程序之间进行消息交换，并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。 MQ全称为Message Queue（消息队列）是一种应用程序对应用程序的通信方法，是面向消息中间件（MOM）的最终实现，是真正的服务提供者。MQ的实现可以基于JMS，也可以基于其他规范或标准。 消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远过程调用（RPC）的技术。 应用程序通过写入和消息列队中的数据（消息）来通信，从而避免了应用程序之间的相互连接（高耦合）。 “生产者-消费者”模型是MQ的一个典型的代表：一端往消息队列中不断的写入消息，而另一端则可以读取或者订阅队列中的消息。常见的MQ消息中间件是遵循JMS和（或）AMQP协议规范的具体实现产品。 AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。 我们经常会在项目中，将一些无需即时返回且耗时的操作提取出来，进行异步处理。而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。 JMS中的一些术语： Provider(MessageProvider)：生产者，指消息的生产者，发送消息的程序。 Consumer(MessageConsumer)：消费者，指消息的消费者，接收消息的程序。 P2P：Point to Point，即点对点的消息模型。 Pub/Sub：publish/Subscribe，即发布/订阅的消息模型。 Queue：队列，在消息的传输过程中保存消息的容器。 Topic：主题。消息的发布者将消息发布到一个内容节点，消息的订阅者在这个内容节点订阅（接收）消息，这个内容节点就是主题。主题使得消息的发布者和订阅者保持相互独立。 ConnectionFactory：连接工厂，JMS用来创建连接的工厂（一种常见的设计模式：工厂模式）。 Connection：JMS客户端到JMS Provider的连接。 Destination：消息的目的地。 Session：会话，一个发送或者接受消息的线程。 JMS规范的两种消息传输方式Topic（一对多）和Queue（一对一），比较如下： 比较项 Topic Queue 概要 Publish Subscribe messaging 发布订阅消息 Point-to-Point 点对点 有无状态 数据默认不落地，是无状态的 数据默认会在mq服务器上以文件形式保存，比如Active MQ一般保存在$AMQ_HOME\\data\\kr-store\\data下面。也可以配置成DB存储 完整性保障 并不保证publisher发布的每条数据，Subscriber都能接受到 保证每条数据都能被receiver接收 消息是否会丢失 一般来说publisher发布消息到某一个topic时，只有正在监听该topic地址的sub能够接收到消息；如果没有sub在监听，该topic就丢失了 Sender发送消息到目标Queue，receiver可以异步接收这个Queue上的消息。Queue上的消息如果暂时没有receiver来取，也不会丢失 发布接收策略 一对多的消息发布接收策略，监听同一个topic地址的多个sub都能收到publisher发送的消息。Sub接收完通知mq服务器 一对一的消息发布接收策略，一个sender发送的消息，只能有一个receiver接收。receiver接收完后，通知mq服务器已接收，mq服务器对queue里的消息采取删除或其他操作 9.1.2 高可用 当前所有的主流消息中间件，都支持高可用。 在生产环境下可以通过集群方式来保证消息中间件的高可用（HA）性。 消息中间件集群包括两种，普通模式和镜像模式： 普通模式是每个节点存相同的元数据，只有一个存真正的数据实体，当消费者从某个没有数据实体的节点读数据时，需要临时在节点间传输数据。这种集群做不到高可用。 镜像模式：消息队列为镜像队列，实现了消息队列的高可用，但是占用大量网络带宽同步镜像队列中的数据。 9.1.3 幂等 在可靠消息支持的分布式事务场景下，我们需要消息的消费满足“有且仅有一次”的条件。 幂等（idempotent, idempotence）在数学上有明确的定义： 设f为一由X映射至X的一元运算，则f为幂等的，当对于所有在X内的x，f(f(x)) = f(x)。 特别的是，恒等函数一定是幂等的，且任一常数函数也都是幂等的。 基于幂等的数学定义，结合消息消费的场景，我们能够很容易的总结出消息幂等的概念： 如果消息重试多次，消费者端对该重复消息消费多次与消费一次的结果是相同的，并且多次消费没有对系统产生副作用，那么我们就称这个过程是消息幂等的。 支付场景下，消费者消费扣款消息，对一笔订单进行扣款操作。 这个扣款操作重复多次与执行一次的效果相同，只进行一次真实扣款，用户的扣款记录中对应该笔订单的只有一条扣款流水。不会多扣。那么我们就说这个扣款操作是符合要求的，这个消费过程是消息幂等的。 "},"第9章 Spring Boot与异步消息/9.2activeMQ.html":{"url":"第9章 Spring Boot与异步消息/9.2activeMQ.html","title":"9.2 Spring Boot集成ActiveMQ","keywords":"","body":"9.2 Spring Boot集成ActiveMQ ActiveMQ是一种基于JMS 1.1规范的开源的消息中间件，ActiveMQ的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成消息通信中间件。 ActiveMQ非常成熟，功能强大，在早些年业内大量的公司以及项目中都有应用，偶尔会有较低概率丢失消息，现在社区活跃度在降低，国内应用越来越少。官方现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本。 9.2.1安装配置 到官网下载最新的 apache-activemq-5.15.10-bin.zip编译好的zip压缩包。 将其解压到磁盘，例如C:\\Java\\apache-activemq-5.15.10这个目录。 打开命令终端，进入ActiveMQ安装目录下的bin目录，执行activemq.bat start启动ActiveMQ服务器。 访问http://localhost:8161/index.html控制台，点击Manage ActiveMQ broker用户名和密码都是admin，进入管理界面，检查ActiveMQ是否正确安装。 因为ActiveMQ应用得越来越少，我们就不做集群安装配置演示了。 9.2.2 Spring Boot集成ActiveMQ Spring Boot为ActiveMQ提供了启动器（starter），集成ActiveMQ很方便。 Spring为JMS提供了org.springframework.jms.core.JmsTemplate模板类，封装了常用的消息操作，使用起来非常方便。 新建一个Spring Boot项目，选择Spring Web和Spring for Apache ActiveMQ 5这两个starter依赖。 项目pom文件，最主要的就是： org.springframework.boot spring-boot-starter-activemq 9.2.2.1 点对点（Queue）模式 ActiveMQ的默认配置为点对点模式（spring.jms.pub-sub-domain=false）。 在配置文件application.yml中配置到ActiveMQ的连接信息： spring: activemq: broker-url: tcp://localhost:61616 user: admin password: admin 创建一个Controller，接收用户输入，向MQ发送消息： package com.example.activemq.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.core.JmsTemplate; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/activemq/\") public class ActiveMQController { @Autowired private JmsTemplate jmsTemplate; @RequestMapping(\"/send\") public String sendMsg(String msg) { jmsTemplate.convertAndSend(\"Q1\", msg); return msg + \" Sended to Q1.\"; } } 在Controller中注入private JmsTemplate jmsTemplate;，然后使用JmsTemplate的send方法向Q1队列发送消息。 创建一个服务类，监听消息队列Q1，并简单地将接收到地消息输出到控制台。 package com.example.activemq.service; import org.springframework.jms.annotation.JmsListener; import org.springframework.stereotype.Service; @Service public class MessageListener { @JmsListener(destination = \"Q1\") public void msgReceive(String msg) { System.out.println(\"Message: \" + msg + \" Received.\"); } } 注解@JmsListener(destination = \"Q1\")表示msgReceive方法监听Q1这个队列。 运行Spring Boot应用程序，访问http://localhost:8080/activemq/send?msg=Hello%20Kevin.，向消息队列中发送“Hello Kevin.”这样一条消息。 然后观察Spring Boot应用的控制台，可以看到由MessageListener.msgReceive方法从Q1接收到消息后在控制台输出的信息。 在ActiveMQ的管理控制台，也可以看到由程序创建的Q1队列，及消息消费者和消息相关的信息。 9.2.2.2 发布订阅（Topic）模式 在Spring Boot应用中通过spring.jms.pub-sub-domain=true配置，打开Spring对ActiveMQ发布订阅模式的支持。 新创建一个Spring Boot项目，选择Spring Web和Spring for Apache ActiveMQ 5这两个starter依赖。 在配置文件application.yml中配置到ActiveMQ的连接信息： spring: activemq: broker-url: tcp://localhost:61616 user: admin password: admin packages: trust-all: true jms: pub-sub-domain: true 在com.example.activemq.topic.producer包下面创建消息生产者类TopicProducer，将消息发送到“Topic-Weather”这个Topic上。 package com.example.activemq.topic.producer; import org.apache.activemq.command.ActiveMQTopic; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jms.core.JmsTemplate; import org.springframework.stereotype.Component; @Component public class TopicProducer { @Autowired private JmsTemplate jmsTemplate; public void sendMessage(String msg) { ActiveMQTopic destination = new ActiveMQTopic(\"Topic-Weather\"); jmsTemplate.convertAndSend(destination, msg); } } 在com.example.activemq.topic.consumer包下创建消息消费者TopicConsumer，通过两个消息监听方法模拟两个订阅“Topic-Weather”主题的消息消费者（subscriber1和subscriber2）。 package com.example.activemq.topic.consumer; import org.springframework.jms.annotation.JmsListener; import org.springframework.stereotype.Component; @Component public class TopicConsumer { /** * 消息消费者1，监听\"Topic-Weather\"上的消息 * @param msg 消息 */ @JmsListener(destination = \"Topic-Weather\") public void subscriber1(String msg) { System.out.println(\"Consumer1 consume message: \" + msg); } /** * 消息消费者2，监听\"Topic-Weather\"上的消息 * @param msg 消息 */ @JmsListener(destination = \"Topic-Weather\") public void subscriber2(String msg) { System.out.println(\"Consumer2 consume message: \" + msg); } } 在com.example.activemq.topic.controller包下创建和用户交互发送消息的控制器，在其中调用消息生产者TopicProducer类来发送消息。 package com.example.activemq.topic.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.activemq.topic.producer.TopicProducer; @RestController @RequestMapping(\"/activemq/\") public class TopicController { @Autowired private TopicProducer topicProducer; @RequestMapping(\"/send\") public String sendMsg(String msg) { topicProducer.sendMessage(msg); return msg + \" Sended to Topic-Weather.\"; } } 运行Spring Boot应用程序，访问http://localhost:8080/activemq/send?msg=明天气温6-8度，向消息队列中发送“Hello Kevin.”这样一条消息。 然后观察Spring Boot应用的控制台，可以看到由TopicConsumer.subscriber1方法和TopicConsumer.subscriber1方法订阅Topic-Weather这个主题后接收到消息，在控制台输出的信息。 在ActiveMQ的管理控制台，也可以看到Topic-Weather及其消费者数量等信息。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-activemq https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-activemq-topic "},"第9章 Spring Boot与异步消息/9.3rabbitMQ.html":{"url":"第9章 Spring Boot与异步消息/9.3rabbitMQ.html","title":"9.3 Spring Boot集成RabbitMQ","keywords":"","body":"9.3 Spring Boot集成RabbitMQ RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息中间件，基于erlang开发，并发能力很强，性能极好，延时很低，是当前大量部署使用的消息中间件。 RabbitMQ发送消息时，是先把消息发送给Exchange（交换器），然后再分发给有相应RoutingKey（路由键）关系的Queue（队列）。 在RabbitMQ中消息交换器有四种： Direct模式：消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配。 Topic模式：主题交换器通过模式匹配消息的路由键属性，然后将消息分配到绑定到该模式的队列。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。该交换器会识别两个通配符：“#”和“*”。#匹配0个或多个单词，*匹配一个单词。 Fanout模式：每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上（就像广播一样）。fanout 类型转发消息是最快的。 Header模式： 和主题交换器有点相似，头交换器的路由值基于消息的header数据。主题交换器路由键只有是字符串，而头交换器可以是整型和哈希值。 Headers交换器允许你匹配AMQP消息的header而非路由键，除此之外headers交换器和direct交换器完全一致，但性能却很差，几乎用不到。 9.3.1 安装配置 到RabbitMQ官网下载最新版rabbitmq-server-3.8.2.exe。 安装运行RabbitMQ需要64位的Erlang，针对3.8.2版本的RabbitMQ官方推荐Erlang 22.1版本。 到Erlang官网下载otp_win64_22.1.exe。 9.3.1.1 安装Erlang 使用默认配置安装Erlang。 9.3.1.2 安装RabbitMQ 使用默认配置安装RabbitMQ。 RabbitMQ提供了Web管理界面。 打开命令提示符窗口，进入C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-3.8.2\\sbin目录，执行rabbitmq-plugins.bat enable rabbitmq_management 开启Web管理插件。 Microsoft Windows [版本 10.0.18362.476] (c) 2019 Microsoft Corporation。保留所有权利。 C:\\Users\\Kevin>cd C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-3.8.2\\sbin C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-3.8.2\\sbin>rabbitmq-plugins.bat enable rabbitmq_management Enabling plugins on node rabbit@NOTEBOOK-KEVIN: rabbitmq_management The following plugins have been configured: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatch Applying plugin configuration to rabbit@NOTEBOOK-KEVIN... The following plugins have been enabled: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatch started 3 plugins. C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-3.8.2\\sbin> 打开浏览器访问http://localhost:15672/，使用guest用户，密码guest登录管理控制台。 9.3.2 与Spring Boot集成 新建Spring Boot项目，选择Spring for RabbitMQ+Spring Web启动器依赖。 pom文件的主要依赖为spring-boot-starter-amqp。 org.springframework.boot spring-boot-starter-amqp org.springframework.boot spring-boot-starter-web 在配置文件application.yml中添加RabbitMQ连接等配置信息。 spring: application: name: spring-boot-rabbitmq rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest # 开启发送确认 publisher-confirm-type: correlated # 开启发送失败退回 publisher-returns: true # 开启ACK listener: direct: acknowledge-mode: manual simple: acknowledge-mode: manual 9.3.2.1 一对一模式 一个生产者对一个消费者模式，生产者将消息投送到队列中，消费者从队列中消费消息，然后就结束了。 创建配置类RabbitMQConfig，在其中配置消息队列kevin。 package com.example.rabbitmq.config; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { @Bean public Queue kevinQueue() { return new Queue(\"kevin\"); } } 创建消息生产者RabbitMQProducer，使用注入的AmqpTemplate对象向消息队列kevin发送消息。 package com.example.rabbitmq.producer; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class RabbitMQProducer { @Autowired AmqpTemplate amqpTemplate; public void sendMessage(String msg) { amqpTemplate.convertAndSend(\"kevin\", msg); } } 创建消息消费者RabbitMQConsumer，监听kevin消息队列的消息，并在管理控制台上输出信息。 package com.example.rabbitmq.consumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = \"kevin\") public class RabbitMQConsumer { @RabbitHandler public void receive(String msg) { System.out.println(\"RabbitMQ Consumer consume message: \" + msg); } } 创建与用户交互的控制器类RabbitMQController，在/rabbitmq/send路径上接收用户输入。 package com.example.rabbitmq.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.rabbitmq.producer.RabbitMQProducer; @RestController @RequestMapping(\"/rabbitmq/\") public class RabbitMQController { @Autowired RabbitMQProducer rabbitMQProducer; @RequestMapping(\"/send\") public String sendMsg(String msg) { rabbitMQProducer.sendMessage(msg); return msg + \" Sended to kevin.\"; } } 运行Spring Boot应用，打开浏览器访问http://localhost:8080/rabbitmq/send?msg=Kevin is a GOODMAN.，向RabbitMQ发送消息。 RabbitMQ消费者（RabbitMQConsumer类）消费消息，并在控制台打印信息。 通过管理控制台，可以看到消息队列的相关情况。 9.3.2.2 一对多模式 一个生产者对多个消费者，该模式下可以是一个生产者将消息投递到一个队列，该队列对应多个消费者，此时每条消息只会被消费一次，多个消费者循环处理。另外也可以是一个生产者将消息投递到多个队列里，此时消息是被复制处理。 在配置类com.example.rabbitmq.config.RabbitMQConfig中添加一个新的消息队列roy。 @Bean public Queue royQueue() { return new Queue(\"roy\"); } 创建消息生产者RabbitMQProducerMore，使用注入的AmqpTemplate对象向消息队列roy发送消息。 package com.example.rabbitmq.producer; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class RabbitMQProducerMore { @Autowired AmqpTemplate amqpTemplate; public void sendMessage(String msg) { amqpTemplate.convertAndSend(\"roy\", msg); } } 创建消息消费者RabbitMQConsumer1，监听roy消息队列的消息，并在管理控制台上输出信息。 package com.example.rabbitmq.consumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = \"roy\") public class RabbitMQConsumer1 { @RabbitHandler public void receive(String msg) { System.out.println(\"RabbitMQ Consumer1 consume message: \" + msg); } } 创建消息消费者RabbitMQConsumer2，监听roy消息队列的消息，并在管理控制台上输出信息。 package com.example.rabbitmq.consumer; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = \"roy\") public class RabbitMQConsumer2 { @RabbitHandler public void receive(String msg) { System.out.println(\"RabbitMQ Consumer2 consume message: \" + msg); } } 在控制器类RabbitMQController中，添加/rabbitmq/sendMore路径上接收用户输入，并调用RabbitMQProducerMore（消息生产者类）中的sendMessage方法循环发送5条消息到roy消息队列上。 @Autowired RabbitMQProducerMore rabbitMQProducerMore; @RequestMapping(\"/sendMore\") public String sendMoreMsg(String msg) { for (int i = 0; i 运行Spring Boot应用，打开浏览器访问http://localhost:8080/rabbitmq/sendMore?msg=Roy is a GOODMAN.，向RabbitMQ发送消息。 RabbitMQ消费者（RabbitMQConsumer1类和RabbitMQConsumer2类）轮流消费消息，并在控制台打印信息。 通过管理控制台，可以看到消息队列的相关情况。 一个生产者将消息投递到多个队列里的场景，请读者自行完成练习。 9.3.2.3 ACK消息确认 消息确认ACK机制，是指消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除的一种保证消息能被正确消费的一种处理方法。 如果一个消费者在处理消息的过程中出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有被正常消费，会将消息重新放入队列中。 ACK：acknowledgement，确认。 在配置类com.example.rabbitmq.config.RabbitMQConfig中添加一个新的消息队列lily，并绑定到一个名为“fanoutExchange”的Fanout交换器上。 @Bean public Queue ackQueue() { return new Queue(\"lily\"); } @Bean public FanoutExchange fanoutExchange() { return new FanoutExchange(\"fanoutExchange\"); } @Bean Binding bindingAckQueue2Exchange(Queue ackQueue, FanoutExchange fanoutExchange) { return BindingBuilder.bind(ackQueue).to(fanoutExchange); } 创建消息生产者RabbitMQProducerAck，使用注入的RabbitTemplate对象向消息队列lily发送消息，并编写对应的回调实现。 package com.example.rabbitmq.producer; import java.time.LocalDateTime; import java.time.ZoneId; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class RabbitMQProducerAck implements RabbitTemplate.ReturnCallback { @Autowired private RabbitTemplate rabbitTemplate; @Override public void returnedMessage(Message message, int i, String s, String s1, String s2) { System.out.println(\"RabbitMQProducerAck Returned Message: \" + message.toString() + \" , \" + i + \" , \" + s1 + \" , \" + s2); } public void sendMessage(String msg) { rabbitTemplate.setReturnCallback(this); rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> { if (ack) { System.out.println(\"Send Message Success.\"); } else { System.out.println(\"Send Message Failure:\" + cause + correlationData.toString()); } }); rabbitTemplate.convertAndSend(\"lily\", msg + \", \" + LocalDateTime.now(ZoneId.systemDefault())); } } 创建消息消费者RabbitMQConsumerAck，监听lily消息队列的消息，消费消息并确认（channel.basicAck），然后在管理控制台上输出信息。 package com.example.rabbitmq.consumer; import java.time.LocalDateTime; import java.time.ZoneId; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import com.rabbitmq.client.Channel; @Component @RabbitListener(queues = {\"lily\"}) public class RabbitMQConsumerAck { @RabbitHandler public void process(String sendMsg, Channel channel, Message message) { System.out.println(\"RabbitMQ ConsumerAck consume message: \" + sendMsg + \" @\" + LocalDateTime.now(ZoneId.systemDefault())); try { channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); System.out.println(\"Process Success\"); } catch (Exception e) { System.out.println(\"Process Failure.\"); e.printStackTrace(); } } } 在控制器类RabbitMQController中，添加/rabbitmq/sendAck路径，接收用户输入。 @Autowired RabbitMQProducerAck rabbitMQProducerAck; @RequestMapping(\"/sendAck\") public String sendAckMsg(String msg) { rabbitMQProducerAck.sendMessage(msg); return msg + \" Sended to lily.\"; } 运行Spring Boot应用，打开浏览器访问http://localhost:8080/rabbitmq/sendAck?msg=Lily is a GOODMAN.，向RabbitMQ发送消息。 RabbitMQ消费者RabbitMQConsumerAck消费消息，然后告诉服务器收到的这条消息已经被当前消费者（RabbitMQConsumerAck）消费了，消息服务器就可以删除这条消息了。 RabbitMQ生产者RabbitMQProducerAck收到确认回调信息后，在控制台输出Send Message Success.的信息。 请仔细查看在控制台打印的信息并结合上述代码理解消息生产、消费、确认的过程。 RabbitMQ ConsumerAck consume message: Lily is a GOODMAN., 2019-12-13T00:07:51.750 @2019-12-13T00:07:51.782：根据代码，前面的时间为消息的生产时间，后面的时间为消息的消费时间。 通过管理控制台，可以看到消息队列的相关情况。 kevin队列有1条消息没有确认，roy队列有5条消息没有确认，所以这次Spring Boot应用启动的时候还能看到RabbitMQ Consumer1 consume message: Roy is a GOODMAN.No.3之类的信息就是因为没有确认消息已被消费（服务器没有收到确认就不会删除消息，下次连接到队列，就会继续发送消息给消费者）。 lily队列Unacked消息数量为0，是因为消息已经确认消费了。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-rabbitmq "},"第9章 Spring Boot与异步消息/9.4rocketMQ.html":{"url":"第9章 Spring Boot与异步消息/9.4rocketMQ.html","title":"9.4 Spring Boot集成RocketMQ","keywords":"","body":"9.4 Spring Boot集成RocketMQ RocketMQ是由阿里巴巴开源到Apache的一个Java语言的分布式消息中间件，支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。它里面有几个区别于标准消息中件间的概念，如Group、Topic、Queue等。系统组成则有Producer、Consumer、Broker、NameServer等。 RocketMQ的主要特点： 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型。 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递 （RocketMQ可以保证严格的消息顺序，而ActiveMQ无法保证）。 支持拉（pull）和推（push）两种消息模式 （Push好理解，比如在消费者端设置Listener回调；而Pull，控制权在于应用，即应用需要主动的调用拉消息方法从Broker获取消息，这里面存在一个消费位置记录的问题（如果不记录，会导致消息重复消费））。 单一队列百万消息的堆积能力（RocketMQ提供亿级消息的堆积能力，这不是重点，重点是堆积了亿级的消息后，依然保持写入低延迟）。 支持多种消息协议，如 JMS、MQTT 等。 分布式高可用的部署架构，满足至少一次消息传递语义（RocketMQ原生就是支持分布式的，而ActiveMQ原生存在单点性）。 提供 docker 镜像用于隔离测试和云集群部署。 提供配置、指标和监控等功能丰富的 Dashboard。 RocketMQ以Topic来管理不同应用的消息，对于生产者（producer）而言，发送消息时需要指定消息的Topic，对于消费者（consumer）而言，在启动后需要订阅相应的Topic，然后可以消费相应的消息。Topic是逻辑上的概念，在物理实现上，一个Topic由多个Queue组成，采用多个Queue的好处是可以将Broker存储分布式化，提高系统性能。 本小节介绍如何安装配置高可用的RocketMQ集群，在Spring Boot中集成使用。 9.4.1 单机安装配置 到官网下载最新版本rocketmq-all-4.6.0-bin-release.zip，然后解压到磁盘，例如C:\\Java\\rocketmq-all-4.6.0-bin-release。 在Windows的环境变量中配置ROCKETMQ_HOME到RocketMQ的解压目录，例如C:\\Java\\rocketmq-all-4.6.0-bin-release。 为RocketMQ设置Windows环境变量ROCKETMQ_HOME，指向安装目录C:\\Java\\rocketmq-all-4.6.0-bin-release。 执行bin目录下的mqnamesrv.cmd，启动name server。 C:\\Java\\rocketmq-all-4.6.0-bin-release\\bin>mqnamesrv.cmd 执行bin目录下的mqbroker.cmd，启动BROKER。 C:\\Java\\rocketmq-all-4.6.0-bin-release\\bin>mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true 为了方便后续对RocketMQ的监控，可以选择安装RocketMQ社区提供的管理控制台。 rocketmq-externals项目由社区维护了很多RocketMQ相关的扩展/集成支持，其中的rocketmq-console子项目是一个可视化的管理控制台。 执行git clone命令，将项目版本库克隆到本地。 git clone https://github.com/apache/rocketmq-externals.git 进入rocketmq-console子项目的目录，maven编译。 mvn clean package -Dmaven.test.skip=true 进入target目录执行java -jar命令（在命令行中指定服务器端口和RocketMQ的name server地址），启动RocketMQ管理控制台。 java -jar rocketmq-console-ng-1.0.1.jar --server.port=80 --rocketmq.config.namesrvAddr=127.0.0.1:9876 打开浏览器，输入http://localhost/就可以访问到RocketMQ的控制台。 9.4.2 高可用集群 RocketMQ天生对集群的支持非常友好，在其安装包的conf目录下就带了“2主-2从同步”和“2主-2从异步”的配置参考文件。 RocketMQ的服务模式有如下几种： 单Master 优点：除了配置简单没什么优点。 缺点：不可靠，该机器重启或宕机，将导致整个服务不可用。 多Master 优点：配置简单，性能最高。 缺点：可能会有少量消息丢失（配置相关），单台机器重启或宕机期间，该机器上面未被消费的消息在机器恢复前不可订阅，影响消息实时性。 多Master多Slave异步模式：每个Master配一个Slave，有多对Master-Slave，集群采用异步复制方式，主备有短暂（毫秒级）消息延迟 优点：性能同多Master几乎一样，实时性高，主备间切换对应用透明，不需人工干预。 缺点：Master宕机或磁盘损坏时会有少量消息丢失。 多Master多Slave同步模式：每个Master配一个Slave，有多对Master-Slave，集群采用同步双写方式，主备都写成功，向应用返回成功 优点：服务可用性与数据可用性非常高。 缺点：性能比异步集群略低，当前版本主宕备不能自动切换为主。 下面我们以“2namesrv-2master-2slave异步刷盘消息队列集群”为例来讲解RocketMQ的集群配置，以官方发布包rocketmq-all-4.6.0-bin-release\\conf\\2m-2s-async下的参考配置文件为基础，并根据自生集群情况进行了修改。 9.4.2.1 配置 六台服务器都部署在本地机器上，名称、端口信息规划如下： 服务器名称 IP地址 端口 用途 nameserver-a 127.0.0.1 9876 Name Server nameserver-b 127.0.0.1 9877 Name Server broker-a 127.0.0.1 10850 Broker Server（主） broker-a-s 127.0.0.1 10880 Broker Server（从） broker-b 127.0.0.1 10950 Broker Server（主） broker-b-s 127.0.0.1 10980 Broker Server（从） 为两个broker主从服务器创建数据存储目录\\rocketmq-all-4.6.0-bin-release\\data\\broker-a和\\rocketmq-all-4.6.0-bin-release\\data\\broker-b，并分别在其下创建如下目录： store：存放broker master的数据； store\\slave：存放broker slave的数据； store\\commitlog：存放提交日志数据； brokerIP1 当前broker监听的IP； brokerIP2 存在broker主从时，在broker主节点上配置了brokerIP2的情况下，broker从节点会连接主节点配置的brokerIP2来同步。 因为是在一台机器上运行六个服务器实例（学习测试用），所以，将服务器启动脚本中jvm对内存的要求调小： 修改RocketMQ bin目录下的runserver.cmd，将内存修改为：-server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m； 修改RocketMQ bin目录下的runbroker.cmd，将内存修改为：-server -Xms256m -Xmx256m -Xmn128m； 配置Name Server A，nameserver-a.properties： listenPort=9876 配置Name Server B，nameserver-b.properties： listenPort=9877 配置broker-a master，broker-a.properties： brokerClusterName=DefaultCluster brokerName=broker-a brokerId=0 deleteWhen=04 fileReservedTime=48 brokerRole=ASYNC_MASTER flushDiskType=ASYNC_FLUSH namesrvAddr=127.0.0.1:9876;127.0.0.1:9877 listenPort=10850 brokerIP1=127.0.0.1 brokerIP2=127.0.0.1 storePathRootDir=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-a/store storePathCommitLog=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-a/store/commitlog 配置broker-a slave，broker-a-s.properties： brokerClusterName=DefaultCluster brokerName=broker-a brokerId=1 deleteWhen=04 fileReservedTime=48 brokerRole=SLAVE flushDiskType=ASYNC_FLUSH namesrvAddr=127.0.0.1:9876;127.0.0.1:9877 listenPort=10880 brokerIP1=127.0.0.1 storePathRootDir=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-a/store/slave storePathCommitLog=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-a/store/commitlog 配置broker-b master，broker-b.properties： brokerClusterName=DefaultCluster brokerName=broker-b brokerId=0 deleteWhen=04 fileReservedTime=48 brokerRole=ASYNC_MASTER flushDiskType=ASYNC_FLUSH namesrvAddr=127.0.0.1:9876;127.0.0.1:9877 listenPort=10950 brokerIP1=127.0.0.1 brokerIP2=127.0.0.1 storePathRootDir=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-b/store storePathCommitLog=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-b/store/commitlog 配置broker-b slave，broker-b-s.properties： brokerClusterName=DefaultCluster brokerName=broker-b brokerId=1 deleteWhen=04 fileReservedTime=48 brokerRole=SLAVE flushDiskType=ASYNC_FLUSH namesrvAddr=127.0.0.1:9876;127.0.0.1:9877 listenPort=10980 brokerIP1=127.0.0.1 storePathRootDir=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-b/store/slave storePathCommitLog=C:/Java/rocketmq-all-4.6.0-bin-release/data/broker-b/store/commitlog 9.4.2.2 启动 配置完集群后，依次启动name server（两台），broker-a（主从）和broker-b（主从）等六台服务器。 启动两台name server： mqnamesrv.cmd -c ../conf/2m-2s-async/nameserver-a.properties mqnamesrv.cmd -c ../conf/2m-2s-async/nameserver-b.properties 启动broker-a主从服务器： mqbroker.cmd -c ../conf/2m-2s-async/broker-a.properties mqbroker.cmd -c ../conf/2m-2s-async/broker-a-s.properties 启动broker-b主从服务器： mqbroker.cmd -c ../conf/2m-2s-async/broker-b.properties mqbroker.cmd -c ../conf/2m-2s-async/broker-b-s.properties 9.4.2.3 检查 连接到任一Name Server查看集群信息： mqadmin.cmd clusterList -n 127.0.0.1:9876 启动管理控制台： java -jar rocketmq-console-ng-1.0.1.jar --server.port=80 --rocketmq.config.namesrvAddr=127.0.0.1:9876;127.0.0.1:9877 通过控制台可以看到集群信息。 9.4.3 与Spring Boot集成 为了方便在Spring Boot中集成RocketMQ，官方提供了Spring Boot的starter。 9.4.3.1 单机环境 新建Spring Boot项目，添加Spring Web启动器依赖。 Spring Boot官方没有提供RocketMQ的starter，由RocketMQ官方提供starter，从rocketmq-spring-boot-starter命名上可以看出来，和MyBatis的命令类似。 然后，在pom文件中手工添加RocketMQ的启动器依赖。 org.apache.rocketmq rocketmq-spring-boot-starter 2.0.4 在application.yml文件中，添加到RocketMQ的连接信息。 rocketmq: name-server: 127.0.0.1:9876 producer: send-message-timeout: 300000 group: my-group 创建消息提供者RocketProducer，注入RocketMQTemplate类。 package com.example.rocketmq.producer; import org.apache.rocketmq.spring.core.RocketMQTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class RocketProducer { @Autowired private RocketMQTemplate rocketMQTemplate; public void sendMessage(String msg) { rocketMQTemplate.convertAndSend(\"test-topic\",msg); } } 创建消息消费者RocketConsumer，实现RocketMQListener接口。 使用@RocketMQMessageListener注解，连接到RocketMQ的test-topic主题，监听消息。 package com.example.rocketmq.consumer; import org.apache.rocketmq.spring.annotation.RocketMQMessageListener; import org.apache.rocketmq.spring.core.RocketMQListener; import org.springframework.stereotype.Component; @Component @RocketMQMessageListener(consumerGroup = \"my-consumer_test-topic\", topic = \"test-topic\") public class RocketConsumer implements RocketMQListener { @Override public void onMessage(String message) { System.out.println(\"RocketMQ Consumer consume message: \" + message); } } 创建控制器RocketController类，和用户交互，向RocketMQ发送消息。 package com.example.rocketmq.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.rocketmq.producer.RocketProducer; @RestController @RequestMapping(\"/rocketmq/\") public class RocketController { @Autowired RocketProducer rocketProducer; @RequestMapping(\"/send\") public String sendMsg(String msg) { rocketProducer.sendMessage(msg); return msg + \" Sended to test-topic.\"; } } 按照9.4.1小节中的单机RocketMQ服务器启动，然后启动Spring Boot应用。 C:\\Java\\rocketmq-all-4.6.0-bin-release\\bin>mqnamesrv.cmd C:\\Java\\rocketmq-all-4.6.0-bin-release\\bin>mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true 打开浏览器，输入http://localhost:8080/rocketmq/send?msg=Kevin is a GOODMAN.，向RocketMQ发送消息。 观察Spring Boot的控制台，检查消息消费者通过System.out打印出来的消息。 可以通过RocketMQ管理控制台查看消息的生产者信息： 通过RocketMQ管理控制台查看消息的消费者信息： 9.4.3.2 集群环境 修改上面“9.4.3.1 单机环境”小节创建的Spring Boot项目的配置文件application.yml，将name-server连接信息修改为集群的两个Name Server配置即可，其他所有代码都不需要修改。 rocketmq: name-server: 127.0.0.1:9876;127.0.0.1:9877 producer: send-message-timeout: 300000 group: my-group 测试运行，检查程序和集群是否正常匹配工作。 通过浏览器发送消息： 在Spring Boot的控制台中，检查消息消费者打印出来的信息： 在RocketMQ管理控制台中，可以看到这条消息是由broker-b接收和处理的。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-rocketmq "},"第9章 Spring Boot与异步消息/9.5kafka.html":{"url":"第9章 Spring Boot与异步消息/9.5kafka.html","title":"9.5 Spring Boot集成Kafka","keywords":"","body":"9.5 Spring Boot集成Kafka Kafka最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统）。常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。 Kafka®用于构建实时数据管道和流应用程序。它具有横向可扩展性、容错性、极快的速度，并在数千家公司的生产中运行。 主要应用场景是：日志收集系统和消息系统。 Kafka的主要设计目标： 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒10万+条消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个分区内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 支持在线水平扩展。 9.5.1 概念 为了理解Kafka，需要了解Kafka中的术语。下图展示了Kafka的相关概念以及之间的关系： 上图中一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。 如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。 9.5.1.1 broker Kafka 集群包含一个或多个服务器，服务器节点称为broker。broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。 如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。 如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。 9.5.1.2 Topic 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）。 Topic类似于数据库的表名。 9.5.1.3 Partition topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。 9.5.1.4 Producer 生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。 9.5.1.5 Consumer 消费者就是数据的使用者，可以从broker中读取数据。消费者可以消费多个topic中的数据。 9.5.1.6 Consumer Group 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。 9.5.1.7 Leader 每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。 9.5.1.8 Follower Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。 9.5.2 安装配置 到官网下载最新版本的使用Scala 2.12的Kafka 2.3.1，Kafka需要依赖 ZooKeeper，需要到zookeeper官网下载最新版本的ZooKeeper 3.5.6并提前安装配置好。 Kafka uses ZooKeeper so you need to first start a ZooKeeper server if you don't already have one. You can use the convenience script packaged with kafka to get a quick-and-dirty single-node ZooKeeper instance. bin/zookeeper-server-start.sh config/zookeeper.properties 9.5.2.1 安装ZooKeeper 解压下载后的apache-zookeeper-3.5.6-bin.tar.gz到磁盘，例如C:\\Java\\apache-zookeeper-3.5.6-bin目录。 Windows下使用WinRAR解压apache-zookeeper-3.5.6-bin.tar.gz有可能会出现错误，可使用7zip解压即可。 在ZooKeeper安装目录下创建data目录，例如C:\\Java\\apache-zookeeper-3.5.6-bin\\data。 进入C:\\Java\\apache-zookeeper-3.5.6-bin\\conf目录，拷贝zoo_sample.cfg为zoo.cfg，然后编辑配置信息。 # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=C:/Java/apache-zookeeper-3.5.6-bin/data # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to \"0\" to disable auto purge feature #autopurge.purgeInterval=1 打开命令提示符窗口，进入ZooKeeper的bin目录，执行zkServer.cmd命令启动服务。 在学习环境下，我们就不演示配置ZooKeeper高可用集群了。 9.5.2.2 安装Kafka 解压下载后的kafka_2.12-2.3.1.tgz文件到磁盘，例如C:\\Java\\kafka_2.12-2.3.1目录。 在Kafka安装目录下创建logs目录（C:\\Java\\kafka_2.12-2.3.1\\logs），用来存放日志文件。 编辑Kafka安装目录下config目录下的server.properties文件（C:\\Java\\kafka_2.12-2.3.1\\config\\server.properties）。修改的地方为log.dirs=C:/Java/kafka_2.12-2.3.1/logs（第60行）。需要检查连接到ZooKeeper的配置信息zookeeper.connect=localhost:2181（第123行）是否正确。 # Licensed to the Apache Software Foundation (ASF) under one or more # contributor license agreements. See the NOTICE file distributed with # this work for additional information regarding copyright ownership. # The ASF licenses this file to You under the Apache License, Version 2.0 # (the \"License\"); you may not use this file except in compliance with # the License. You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # see kafka.server.KafkaConfig for additional details and defaults ############################# Server Basics ############################# # The id of the broker. This must be set to a unique integer for each broker. broker.id=0 ############################# Socket Server Settings ############################# # The address the socket server listens on. It will get the value returned from # java.net.InetAddress.getCanonicalHostName() if not configured. # FORMAT: # listeners = listener_name://host_name:port # EXAMPLE: # listeners = PLAINTEXT://your.host.name:9092 #listeners=PLAINTEXT://:9092 # Hostname and port the broker will advertise to producers and consumers. If not set, # it uses the value for \"listeners\" if configured. Otherwise, it will use the value # returned from java.net.InetAddress.getCanonicalHostName(). #advertised.listeners=PLAINTEXT://your.host.name:9092 # Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details #listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL # The number of threads that the server uses for receiving requests from the network and sending responses to the network num.network.threads=3 # The number of threads that the server uses for processing requests, which may include disk I/O num.io.threads=8 # The send buffer (SO_SNDBUF) used by the socket server socket.send.buffer.bytes=102400 # The receive buffer (SO_RCVBUF) used by the socket server socket.receive.buffer.bytes=102400 # The maximum size of a request that the socket server will accept (protection against OOM) socket.request.max.bytes=104857600 ############################# Log Basics ############################# # A comma separated list of directories under which to store log files log.dirs=C:/Java/kafka_2.12-2.3.1/logs # The default number of log partitions per topic. More partitions allow greater # parallelism for consumption, but this will also result in more files across # the brokers. num.partitions=1 # The number of threads per data directory to be used for log recovery at startup and flushing at shutdown. # This value is recommended to be increased for installations with data dirs located in RAID array. num.recovery.threads.per.data.dir=1 ############################# Internal Topic Settings ############################# # The replication factor for the group metadata internal topics \"__consumer_offsets\" and \"__transaction_state\" # For anything other than development testing, a value greater than 1 is recommended for to ensure availability such as 3. offsets.topic.replication.factor=1 transaction.state.log.replication.factor=1 transaction.state.log.min.isr=1 ############################# Log Flush Policy ############################# # Messages are immediately written to the filesystem but by default we only fsync() to sync # the OS cache lazily. The following configurations control the flush of data to disk. # There are a few important trade-offs here: # 1. Durability: Unflushed data may be lost if you are not using replication. # 2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush. # 3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks. # The settings below allow one to configure the flush policy to flush data after a period of time or # every N messages (or both). This can be done globally and overridden on a per-topic basis. # The number of messages to accept before forcing a flush of data to disk #log.flush.interval.messages=10000 # The maximum amount of time a message can sit in a log before we force a flush #log.flush.interval.ms=1000 ############################# Log Retention Policy ############################# # The following configurations control the disposal of log segments. The policy can # be set to delete segments after a period of time, or after a given size has accumulated. # A segment will be deleted whenever *either* of these criteria are met. Deletion always happens # from the end of the log. # The minimum age of a log file to be eligible for deletion due to age log.retention.hours=168 # A size-based retention policy for logs. Segments are pruned from the log unless the remaining # segments drop below log.retention.bytes. Functions independently of log.retention.hours. #log.retention.bytes=1073741824 # The maximum size of a log segment file. When this size is reached a new log segment will be created. log.segment.bytes=1073741824 # The interval at which log segments are checked to see if they can be deleted according # to the retention policies log.retention.check.interval.ms=300000 ############################# Zookeeper ############################# # Zookeeper connection string (see zookeeper docs for details). # This is a comma separated host:port pairs, each corresponding to a zk # server. e.g. \"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002\". # You can also append an optional chroot string to the urls to specify the # root directory for all kafka znodes. zookeeper.connect=localhost:2181 # Timeout in ms for connecting to zookeeper zookeeper.connection.timeout.ms=6000 ############################# Group Coordinator Settings ############################# # The following configuration specifies the time, in milliseconds, that the GroupCoordinator will delay the initial consumer rebalance. # The rebalance will be further delayed by the value of group.initial.rebalance.delay.ms as new members join the group, up to a maximum of max.poll.interval.ms. # The default value for this is 3 seconds. # We override this to 0 here as it makes for a better out-of-the-box experience for development and testing. # However, in production environments the default value of 3 seconds is more suitable as this will help to avoid unnecessary, and potentially expensive, rebalances during application startup. group.initial.rebalance.delay.ms=0 打开命令提示符窗口，进入C:\\Java\\kafka_2.12-2.3.1\\bin\\windows目录，执行kafka-server-start.bat ..\\..\\config\\server.properties命令，启动Kafka服务器，默认服务监听端口9092。 [2019-12-08 11:21:44,907] INFO Awaiting socket connections on 0.0.0.0:9092. (kafka.network.Acceptor) 9.5.3 与Spring Boot集成 Spring为Kafka提供了依赖配置，集成非常方便。并且提供KafkaTemplate模板类来简化编码过程。 创建新的Spring Boot项目，添加Spring Web和Spring for Apache Kafka依赖。 pom文件中关键的Kafka依赖： org.springframework.kafka spring-kafka 在application.yml配置文件中配置连接到Kafka的信息： server: port: 9090 spring: kafka: bootstrap-servers: - 127.0.0.1:9092 consumer: group-id: test-consumer-group key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer producer: key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer 创建消息生产者KafkaProducer类，添加回调方法（消息消费成功后消息中间件会回调消息生产者）： package com.example.kafka.producer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.kafka.support.SendResult; import org.springframework.stereotype.Component; import org.springframework.util.concurrent.ListenableFuture; import org.springframework.util.concurrent.ListenableFutureCallback; @Component public class KafkaProducer { @Autowired private KafkaTemplate kafkaTemplate; public void sendMessage(String msg) { ListenableFuture> future = kafkaTemplate.send(\"KafkaTopic\", msg); future.addCallback(new ListenableFutureCallback>() { @Override public void onFailure(Throwable throwable) { System.out.println(\"Send Message Failure:\" + throwable.getMessage()); } @Override public void onSuccess(SendResult sendResult) { System.out.println(\"Send Message Success:\" + sendResult.toString()); } }); } } 创建消息消费者KafkaConsumer类： package com.example.kafka.consumer; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Component; @Component public class KafkaConsumer { @KafkaListener(topics = {\"KafkaTopic\"}) public void listen(ConsumerRecord record) { System.out.println(\"RocketMQ Consumer consume message: \" + record.value()); } } 创建控制器KafkaController类与用户交互： package com.example.kafka.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.kafka.producer.KafkaProducer; @RestController @RequestMapping(\"/kafka/\") public class KafkaController { @Autowired KafkaProducer kafkaProducer; @RequestMapping(\"/send\") public String sendMsg(String msg) { kafkaProducer.sendMessage(msg); return msg + \" Sended to KafkaTopic.\"; } } 这个时候启动Spring Boot应用可能会报错，原因是没有创建“KafkaTopic”主题，需要提前在Kafka中创建这个“KafkaTopic”主题。 org.springframework.context.ApplicationContextException: Failed to start bean 'org.springframework.kafka.config.internalKafkaListenerEndpointRegistry'; nested exception is java.lang.IllegalStateException: Topic(s) [KafkaTopic] is/are not present and missingTopicsFatal is true 创建KafkaTopic主题：kafka-topics.bat -create --bootstrap-server localhost:9092 -replication-factor 1 --partitions 1 --topic KafkaTopic 查看主题：kafka-topics -list --bootstrap-server localhost:9092 在确保Kafka消息中间件中有“KafkaTopic”主题的前提下启动Spring Boot应用。 打开浏览器，访问http://localhost:9090/kafka/send?msg=Kevin is a GOODMAN.地址，向Kafka发送消息。 观察Spring Boot应用的控制台，消息消费者KafkaConsumer消费消息后在控制台上输出正确的消息RocketMQ Consumer consume message: Kevin is a GOODMAN.，还可以看到回调消息生产者输出的结果Send Message Success...。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-kafka "},"第9章 Spring Boot与异步消息/9.6homework.html":{"url":"第9章 Spring Boot与异步消息/9.6homework.html","title":"9.6 课后作业","keywords":"","body":"9.6 课后作业 理解JMS和MQ的概念。 在Spring Boot中集成使用RocketMQ，并做常用消息发送接收练习。 "},"第10章 异常处理/Exception.html":{"url":"第10章 异常处理/Exception.html","title":"第10章 异常处理","keywords":"","body":"第10章 异常处理 异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误、试图打开一个不存在的文件等，这些都是意外的情况，背离我们程序本身的意图。为了能够及时有效地处理程序中的运行错误，Java 专门引入了错误（Error）类和异常（Exception）类。 Throwable类：是 Java 语言中所有错误和异常的超类。有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含了大量的子类。 Error类：是程序无法处理的错误，表示运行应用程序时遇到的较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。遇见这类错误，程序只有终止运行，例如OutOfMemoryError（继承自VirtualMachineError）、NoClassDefFoundError（继承自LinkageError）等。 Exception类：程序运行过程中出现的意外的情况，背离我们程序本身的意图，需要程序员接入处理。 异常和错误的本质区别是：异常能被程序本身处理，而错误无法处理。 Error是一种严重的问题，应用程序不应该捕捉它。 Error继承自Throwable而不是继承自Exception，就是为了方便程序可以使用 “catch (Exception)”来捕捉异常而不会把Error也捕捉在内。因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。 本章在介绍Java异常及异常处理的基础上，介绍Spring Boot中如何处理全局异常，及针对某些异常的重试机制。 "},"第10章 异常处理/10.1exceptionOverview.html":{"url":"第10章 异常处理/10.1exceptionOverview.html","title":"10.1 异常介绍","keywords":"","body":"10.1 异常介绍 异常分为编译时异常和运行时异常： 编译时的异常，我们可以直观的看见，可以进行立马的更改，由Java编译器把关，不处理（修改代码）编译时异常就不会生成Java程序（Java字节码class文件）。 运行时的错误，则是编译器能力之外的事情，我们预料不到的错误，如果不更改，程序就会崩溃，例如用户输一个超越数组大小的数字来访问数组中的元素时，就会出现ArrayIndexOutOfBoundsException这个异常。 Java中的异常体系，简要的如下图所示： Java 定义了两种类型的异常： Checked exception：继承自 Exception 类的就是 Checked exception。代码需要明确的处理抛出的 Checked exception，要么用 catch 语句，要么直接用 throws 语句抛出去让调用方处理。 Unchecked exception：也称 RuntimeException，它也是继承自 Exception。但所有 Runtime Exception 的子类都有个特点，就是代码不需要处理它们的异常也能通过编译，所以它们称作 Unchecked Exception。RuntimeException（运行时异常）就是不需要try...catch...或throws 机制去处理的异常。 如果出现了RuntimeException，就一定是程序员自身的问题。比如说，数组下标越界（程序应该控制不越界的下标）和访问空指针异常等等，只要你稍加留心这些异常都是在编码阶段可以避免的异常。 Java中常见的异常及说明如下： 异常类型 说明 Exception 异常的根类，继承自Throwable类 RuntimeException 运行时异常，多数 java.lang 异常的根类 ArithmeticException 算术错误异常，如以零做除数 ArraylndexOutOfBoundException 数组下标小于或大于实际的数组大小 NullPointerException 著名的NPE，尝试访问 null 对象成员，空指针异常 ClassNotFoundException 不能加载所需的类 NumberFormatException 数字转化格式异常，比如字符串到 float 型数字的转换无效 IOException I/O 异常的根类 FileNotFoundException 找不到文件 EOFException 文件结束 InterruptedException 线程中断 IllegalArgumentException 方法接收到非法参数 ClassCastException 类型转换异常 SQLException SQL操作数据库异常 在实际工作中最经常遇到的5大异常： 异常 示例说明 ArithmeticException int a=0;int b= 3/a; ClassCastException Object x = new Integer(0);System.out.println((String)x); IndexOutOfBoundsException ArrayIndexOutOfBoundsException StringIndexOutOfBoundsException int [] numbers = { 1, 2, 3 };int sum = numbers[3]; IllegalArgumentException NumberFormatException int a = Interger.parseInt(\"test\"); NullPointerException 著名的NPE，空指针异常 在Java语言中，通过面向对象的方法来处理异常。如果在一个方法的运行过程中发生了异常，则这个方法会产生代表该异常的一个对象，并把它交给运行时的系统，运行时系统寻找相应的代码来处理这一异常。 我们把生成异常对象，并把它提交给运行时系统的过程称为拋出（throw）异常。运行时系统在方法的调用栈中查找，直到找到能够处理该类型异常的对象，这一个过程称为捕获（catch）异常。 Java异常强制用户考虑程序的强健性和安全性。异常处理不应该用来控制程序的正常流程，而应该用来捕获程序在运行时发生的异常行为并进行相应处理，让程序能够回到正常的预期运行状态，按照编写代码时期望的路径上运行（一般而言，就是符合客户需求预期）。 编写代码处理某个方法可能出现的异常，可遵循如下三个原则： 在当前方法声明中使用 try catch 语句捕获异常。 一个方法被覆盖时，覆盖它的方法必须拋出相同的异常或异常的子类。 如果父类抛出多个异常，则覆盖方法必须拋出那些异常的一个子集，而不能拋出新的异常。 典型的异常处理代码： try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }finally{ // 程序代码 } 另外，也可以在具体位置不处理异常（无论它是新实例化的还是刚捕获到的），通过throw直接抛出到上层再进行处理。这个不处理受查异常（Checked exception）的方法必须使用 throws 关键字来声明（throws 关键字放在方法签名的尾部）。 import java.io.*; public class TestClass { public void doSomthing(String[] args) throws SomeException { //程序代码 throw new SomeException(); } //其他方法 } "},"第10章 异常处理/10.2globalException.html":{"url":"第10章 异常处理/10.2globalException.html","title":"10.2 Spring Boot中全局异常的使用","keywords":"","body":"10.2 Spring Boot中全局异常的使用 在实际工作中，我们大部分时间在使用Spring Boot开发Web应用（当然，最经常使用到的是框架是Spring MVC）。由于和用户多有交互，所以在请求的过程中，发生错误异常是很常见的。Spring Boot为我们提供了一套默认的异常/错误处理机制，帮助我们来处理交互过程中的异常/错误。 官方文档，对错误处理的描述如下： By default, Spring Boot provides an /error mapping that handles all errors in a sensible way, and it is registered as a “global” error page in the servlet container. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error view that renders the same data in HTML format (to customize it, add a View that resolves to error). To replace the default behavior completely, you can implement ErrorController and register a bean definition of that type or add a bean of type ErrorAttributes to use the existing mechanism but replace the contents. 例如，当我们通过浏览器访问一个不存在的url地址时，服务器就产生一个“404 Not Found”错误，Spring Boot提供的默认映射“/error”就起作用了，在这个请求中处理“404 Not Found”然后通过为该请求配置的默认全局错误页面来展示错误信息。 Spring Boot默认在没有找到对应的Controller处理器方法（handler not found）的情况下，不会直接报错，而是通过向Servlet容器（如Tomcat）设置错误报告属性，然后Servlet容器发现错误（例如，http status=404），就查找默认“/error” 这个路径，Spring Boot就接管后续全局统一异常处理。 如果是通过Postman之类的工具以Post方式访问，Spring Boot的默认全局异常处理机制则会返回一段json信息。 10.2.1 Spring Boot默认全局异常 在Spring Boot提供的org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration类通过自动配置错误处理Bean，为Web容器提供了默认的全局异常处理机制。 ... @Bean//1.DefaultErrorAttributes @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); } @Bean//2.BasicErrorController @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT) public BasicErrorController basicErrorController(ErrorAttributes errorAttributes, ObjectProvider errorViewResolvers) { return new BasicErrorController(errorAttributes, this.serverProperties.getError(), errorViewResolvers.orderedStream().collect(Collectors.toList())); } @Bean//3.ErrorPageCustomizer public ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) { return new ErrorPageCustomizer(this.serverProperties, dispatcherServletPath); } ... @Configuration(proxyBeanMethods = false) static class DefaultErrorViewResolverConfiguration { private final ApplicationContext applicationContext; private final ResourceProperties resourceProperties; DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, ResourceProperties resourceProperties) { this.applicationContext = applicationContext; this.resourceProperties = resourceProperties; } @Bean//4.DefaultErrorViewResolver @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean(ErrorViewResolver.class) DefaultErrorViewResolver conventionErrorViewResolver() { return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); } } @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(prefix = \"server.error.whitelabel\", name = \"enabled\", matchIfMissing = true) @Conditional(ErrorTemplateMissingCondition.class) protected static class WhitelabelErrorViewConfiguration { private final StaticView defaultErrorView = new StaticView(); @Bean(name = \"error\")//将StaticView（就是Whitelabel错误页面）配置为error @ConditionalOnMissingBean(name = \"error\") public View defaultErrorView() { return this.defaultErrorView; } ... 10.2.1.1 DefaultErrorAttributes 其中配置的org.springframework.boot.web.servlet.error.DefaultErrorAttributes类，为我们提供了在页面共享信息的“getErrorAttributes”方法。 @Override public Map getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map errorAttributes = new LinkedHashMap<>(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, webRequest); addErrorDetails(errorAttributes, webRequest, includeStackTrace); addPath(errorAttributes, webRequest); return errorAttributes; } 10.2.1.2 BasicErrorController 其中配置的org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController类，根据请求头的不同，提供了不同的方法处理默认/error请求。 普通html请求使用errorHtml方法，返回error错误页面并携带错误数据。 其他的请求（例如Postman发起的请求）使用error方法，返回json数据。 @RequestMapping(\"${server.error.path:${error.path:/error}}\")：这是一个三元写法，如果你在配置文件配置了server.error.path的话，就会使用你配置的异常处理地址，如果没有就会使用你配置的error.path路径地址，如果还是没有，默认使用/error来作为发生异常的处理地址。 @Controller @RequestMapping(\"${server.error.path:${error.path:/error}}\")//拦截/error请求 public class BasicErrorController extends AbstractErrorController { ... @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)//处理浏览器请求，返回错误html页面 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map model = Collections .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model); } @RequestMapping//处理“machine clients”请求，例如Postman发起的请求，返回json数据 public ResponseEntity> error(HttpServletRequest request) { HttpStatus status = getStatus(request); if (status == HttpStatus.NO_CONTENT) { return new ResponseEntity<>(status); } Map body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); return new ResponseEntity<>(body, status); } 例如，我们在浏览器中访问了一个不存在的url，Spring MVC将其错误信息封装到DefaultErrorAttributes（由getErrorAttributes方法提供数据），然后将其转发到“/error”请求，由BasicErrorController.errorHtml方法接管处理。 其中的org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration.StaticView类的“render”方法提供的就是我们经常能够看到的“Whitelabel Error Page”页面。 private static class StaticView implements View { private static final MediaType TEXT_HTML_UTF8 = new MediaType(\"text\", \"html\", StandardCharsets.UTF_8); private static final Log logger = LogFactory.getLog(StaticView.class); @Override public void render(Map model, HttpServletRequest request, HttpServletResponse response) throws Exception { if (response.isCommitted()) { String message = getMessage(model); logger.error(message); return; } response.setContentType(TEXT_HTML_UTF8.toString()); StringBuilder builder = new StringBuilder(); Date timestamp = (Date) model.get(\"timestamp\"); Object message = model.get(\"message\"); Object trace = model.get(\"trace\"); if (response.getContentType() == null) { response.setContentType(getContentType()); } builder.append(\"Whitelabel Error Page\").append( \"This application has no explicit mapping for /error, so you are seeing this as a fallback.\") .append(\"\").append(timestamp).append(\"\") .append(\"There was an unexpected error (type=\").append(htmlEscape(model.get(\"error\"))) .append(\", status=\").append(htmlEscape(model.get(\"status\"))).append(\").\"); if (message != null) { builder.append(\"\").append(htmlEscape(message)).append(\"\"); } if (trace != null) { builder.append(\"\").append(htmlEscape(trace)).append(\"\"); } builder.append(\"\"); response.getWriter().append(builder.toString()); } ... 10.2.1.3 ErrorPageCustomizer 其中的org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration.ErrorPageCustomizer类，在Spring Boot（Spring MVC）应用启动时，读取server.error.path配置属性，注册ErrorPage，在应用出现异常（比如404）时就能找到对应的页面（/error）进行处理。 private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered { private final ServerProperties properties; private final DispatcherServletPath dispatcherServletPath; protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) { this.properties = properties; this.dispatcherServletPath = dispatcherServletPath; } @Override public void registerErrorPages(ErrorPageRegistry errorPageRegistry) { ErrorPage errorPage = new ErrorPage( this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())); //this.properties.getError().getPath()=server.error.path=error(默认值) errorPageRegistry.addErrorPages(errorPage); } @Override public int getOrder() { return 0; } } 10.2.1.4 DefaultErrorViewResolver 其中的org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver类，完成默认的错误视图解析工作。 @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map model) { ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map model) { //Spring Boot去找到一个处理错误的页面，例如error/404 String errorViewName = \"error/\" + viewName; TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) { return new ModelAndView(errorViewName, model); } return resolveResource(errorViewName, model); } ... 10.2.1.5 全局异常处理过程 默认情况下，Web应用一旦出现错误，Spring Boot全局异常体系就接管该错误，并按照如下步骤进行处理： 系统启动时ErrorPageCustomizer注册错误处理页面，并准备为异常服务； 一但系统出现4xx或者5xx之类的错误，“/error”请求会被BasicErrorController处理，根据请求头的不同，返回页面或json数据； 在返回页面的情况下，由DefaultErrorViewResolver解析得到由ErrorPageCustomizer注册的响应页面，如果没有指定页面，BasicErrorController就使用\"error\"视图； \"error\"视图是由StaticView这个类提供的“Whitelabel Error Page”页面。 10.2.1.6 跟踪代码，加深理解 为了理解Spring Boot在Spring MVC应用中提供的全局异常处理机制，建议读者以调试方式启动Spring Boot应用，通过浏览器访问一个不存在的地址（例如http://localhost:8080/good），跟踪代码，加深理解。 在org.springframework.web.servlet.DispatcherServlet.doDispatch方法处设置断点； 在org.apache.catalina.core.StandardHostValve.status方法处设置断点； 在org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml方法处设置断点； 在org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver.resolve方法处设置断点； 然后跟踪代码： 第1次进入doDispatch方法，是浏览器发起的，观察request的attributes中的值org.springframework.web.servlet.HandlerMapping.lookupPath=/good，DispatcherType=REQUEST； 然后进入status方法，tomcat设置statusCode=404，ErrorPage[errorCode=0, location=/error]，然后转发错误请求“/error”； 第2次进入doDispatch方法，观察request的dispatcherType=DispatcherType.ERROR，servletPath=/error；匹配的mappedHandler=org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml； 后续就由errorHtml方法接管错误处理了。在ModelAndView modelAndView = resolveErrorView(request, response, status, model)查找对应的视图（view），我们没有指定视图的情况下返回null，然后在return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model)代码处为指定Model为“error”（ModelAndView(\"error\", model)）； 浏览器得到“Whitelabel Error Page”错误页面。 10.2.2 自定义全局异常 在SpringBoot 统一异常处理的做法主要有两种：一是使用注解ExceptionHandler处理某个特定的异常类，二是实现接口ErrorController或继承扩展AbstractErrorController类（BasicErrorController就继承自这个类）。 本小节使用“Thymeleaf模板引擎+Spring MVC”的Spring Boot应用，来讲解提供自定义错误页面进行如何优雅的全局异常处理。 10.2.2.1 自定义错误页面 在resources/templates下面创建error.html页面，内容如下： 哦豁 发生错误啦！（使用Thymeleaf动态错误页面） 如果要细分错误码（如404，500）则在resources/templates/error下创建对应的页面，如500.html，内容如下： 哦豁 发生“服务器内部”错误啦！（使用Thymeleaf动态错误页面） 404.html： 哦豁 你访问的页面逃跑啦！（使用Thymeleaf动态错误页面） 通过一个Controller方法，内部除0发生异常，来测试500错误： package com.example.exception.foo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/exception/\") public class TestController { @RequestMapping(\"/serverError\") public String serverError() { double d = 100/0; return \"error\" + d; } } 浏览器访问http://localhost:8080/exception/serverError，由500.html响应的效果如下： 浏览器访问http://localhost:8080/hello，由404.html响应的效果如下： 10.2.2.2 扩展DefaultErrorAttributes类 如果我们需要在错误发生的时候，生成（或提供）更多的信息，可以扩展Spring Boot提供的DefaultErrorAttributes类，在其中添加额外的错误信息。 package com.example.exception.component; import java.util.Map; import org.springframework.boot.web.servlet.error.DefaultErrorAttributes; import org.springframework.stereotype.Component; import org.springframework.web.context.request.WebRequest; @Component public class ExErrorAttributes extends DefaultErrorAttributes { @Override public Map getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); // 从ExExceptionHandler中传递过来的额外异常信息，放入到errorAttributes中，供后续错误处理页面用。 String msg = (String) webRequest.getAttribute(\"extErrorMsg\", 0); errorAttributes.put(\"extErrorMsg\", msg); return errorAttributes; } } 10.2.2.3 自定义异常处理类 创建一个异常类DemoException，用来演示抛出异常。 package com.example.exception.component; public class DemoException extends RuntimeException { private static final long serialVersionUID = -9185062164416168469L; public DemoException() { super(\"演示用异常\"); } } 自定义一个异常处理类，专门处理DemoException异常： package com.example.exception.component; import javax.servlet.http.HttpServletRequest; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; @ControllerAdvice public class ExExceptionHandler { @ExceptionHandler(DemoException.class) public String handleException(Exception e, HttpServletRequest request) { request.setAttribute(\"javax.servlet.error.status_code\", 500); request.setAttribute(\"extErrorMsg\", \"演示用异常，扩展信息。\"); return \"forward:/error\"; } } 102.2.4 测试 在控制器TestController中添加一个方法，其内部抛出DemoException，测试。 package com.example.exception.foo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.exception.component.DemoException; @RestController @RequestMapping(\"/exception/\") public class TestController { @RequestMapping(\"/demoException\") public String serverError() { throw new DemoException(); } @RequestMapping(\"/serverError\") public String serverError2() { double d = 100/0; return \"error\" + d; } } 打开浏览器访问http://localhost:8080/exception/demoException，验证自定义异常的处理效果。 使用Postman发起请求，同样能够得到期望的异常信息。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-exception "},"第10章 异常处理/10.3retry.html":{"url":"第10章 异常处理/10.3retry.html","title":"10.3 异常的重试","keywords":"","body":"10.3 异常的重试 在实际项目中，有些业务场景需要我们对一些异常情况下的任务进行重试，比如：调用第三方接口RPC服务，可能由于网络抖动、连接超时等网络异常，多尝试几次就可以恢复正常。 如果我们要做重试，为特定的某个操作提供重试功能，就需要硬编码。大概逻辑基本都是写个循环，根据返回或异常，计数失败的次数，然后设定退出条件。这样做，每个操作都要写这种类似的代码，而且重试逻辑和业务逻辑混在一起，给维护和扩展带来了麻烦。从面向对象和面向方面（AOP）的角度来看，我们应该把重试的代码独立出来。 Spring提供的独立出来的重试框架就是spring-retry项目，它是从Spring Batch（从2.2.0版本中独立出来）中独立出来的一个项目，主要实现了重试和熔断，被用到Spring Batch、Spring Integration等项目中。 This project provides declarative retry support for Spring applications. It is used in Spring Batch, Spring Integration, and others. Imperative retry is also supported for explicit usage. spring-retry对于重试是有场景限制的，不是什么场景都适合重试，比如参数校验不合法、写操作等（要考虑写是否幂等）都不适合重试。远程调用超时、网络突然中断可以重试。在微服务治理框架中，通常都有自己的重试与超时配置，比如dubbo可以设置retries=1，timeout=500调用失败只重试1次，超过500ms调用仍未返回则调用失败。在spring retry中可以指定需要重试的异常类型，并设置每次重试的间隔以及如果重试失败是继续重试还是熔断（停止重试）。 10.3.1 重试策略 spring-retry通过接口RetryPolicy（重试策略）及其8个实现类提供了8种重试策略。 NeverRetryPolicy：只允许调用RetryCallback一次，不允许重试； AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环； SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为3次，是RetryTemplate默认使用的策略； ExpressionRetryPolicy：表达式重试策略，符合表达式就会重试； TimeoutRetryPolicy：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试； ExceptionClassifierRetryPolicy：设置不同异常的重试策略，类似组合重试策略，区别在于这里只区分不同异常的重试； CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate，如果不在熔断状态，则允许重试； CompositeRetryPolicy：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以重试，悲观组合重试策略是指只要有一个策略不允许重试即不可以重试，但不管哪种组合方式，组合中的每一个策略都会执行。 10.3.2 退避策略 两次重试之间需要立即重试还是等待一段时间后重试，就是退避策略。 比如发生网络错误，立即重试将导致立即失败，最好的办法是等待一小段时间后重试，这还可以防止很多服务同时重试导致的DDoS（Distributed Denial of Service）。 spring-retry通过接口BackOffPolicy（退避策略）及其5个实现类提供了5种退避策略。 FixedBackOffPolicy：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒； NoBackOffPolicy：无退避算法策略，即需要重试时立即重试； UniformRandomBackOffPolicy：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在[minBackOffPeriod, maxBackOffPeriod]之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒； ExponentialBackOffPolicy：指数退避策略，需设置参数sleeper、initialInterval、maxInterval和multiplier，initialInterval指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，multiplier指定乘数，即下一次休眠时间为当前休眠时间*multiplier； ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，相对ExponentialBackOffPolicy和FixedBackOffPolicy可能会引起很多服务同时重试导致DDoS，使用随机休眠时间就可以避免这种情况。 10.3.3 无状态重试 在最简单的情况下，重试只是一个while循环：RetryTemplate可以一直尝试，直到成功或失败。RetryContext包含一些状态以确定是重试还是中止。但是，这个状态在堆栈上，不需要在全局任何地方存储它。因此，我们称之为无状态重试。无状态重试和有状态重试之间的区别包含在RetryPolicy的实现中（RetryTemplate可以处理这两者）。在无状态重试中，回调始终在重试失败时的同一线程中执行。 10.3.4 有状态重试 无状态重试情况下产生异常，并不会将其抛出去，这对于事务性调用，是不可容忍的，因为上层框架需要获得异常进行事务的回滚操作。这个时候就应当使用有状态重试。 BinaryExceptionClassifier classifier = new BinaryExceptionClassifier(Collections.singleton(Throwable.class)); RetryState state = new DefaultRetryState(\"mykey\", false, classifier); String result = template.execute((RetryCallback)context -> { remoteInvoke(); return \"ret\"; }, context -> { return \"recovery\"; }, state); 事务的开销一般较大，这里虽然能够有状态重试进行事务的回滚，但并不建议去进行事务的重试，而应当使用failfast机制，可能更加合理一些。 10.3.5 声明式重试 spring-retry官方给出了最简单的声明式重试代码示例。通过@EnableRetry、@Retryable和@Recover注解完成声明式重试的代码的编写。 @Configuration @EnableRetry public class Application { @Bean public Service service() { return new Service(); } } @Service class Service { @Retryable(RemoteAccessException.class) public void service() { // ... do something } @Recover public void recover(RemoteAccessException e) { // ... panic } } 以上代码：在调用service方法时，如果发生RemoteAccessException异常就开始重试（默认重试策略，重试3次），如果重试不成功，则调用recover方法。 10.3.6 命令式重试 spring-retry官方给出了最简单的命令式重试代码示例。 命令式重试使用Spring一贯的API风格：RetryTemplate模板实现，是线程安全的。 RetryTemplate将重试、熔断功能封装到模板中，提供健壮和不易出错的API供我们使用。 RetryTemplate template = RetryTemplate.builder() .maxAttempts(3) .fixedBackoff(1000) .retryOn(RemoteAccessException.class) .build(); template.execute(ctx -> { // ... do something }); 10.3.7 在Spring Boot中使用spring-retry 新建Spring Boot web应用，在pom文件种添加spring-retry和aspectjweaver依赖。 org.springframework.boot spring-boot-starter-web org.springframework.retry spring-retry org.aspectj aspectjweaver 在Spring Boot启动类上使用注解@EnableRetry打开重试配置。 package com.example.retry; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.retry.annotation.EnableRetry; @SpringBootApplication @EnableRetry public class SpringBootRetryApplication { public static void main(String[] args) { SpringApplication.run(SpringBootRetryApplication.class, args); } } 添加重试服务类RetryService，在service方法上标注@Retryable，在recover方法上标注@Recover。 package com.example.retry.service; import java.time.LocalTime; import org.springframework.retry.annotation.Backoff; import org.springframework.retry.annotation.Recover; import org.springframework.retry.annotation.Retryable; import org.springframework.stereotype.Service; @Service public class RetryService { @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 2000, multiplier = 1.5)) public int service(int code) throws Exception { System.out.println(\"service called: \" + LocalTime.now()); if (code == 0) { throw new Exception(\"EXCCEPTION: It's bad.\"); } System.out.println(\"service called, it's good.\"); return 200; } @Recover public int recover(Exception e){ System.out.println(\"retry recover.\"); return 500; } } 添加控制器RetryController类，与用户进行交互。 package com.example.retry.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.retry.service.RetryService; @RestController @RequestMapping(\"/retry/\") public class RetryController { @Autowired RetryService service; @RequestMapping(\"/service\") public String service(int code) throws Exception { int result = service.service(code); return \"spring-retry in Spring Boot: \"+ result; } } 打开浏览器，输入http://localhost:8080/retry/service?code=0地址，通过传入code=0这个参数，触发异常重试，测试。 通过后台观察，重试了3次，最后调用了@Recover标注的方法。 打开浏览器，输入http://localhost:8080/retry/service?code=6998地址，通过传入code=6998这个参数，不触发异常，调用服务不需要重试，测试。 通过后台观察，没有异常，没有重试，程序代码逻辑正常。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-retry "},"第10章 异常处理/10.4homework.html":{"url":"第10章 异常处理/10.4homework.html","title":"10.4 课后作业","keywords":"","body":"10.4 课后作业 理解Spring Boot中的全局异常处理机制； 动手实现捕获AnotherDemoException（extends RuntimeException）的全局异常处理代码； 动手练习在Spring Boot中集成spring-retry，使用RetryTemplate进行重试。 "},"第11章 单元测试与热部署/UnitTestHotDeploy.html":{"url":"第11章 单元测试与热部署/UnitTestHotDeploy.html","title":"第11章 单元测试与热部署","keywords":"","body":"第11章 单元测试与热部署 单元测试是对软件或程序的基本（最小）组成单元的测试，可以让你在软件开发的早期阶段发现 Bug，而不必到集成测试的时候才发现，完善的单元测试，能够在打包之前完成自动化的代码级白盒测试，保证程序代码在方法级的逻辑正确。 日常的开发过程中，通常伴随着修改，重启，测试，验证，再修改的过程。这一重复性过程导致了工作中较多的“无效”工作时间。热部署机制能够监控项目中的修改点（页面，代码，配置等），适时选择重新加载或重新启动应用的方式，帮助开发人员较为流程的完成业务逻辑的开发或修改。 本章，我们学习Spring Boot集成JUnit对应用进行单元测试和通过spring-boot-devtools依赖启动器对项目提供的热部署机制。 "},"第11章 单元测试与热部署/11.1unitTest.html":{"url":"第11章 单元测试与热部署/11.1unitTest.html","title":"11.1 Spring Boot中的单元测试","keywords":"","body":"11.1 Spring Boot中的单元测试 单元测试是指对软件中的最小可测试单元进行检查和验证，单元测试归属于白盒测试。 这个定义有点抽象，下面举几个单元测试的特性，大家感受一下： 一般是一个函数配几个单元测试； 单元测试不应该依赖外部系统； 单元测试运行速度很快； 单元测试不应该造成测试环境的脏数据； 单元测试可以重复运行。 单元测试使得我们可以放心修改、重构业务代码，而不用担心修改某处代码后带来的副作用。 单元测试可以帮助我们反思模块划分的合理性，如果一个单元测试写得逻辑非常复杂、或者说一个函数复杂到无法写单元测试，那就说明模块的抽象有问题。 单元测试使得系统具备更好的可维护性、具备更好的可读性。对于团队的新人来说，可以从单元测试入手阅读代码，进而熟悉系统的逻辑。 优秀的开源框架，都配有完善的单元测试套件（Test Suite），以保证代码质量。 越是底层的代码，越是被更多客户调用的代码，越应该实践TDD（Test-Driven Development，测试驱动开发）。 测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。 虽然，我们日常工作中不会为每一段业务逻辑（类或方法）提供单元测试，但是针对大部分的产品级业务系统（主要工作是在某一技术基础平台上实现业务逻辑），都应该写单元测试。 大部分开发人员使用的单元测试框架都是JUnit，这也是Spring Boot的选择。 11.1.1 使用单元测试 Spring Boot官方文档，对如何进行测试进行了充分的说明。 Spring Boot provides a number of utilities and annotations to help when testing your application. Test support is provided by two modules: spring-boot-test contains core items, and spring-boot-test-autoconfigure supports auto-configuration for tests. 使用Spring Starter创建项目时，默认就添加了spring-boot-starter-test依赖。 查看项目pom文件中的单元测试依赖： org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine spring-boot-starter-test启动器依赖提供如下支持库： JUnit 5（包括与JUnit 4向后兼容的老式引擎）：Java领域的单元测试事实标准，使用最广泛的测试支持库。 Spring Test和Spring Boot Test：对Spring Boot应用提供集成测试支持。 AssertJ：Java领域常用的功能完备的断言库。 Hamcrest：一个匹配对象的库（也称为约束或谓词）。 Mockito：一个Java模拟框架，比如模拟http容器环境。 JSONassert：JSON的断言库。 JsonPath：JSON的XPath支持库。 Spring Boot认为这些公共库在编写测试时很有用。如果这些库不适合我们的需要，也可以手动添加自己喜欢的测试依赖库。 通过查看org.springframework.boot:spring-boot-starters依赖，可以看到其依赖的JUnit的版本信息 org.junit.jupiter junit-jupiter 5.5.2 compile 打开Spring Boot创建的项目中的默认单元测试入口类SpringBootTestApplicationTests： package com.example.test; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class SpringBootTestApplicationTests { @Test void contextLoads() { } } 在contextLoads方法中添加一个断言： @Test void contextLoads() { int num = new Integer(6998); assertEquals(num, 6998); } 选中单元测试入口类，运行JUnit Test： 查看单元测试运行结果，如果没有错误，会出现熟悉的绿色长条。 11.1.2 普通后台代码测试 添加测试用的DAO类TestDAO，模拟从数据库中查询数据后返回用户年龄。其业务逻辑是“kevin用户的年龄为18岁”。 package com.example.test.dao; import org.springframework.stereotype.Repository; @Repository public class TestDAO { //模拟从数据库访问数据后返回用户的年龄 public int getUserAge(String userId) { int result = 0; if (userId.equals(\"kevin\")) { result = 18; } else if (userId.equals(\"roy\")) { result = 12; } else { result = 28; } return result; } } 添加测试用服务类TestService，使用TestDAO从数据库（模拟）中获取用户年龄。 package com.example.test.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.example.test.dao.TestDAO; @Service public class TestService { @Autowired TestDAO testDAO; public int getUserAge(String userId) { return testDAO.getUserAge(userId); } } 在测试启动类中添加测试方法testService，使用注入的TestService获取用户kevin的年龄，并做相等断言（年龄等于18）。 @Autowired TestService testService; @Test void testService() { int age = testService.getUserAge(\"kevin\"); assertEquals(18, age); } 运行测试，查看测试结果。 11.1.3 使用Mock测试控制层 由于控制器层会从浏览器接收用户的输入，所以在对测试控制层进行单元测试时，需要对Spring MVC和Servlet容器进行模拟，具体的模拟类为MockMvc。 修改测试启动类，为其添加@AutoConfigureMockMvc注解，启动MockMvc，创建testControllerGetUserAge测试方法，注意理解其中使用的MockMvc.perform方法，MockMvcRequestBuilders.get方法，MockMvcResultMatchers.status方法和MockMvcResultMatchers.content方法。 package com.example.test; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; @SpringBootTest @AutoConfigureMockMvc class SpringBootTestApplicationTests { @Test void testControllerGetUserAge(@Autowired MockMvc mvc) throws Exception { mvc.perform(MockMvcRequestBuilders.get(\"/test/getUserAge?userId=kevin\") .accept(MediaType.TEXT_PLAIN)) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().string(\"User[kevin]'s age is: 18.\")); } } 运行JUnit Test，检查测试结果： 11.1.4 运行服务器后测试 有时候我们需要在一个完整运行的服务器中进行控制层的测试（模拟用户的浏览器操作行为），这个时候，我们可以使用Spring Boot提供的TestRestTemplate模板类来完成对运行中的服务器进行测试。 这个行为，已经不太像单元测试了，我个人认为有点儿像自动化测试了。 package com.example.test; import org.assertj.core.api.Assertions; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.web.client.TestRestTemplate; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class RandomPortTestRestTemplateExampleTests { @Test void exampleTest(@Autowired TestRestTemplate restTemplate) { String body = restTemplate.getForObject(\"/test/getUserAge?userId=kevin\", String.class); Assertions.assertThat(body).isEqualTo(\"User[kevin]'s age is: 18.\"); } } 运行JUnit Test，然后查看测试结果： 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-test "},"第11章 单元测试与热部署/11.2hotDeploy.html":{"url":"第11章 单元测试与热部署/11.2hotDeploy.html","title":"11.2 Spring Boot对热部署的支持","keywords":"","body":"11.2 Spring Boot对热部署的支持 spring-boot-devtools是一个为开发者服务的一个模块，主要功能是监控程序的变化，然后进行自动重新启动，速度比手动停止后再启动要快，这样就可以节省出来手工操作的时间，达到提高开发效率工作效率的目的。 其实现原理主要是使用了两个类加载器（ClassLoader）： 一个根Class Loader加载不会改变的类（第三方Jar包）； 另一个称为 Restart Class Loader的类加载器加载会更改的类，这样在有代码更改的时候，原来的Restart Class Loader 被丢弃，重新创建一个新的Restart Class Loader，由于需要加载的类相比较少，所以实现了较快（秒级）的重启时间。 默认情况下，当DevTools检测到classpath下有文件（Class文件、配置文件等资源）内容变更时，它会对当前Spring Boot应用进行重新启动。 这种设计可以让程序快速的进行重启，因为这个时候第三方jar包中的资源已经在第一次启动的时候进行加载了，自动重启的时候就不需要加载它们了。在开发的时候，希望改动后立马生效的通常也是应用中自己定义的Class及其它资源。 在日常开发中，有些时候，我们会在修改了一组文件后才测试，也就是说我们不想在改变Class Path路径下的任何文件后立马就进行自动重启，而是希望在更改了很多文件后，在更改了一个特殊的文件后才触发自动重启。针对这种情况，可以通过spring.devtools.restart.trigger-file属性指定触发自动重启的文件，这样当该文件的内容发生了变更后就会触发自动重启。比如下面的配置就表示当更改了application.properties文件的内容时将触发自动重启。 spring.devtools.restart.trigger-file=application.properties 通过查看DevToolsPropertyDefaultsPostProcessor类，可以了解到devtools为方便开发提供的默认值： private static final Map PROPERTIES; static { Map properties = new HashMap<>(); properties.put(\"spring.thymeleaf.cache\", \"false\"); properties.put(\"spring.freemarker.cache\", \"false\"); properties.put(\"spring.groovy.template.cache\", \"false\"); properties.put(\"spring.mustache.cache\", \"false\"); properties.put(\"server.servlet.session.persistent\", \"true\"); properties.put(\"spring.h2.console.enabled\", \"true\"); properties.put(\"spring.resources.cache.period\", \"0\"); properties.put(\"spring.resources.chain.cache\", \"false\"); properties.put(\"spring.template.provider.cache\", \"false\"); properties.put(\"spring.mvc.log-resolved-exception\", \"true\"); properties.put(\"server.error.include-stacktrace\", \"ALWAYS\"); properties.put(\"server.servlet.jsp.init-parameters.development\", \"true\"); properties.put(\"spring.reactor.debug\", \"true\"); PROPERTIES = Collections.unmodifiableMap(properties); } 当然，在我们的应用中，某些资源的修改其实并不需要重启服务。比如前端使用的静态资源文件，默认情况下，Spring Boot 在以下这些目录中的资源变更时，不会触发重启（但是会触发 live reload）： /META-INF/maven , /META-INF/resources , /resources , /static , /public , /templates 我们也可以手动指定不需要重启的资源，覆盖devtools的默认值： spring.devtools.restart.exclude=static/**,public/** 也可以在默认值上额外添加不需要重启的资源： spring.devtools.restart.additional-exclude = /custom-path/** 如果我们觉得 Spring Boot dev-tools 提供的重启还是不够快的话，可以尝试使用其它的基于 Reload 的技术，如收费的JRebel。 在Spring Boot中使用devtools非常方便。使用Spring Starter创建项目时，勾选Spring Boot DevTools启动器依赖即可。 创建的初始项目pom文件中配置dev-tools的依赖为： org.springframework.boot spring-boot-devtools runtime true 绝大多数情况下 spring-boot-devtools 只使用于开发环境，在生产环境是需要禁用的，所以Spring Starter为我们生成的项目中spring-boot-devtools通过true配置到了开发环境。 在后续开发，这个项目就具有热部署（开发过程中，Debug As启动项目后根据情况重启）的功能了。 创建一个测试用的Controller类。 package com.example.devtools.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/devtools/\") public class TestController { @RequestMapping(\"/test\") public String hello() { return \"Hello DevTools.\"; } } 以debug方式（在项目上右键，选择Debug As）启动项目。 在hello方法中，修改返回的字符串值，使用浏览器（http://localhost:8080/devtools/test）测试，可以看到在不重新启动的情况下，浏览器能够正确返回hello方法修改后的字符串。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-devtools "},"第11章 单元测试与热部署/11.3homework.html":{"url":"第11章 单元测试与热部署/11.3homework.html","title":"11.3 课后作业","keywords":"","body":"11.3 课后作业 理解单元测试的相关概念，了解JUnit的常用注解和用法。 创建一个连接到数据库的项目，使用单元测试依次测试其DAO，Service和Controller。 了解Spring Boot DevTools的基本原理，尝试在开发项目中使用DevTools支持开发过程中修改后的热部署。 "},"第12章 Spring Boot安全控制/Security.html":{"url":"第12章 Spring Boot安全控制/Security.html","title":"第12章 Spring Boot安全控制","keywords":"","body":"第12章 Spring Boot安全控制 安全控制是企业应用中不可或缺的基础要求，也是隔离于具体业务需求之外而存在的一个中间技术服务。 Spring Security 是 Spring 家族中的一个安全管理框架。实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了很多年了，但是使用的并不多。在很长一段时间内，安全管理这个领域，一直是 Apache Shiro 的天下。 相对于 Shiro，在 SSM/SSH 中整合 Spring Security 是比较麻烦的操作。所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security，所以 Spring Security 才焕发了新的生机，再次流行起来。 在我们的日常工作，最常见的安全管理技术栈的组合是这样的： SSM + Shiro； Spring Boot/Spring Cloud + Spring Security； 本章围绕Spring Security展开介绍Spring Boot中的安全控制。我们首先介绍 Spring Security 的基本概念及其原理，然后介绍Open Web环境下的安全管控机制OAuth 2，最后结合CAS介绍如何实现单点登录功能。 我在上一版的开发平台（JEP 5）中对安全控制框架做技术选型时，最主要的考量就是”够用，易用，大家都在用“，所以选了 Shiro。但是在最新的一版开发平台（iJEP 6）中安全控制框架选择了 Spring Security，而选型原则并没有改变，还是”够用，易用，大家都在用“。 那是因为托了 Spring Boot 的福：大大降低了 Spring Security 的使用门槛。 更多关于Spring Security 的学习材料，请参考这里：https://www.baeldung.com/security-spring "},"第12章 Spring Boot安全控制/12.1securityOverview.html":{"url":"第12章 Spring Boot安全控制/12.1securityOverview.html","title":"12.1 Spring Security介绍","keywords":"","body":"12.1 Spring Security介绍 Spring Security 以“The Acegi Secutity System for Spring” 的名字始于2003年年底。第一个正式版本1.0.0版发布于2006年5月。Acegi在2007年年底，正式成为spring组合项目，被更名为“Spring Security”。 现在，Spring Security成为了一个强大而又活跃的开源社区。 在Spring Security支持论坛上有成千上万的信息。 有一个积极的核心开发团队专职进行开发，一个积极的社区定期共享补丁并支持他们的同伴。 Spring Security是一个功能强大、高度可定制的身份验证和访问控制框架。它是保护基于Spring应用的事实上的标准。当前最新版本为5.2.1.RELEASE版。 Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。与所有Spring项目一样，Spring Security的真正威力在于它可以很容易地扩展来满足定制化需求。 其特性有： 全面和可扩展的身份验证和授权支持； 防止会话固定攻击、点击劫持、伪造跨站点请求等攻击； Servlet API集成； 与Spring Web MVC的可选集成； 更多… 会话固定攻击（session fixation attack）是利用应用系统在服务器的会话ID固定不变机制，借助他人用相同的会话ID获取认证和授权，然后利用该会话ID劫持他人的会话以成功冒充他人，造成会话固定攻击。 下面我们对Spring Security 原理进行简要的分析。 12.1.1 过滤器链 SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明： WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。 SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。 HeaderWriterFilter：用于将头信息加入响应中。 CsrfFilter：用于处理跨站请求伪造。 LogoutFilter：用于处理退出登录。 UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。 DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。 BasicAuthenticationFilter：检测和处理 http basic 认证。 RequestCacheAwareFilter：用来处理请求的缓存。 SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。 AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。 SessionManagementFilter：管理 session 的过滤器 ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。 FilterSecurityInterceptor：可以看做过滤器链的出口。 RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。 12.1.2 流程 先来看下面一个 Spring Security 执行流程图，只要把 SpringSecurity 的执行过程弄明白了，这个框架就会变得很简单： 客户端发起一个请求，进入 Security 过滤器链。 当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。 当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。 当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。 12.1.3 配置 在 WebSecurityConfigurerAdapter 这个类里面可以完成上述流程图的所有配置。 配置类伪代码： @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder()); } @Override public void configure(WebSecurity web) throws Exception { web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\"); } @Override protected void configure(HttpSecurity http) throws Exception { http .formLogin() .loginPage(\"/login_page\") .passwordParameter(\"username\") .passwordParameter(\"password\") .loginProcessingUrl(\"/sign_in\") .permitAll() .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\") .anyRequest().authenticated().accessDecisionManager(accessDecisionManager()) .and().logout().logoutSuccessHandler(new MyLogoutSuccessHandler()) .and().csrf().disable(); http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class); http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler()); http.addFilterAfter(new MyFittler(), LogoutFilter.class); } } 配置简介 configure(AuthenticationManagerBuilder auth) AuthenticationManager 的建造器，配置 AuthenticationManagerBuilder 会让Security 自动构建一个 AuthenticationManager（该类的功能参考流程图）；如果想要使用该功能你需要配置一个 UserDetailService 和 PasswordEncoder。UserDetailsService 用于在认证器中根据用户传过来的用户名查找一个用户， PasswordEncoder 用于密码的加密与比对，我们存储用户密码的时候用PasswordEncoder.encode() 加密存储，在认证器里会调用 PasswordEncoder.matches() 方法进行密码比对。如果重写了该方法，Security 会启用 DaoAuthenticationProvider 这个认证器，该认证就是先调用 UserDetailsService.loadUserByUsername 然后使用 PasswordEncoder.matches() 进行密码比对，如果认证成功成功则返回一个 Authentication 对象。 configure(WebSecurity web) 这个配置方法用于配置静态资源的处理方式，可使用 Ant 匹配规则。 configure(HttpSecurity http) 这个配置方法是最关键的方法，也是最复杂的方法。我们慢慢掰开来说： http .formLogin() .loginPage(\"/login_page\") .passwordParameter(\"username\") .passwordParameter(\"password\") .loginProcessingUrl(\"/sign_in\") .permitAll() 这是配置登录相关的操作从方法名可知，配置了登录页请求路径，密码属性名，用户名属性名，和登录请求路径，permitAll()代表任意用户可访问。 http .authorizeRequests() .antMatchers(\"/test\").hasRole(\"test\") .anyRequest().authenticated() .accessDecisionManager(accessDecisionManager()); 以上配置是权限相关的配置，配置了一个 /test url 该有什么权限才能访问， anyRequest() 表示所有请求，authenticated() 表示已登录用户才能访问， accessDecisionManager() 表示绑定在 url 上的鉴权管理器 为了对比，现在贴出另一个权限配置清单： http.authorizeRequests() .antMatchers(\"/tets_a/**\",\"/test_b/**\").hasRole(\"test\") .antMatchers(\"/a/**\",\"/b/**\").authenticated() .accessDecisionManager(accessDecisionManager()) 我们可以看到权限配置的自由度很高，鉴权管理器可以绑定到任意 url 上；而且可以硬编码各种 url 权限： http .logout() .logoutUrl(\"/logout\") .logoutSuccessHandler(new MyLogoutSuccessHandler()) 登出相关配置，这里配置了登出 url 和登出成功处理器： http .exceptionHandling() .accessDeniedHandler(new MyAccessDeniedHandler()); 上面代码是配置鉴权失败的处理器。 http.addFilterAfter(new MyFittler(), LogoutFilter.class); http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class); 上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore 加在对应的过滤器之前，addFilterAfter 加在对应的过滤器之后，addFilterAt 加在过滤器同一位置，事实上框架原有的 Filter 在启动 HttpSecurity 配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用 addFilterAt 方法插入的 Filter ，会在这个位置上的原有 Filter 之前执行。 关于 HttpSecurity 使用的是链式编程，其中 http.xxxx.and.yyyyy 这种写法和 http.xxxx;http.yyyy 写法意义一样。 自定义 AuthenticationManager 和 AccessDecisionManager 重写 authenticationManagerBean() 方法，并构造一个 authenticationManager： @Override public AuthenticationManager authenticationManagerBean() throws Exception { ProviderManager authenticationManager = new ProviderManager(Arrays.asLis(getMyAuthenticationProvider(),daoAuthenticationProvider())); return authenticationManager; } 我这里给 authenticationManager 配置了两个认证器，执行过程参考流程图。 定义构造AccessDecisionManager的方法并在配置类中调用，配置参考 configure(HttpSecurity http) 说明： public AccessDecisionManager accessDecisionManager(){ List> decisionVoters = Arrays.asList( new MyExpressionVoter(), new WebExpressionVoter(), new RoleVoter(), new AuthenticatedVoter()); return new UnanimousBased(decisionVoters); } 投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。 12.1.4 权限系统 UserDetails Security 中的用户接口，我们自定义用户类要实现该接口。 GrantedAuthority Security 中的用户权限接口，自定义权限需要实现该接口: public class MyGrantedAuthority implements GrantedAuthority { private String authority; } authority 表示权限字段，需要注意的是在 config 中配置的权限会被加上 ROLE_ 前缀，比如我们的配置 authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")，配置了一个 test 权限但我们存储的权限字段（authority）应该是 ROLE_test 。 UserDetailsService Security 中的用户 Service，自定义用户服务类需要实现该接口： @Service public class MyUserDetailService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { return..... } } loadUserByUsername的作用在上文中已经说明，就是根据用户名查询用户对象。 SecurityContextHolder 用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是 SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。 手动填充 SecurityContextHolder 示例： UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(\"test\",\"test\",list); SecurityContextHolder.getContext().setAuthentication(token); 对于使用 token 鉴权的系统，我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。 12.1.5 扩展 Security 可扩展的有： 鉴权失败处理器 验证器 登录成功处理器 投票器 自定义token处理过滤器 登出成功处理器 登录失败处理器 自定义 UsernamePasswordAuthenticationFilter 鉴权失败处理器 Security 鉴权失败默认跳转登录页面，我们可以实现 AccessDeniedHandler 接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。 验证器 实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。 登录成功处理器 在 Security 中验证成功默认跳转到上一次请求页面或者路径为 \"/\" 的页面，我们同样可以自定义：继承 SimpleUrlAuthenticationSuccessHandler 这个类或者实现 AuthenticationSuccessHandler 接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler 是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。 投票器 投票器可继承 WebExpressionVoter 或者实现 AccessDecisionVoter接口；WebExpressionVoter 是 Security 默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 上文； 注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。 自定义token处理过滤器 自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class); 登出成功处理器 实现LogoutSuccessHandler接口，添加到配置的方式参考上文。 登录失败处理器 登录失败默认跳转到登录页，我们同样可以自定义。继承 SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler，建议采用继承。 自定义UsernamePasswordAuthenticationFilter 我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们 Security的灵活性（比如添加验证验证码是否正确的功能）。 我们直接继承 UsernamePasswordAuthenticationFilter ，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求 url 。 这里配置略微复杂，贴一下代码清单 初始化过滤器： MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){ MyUsernamePasswordAuthenticationFilter myUsernamePasswordAuthenticationFilter = new MyUsernamePasswordAuthenticationFilter(redisService); myUsernamePasswordAuthenticationFilter.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler()); myUsernamePasswordAuthenticationFilter.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler()); myUsernamePasswordAuthenticationFilter.setFilterProcessesUrl(\"/sign_in\"); myUsernamePasswordAuthenticationFilter.setAuthenticationManager(getAuthenticationManager()); return myUsernamePasswordAuthenticationFilter; } 添加到配置： http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class); 12.1.6 总结 对于 Security 的扩展配置关键在于 configure(HttpSecurityhttp) 方法；扩展认证方式可以自定义 authenticationManager 并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义 accessDecisionManager 然后添加自己的投票器并绑定到对应的 url（url 匹配方式为 ant）上，投票器 vote(Authenticationauthentication,FilterInvocationfi,Collectionattributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。 对于 token 认证的校验方式，可以暴露一个获取的接口，或者重写 UsernamePasswordAuthenticationFilter 过滤器和扩展登录成功处理器来获取 token，然后在 LogoutFilter 之后添加一个自定义过滤器，用于校验和填充 SecurityContextHolder。 另外，Security 的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回 json ,那么就需要重写各个处理器了。 以上“Spring Security 原理分析”部分内容来自于Spring Security 工作原理概览，感谢CSDN博主“_江南一点雨”。 "},"第12章 Spring Boot安全控制/12.2securityIntegration.html":{"url":"第12章 Spring Boot安全控制/12.2securityIntegration.html","title":"12.2 集成Spring Security","keywords":"","body":"12.2 集成Spring Security 在Spring Boot中集成Spring Security一如既往地使用了启动器依赖，在创建Spring Starter项目时选中“Spring Security”依赖即可。 12.2.1 基本集成 添加“Spring Security”启动器依赖后，即完成了Spring Security，项目的pom文件中的依赖为： org.springframework.boot spring-boot-starter-security 在项目中添加一个控制器HelloController类，测试Spring Security是否正确工作。 package com.example.security.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/security/\") public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"Hello, Security.\"; } } 运行应用后，打开浏览器，访问http://localhost:8080/security/hello，弹出Spring Security提供的默认认证页面，用户名为user，密码是在启动应用时生成的一个随机字符串（STS控制台中的密码信息：Using generated security password: 0585d7e0-dde1-4b9e-8352-27eb72517803）。 默认密码在应用启动时，打印在控制台中，当然每次启动时生成的密码都不一样。 使用user用户名和生成的密码（这里是“0585d7e0-dde1-4b9e-8352-27eb72517803”）登录后，可正确访问HelloController返回的信息。 通过查看Spring Security的源码org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration类，可以看到inMemoryUserDetailsManager方法中使用的SecurityProperties.User user属性提供了用户名和密码。由getOrDeducePassword方法通过日志logger.info(String.format(\"%n%nUsing generated security password: %s%n\", user.getPassword()));将生成的默认密码打印到控制台。 public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties, ObjectProvider passwordEncoder) { SecurityProperties.User user = properties.getUser(); List roles = user.getRoles(); return new InMemoryUserDetailsManager( User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable())) .roles(StringUtils.toStringArray(roles)).build()); } 进一步查看这个User类，可以看到默认登录用户为user，密码为一个uuid字符串。 public static class User { /** * Default user name. */ private String name = \"user\"; /** * Password for the default user name. */ private String password = UUID.randomUUID().toString(); /** * Granted roles for the default user name. */ private List roles = new ArrayList<>(); private boolean passwordGenerated = true; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public String getPassword() { return this.password; } public void setPassword(String password) { if (!StringUtils.hasLength(password)) { return; } this.passwordGenerated = false; this.password = password; } public List getRoles() { return this.roles; } public void setRoles(List roles) { this.roles = new ArrayList<>(roles); } public boolean isPasswordGenerated() { return this.passwordGenerated; } } 如果我们简单的在application.properties文件中指定用户名和密码： spring.security.user.name=kevin spring.security.user.password=6998 spring.security.user.roles=admin 则应用在启动时，就不会生成随机的uuid密码，也不会在控制台中打印Using generated security password: 0585d7e0-dde1-4b9e-8352-27eb72517803这样的信息了。 这个时候，通过浏览器访问http://localhost:8080/security/hello则需要输入kevin用户和6998密码，就可以正常访问后台业务逻辑并返回正确的结果，并且该用户具有admin角色（虽然这个示例中角色没有任何用处）。 12.2.2 密码加密 除了在学习环境下，为了安全起见，密码存储都必须要加密。 Spring Security通过实现PasswordEncoder接口，提供了众多的密码加密类（包括供我们在学习环境下使用的NoOpPasswordEncoder明文密码编码器），供我们在实际工作中根据需要选用。 奇葩的NoOpPasswordEncoder类：encode(CharSequence rawPassword) 方法的返回值为encode(CharSequence rawPassword) ，也就是密码编码返回明文，所以千万不要在生产环境中使用。 修改SecurityConfiguration类，添加BCryptPasswordEncoder密码编码器。 BCryptPasswordEncoder，使用了BCrypt强哈希方法来加密密码。 package com.example.security.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; @Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { PasswordEncoder encoder = new BCryptPasswordEncoder(); return encoder; } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"admin\")).roles(\"ADMIN\", \"USER\") .and() .withUser(\"kevin\").password(new BCryptPasswordEncoder().encode(\"6998\")).roles(\"USER\") .and() .withUser(\"roy\").password(new BCryptPasswordEncoder().encode(\"3525\")).roles(\"USER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\") .hasRole(\"ADMIN\") .antMatchers(\"/user/**\") .hasRole(\"USER\") .anyRequest() .authenticated() .and() .formLogin() .loginProcessingUrl(\"/login\") .permitAll(); } } 上面的示例中PasswordEncoder使用了BCryptPasswordEncoder实现类，并且在基于内存的认证器中给出用户密码时，使用了BCryptPasswordEncoder加密密码（password(new BCryptPasswordEncoder().encode(\"admin\"))）。这样，内存中存储的密码时通过BCrypt加密的密码，用户在登录页面输入密码（例如admin用户的密码admin）后，Spring Security使用PasswordEncoder对密码进行编码后与内存中存储的加密后的密码对比，完成认证，正确后就放行。 12.2.3 基于内存的认证 在本小节的学习过程中，通过将用户、密码和角色配置在内存中，会更方便集中精力学习Spring Security。 注释掉上一小节application.properties文件中指定的用户名、密码和角色。 后续小节我们会通过数据库来完成一个RBAC的安全控制示例。 package com.example.security.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.password.NoOpPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; @Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"admin\").password(\"admin\").roles(\"ADMIN\", \"USER\") .and() .withUser(\"kevin\").password(\"6998\").roles(\"USER\") .and() .withUser(\"roy\").password(\"3525\").roles(\"USER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\") .hasRole(\"ADMIN\") .antMatchers(\"/user/**\") .hasRole(\"USER\") .anyRequest() .authenticated() .and() .formLogin() .loginProcessingUrl(\"/login\") .permitAll(); } } 上述代码，首先注册一个PasswordEncoder（密码加密编码器类），这里为了测试简便，使用了不加密密码。在实际生产环境下绝对不能使用这个密码编码器类。 然后使用AuthenticationManagerBuilder.inMemoryAuthentication的内存认证，通过编码添加了3个用户和对应的角色（\"ADMIN\", \"USER\"）。 最后使用HttpSecurity为不同的资源匹配了不同的角色访问权限。 添加AdminController控制器类，提供“/admin/hello”资源。 package com.example.security.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/admin/\") public class AdminController { @RequestMapping(\"/hello\") public String hello() { return \"admin.hello\"; } } 添加UserController控制器类，提供“/user/hello”资源。 package com.example.security.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/user/\") public class UserController { @RequestMapping(\"/hello\") public String hello() { return \"user.hello\"; } } 启动应用，测试： 使用admin用户登录，可以正确访问“/admin/hello”和“/user/hello”资源。 使用kevin用户登录，可以正确访问“/user/hello”资源，不能正确访问“/admin/hello”资源，错误信息如下： 以上就是一个基于内存认证的最简单的RBAC（基于角色的存取控制）权限控制系统： kevin拥有USER角色； “/user/**”资源授权给USER角色； kevin登录后拥有USER角色，可以访问“/user/hello”资源。 12.2.4 登录表单/注销配置 虽然Spring Security提供了默认的登录表单，但是在实际工作中绝大多数情况都用不上。基本上在所有的项目/产品中，都会使用自定义的登录表单。当然，注销登录（或者叫做登出），也会使用自定义的配置。 通过查看Spring Security源码，可以看到默认登录表单在org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.generateLoginPageHtml方法中构建。 在DefaultLoginPageGeneratingFilter类的doFilter方法中response.getWriter().write(loginPageHtml)代码向浏览器输出登录表单。 public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; boolean loginError = isErrorPage(request); boolean logoutSuccess = isLogoutSuccess(request); if (isLoginUrlRequest(request) || loginError || logoutSuccess) { String loginPageHtml = generateLoginPageHtml(request, loginError, logoutSuccess); response.setContentType(\"text/html;charset=UTF-8\"); response.setContentLength(loginPageHtml.getBytes(StandardCharsets.UTF_8).length); response.getWriter().write(loginPageHtml); return; } chain.doFilter(request, response); } 本小节，我们使用Thymeleaf模板+基于内存认证方式来学习如何自定义登录表单。 首先，我们添加几个简单的页面，然后通过Spring Security基于内存的配置设置其用户、角色、自定义登录表单、注销等操作。 12.2.4.1 首页 创建src/main/resources/templates/index.html页面，作为项目的首页。 示例首页 示例首页 登录成功后，自动跳转到这里 点击 这里 进入User Hello页面。 点击 这里 进入Admin Hello页面。 12.2.4.2 登录页面 创建src/main/resources/templates/login.html页面，作为项目的登录页面。 自定义登录示例 请你登录 用户名或密码错 您已注销成功 用户名 : 密码 : 在登录页面中，特意将用户名input设为login_username，演示匹配后续的自定义登录页面配置信息。 12.2.4.3 管理页面 创建src/main/resources/templates/admin/hello.html，作为项目的管理页面，按照本示例设置，需要ADMIN角色的用户才可以访问。 Admin.Hello Page Admin Page 返回 12.2.4.4 用户页面 创建src/main/resources/templates/user/hello.html，作为项目的用户页面，按照本示例设置，需要USER角色的用户才可以访问。 User.Hello Page User Page 返回 12.2.4.5 其他页面 创建src/main/resources/templates/other/hello.html，作为项目的其他页面，按照本示例设置，任何登录用户（任何角色）都可以访问。 Other.Hello Page Other Page 返回 12.2.4.6 页面Controller 新建一个控制页面跳转的PageController，将上述4个页面串接起来。 package com.example.security.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.servlet.ModelAndView; @Controller public class PagesController { @RequestMapping(\"/index\") public String index() { return \"/index\"; } @RequestMapping(value = \"/login\", method = RequestMethod.GET) public String login() { return \"/login\"; } @RequestMapping(\"/admin/hello\") public ModelAndView adminHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"admin\"); mv.setViewName(\"/admin/hello\"); return mv; } @RequestMapping(\"/user/hello\") public ModelAndView userHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"kevin\"); mv.setViewName(\"/user/hello\"); return mv; } @RequestMapping(\"/other/hello\") public ModelAndView otherHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"other\"); mv.setViewName(\"/other/hello\"); return mv; } } 12.2.4.7 Spring Security配置 在启用了Spring Security的Spring Boot应用中，我们可以通过自定义表单html页面，然后通过HttpSecurity的formLogin和logout自定义登录页面和注销（登出）操作和行为。 package com.example.security.config; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"admin\")).roles(\"ADMIN\", \"USER\") .and() .withUser(\"kevin\").password(new BCryptPasswordEncoder().encode(\"6998\")).roles(\"USER\") .and() .withUser(\"roy\").password(new BCryptPasswordEncoder().encode(\"3525\")).roles(\"OTHER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() .loginPage(\"/login\") .usernameParameter(\"login_username\") .passwordParameter(\"login_password\") .failureUrl(\"/login?error\") .defaultSuccessUrl(\"/index\") .permitAll() .and().logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/login?logout\") .clearAuthentication(true) .invalidateHttpSession(true) .permitAll() .and().authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/user/**\").hasRole(\"USER\") .anyRequest() .authenticated(); } @Override public void configure(WebSecurity web) { web.ignoring().antMatchers(\"/config/**\", \"/css/**\", \"/images/**\", \"/js/**\"); } } formLogin().permitAll()代码指示Spring Security允许任何用户访问formLogin与之关联的URL（/login）； logout().permitAll()代码指示Spring Security允许任何用户访问logout与之关联的URL（/logout）； authorizeRequests().anyRequest().authenticated()代码指示Spring Security允许登录（通过认证的）用户访问所有的页面（比如“other/hello.html”页面）； antMatchers(\"/admin/**\").hasRole(\"ADMIN\")具有ADMIN角色的登录用户才都访问/admin/开头的页面。 12.2.4.8 测试 启动应用程序，打开浏览器，输出http://localhost:8080/地址，自动跳转到登录页面。 输入错误的用户名，会跳转回登录页面，并且显示错误信息：用户名或密码错。 输入正确的用户名和密码，登录后会跳转到首页。 点击User Hello页面的链接，可以正确访问User Hello页面。 返回首页，后点击Admin Hello页面的链接，由于Kevin用户不具有ADMIN角色，所以不可以访问Admin Hello页面。 使用roy用户登录（其用户角色为OTHER），既不能访问admin/hello页面，也不能访问user/hello页面，只能访问other/hello页面。当然，admin和kevin用户登录，都可以访问other/hello页面。 在首页，点击退出（登出，logout）按钮，可以正确注销当前登录。 以上测试，符合项目权限控制预期。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-security 12.2.5 基于数据库的认证 在我们实际的工作中，几乎所有的认证授权，都是基于数据库中存储的用户授权数据来的完成的。 在Spring Security中，通过org.springframework.security.core.userdetails.UserDetailsl和org.springframework.security.core.userdetails.UserDetailsService两个接口完成程序定义（在这两个接口的实现类中访问数据库中的数据）的用户服务，然后通过AuthenticationManagerBuilder.userDetailsService(customUserService())将我们通过数据库存储的用户角色（授权）连接到Spring Security，完成用户认证与授权（Authentication和Authorization）。 @Bean UserDetailsService customUserService() { // 注册UserDetailsService 的bean return new CustomUserDetailsService(); } @Bean PasswordEncoder passwordEncoder() { PasswordEncoder encoder = new BCryptPasswordEncoder(); return encoder; } @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(customUserService()).passwordEncoder(passwordEncoder()); } 本小节，我们使用MySQL数据库，通过MyBatis来学习如何基于数据库来支持Spring Security的用户认证。 创建项目，添加数据库及Spring Security相关的启动器依赖。 项目的pom依赖为： org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.1 org.springframework.boot spring-boot-devtools runtime true mysql mysql-connector-java runtime 项目的application.yml文件中配置数据库连接及MyBatis属性。 # mysql数据源配置 spring: datasource: url: jdbc:mysql://localhost:3306/ssdemo?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver # mybatis 配置信息 mybatis: mapper-locations: classpath:mapping/*Mapper.xml type-aliases-package: com.example.security.db.entity configuration: map-underscore-to-camel-case: true mybatis.configuration.map-underscore-to-camel-case=true是打开字段下划线和java实体类中属性“驼峰命名”之间的映射。例如role_code字段自动映射为roleCode，反之亦然。 12.2.5.1 创建数据库表 基于最简学习案例原则，设计的数据库表（用户、角色和用户角色关联表）只包含最少的字段。 drop table if exists sys_role; drop table if exists sys_user; drop table if exists sys_user_role; /*==============================================================*/ /* Table: sys_role */ /*==============================================================*/ create table sys_role ( role_code varchar(64) not null, role_name varchar(64), primary key (role_code) ); /*==============================================================*/ /* Table: sys_user */ /*==============================================================*/ create table sys_user ( username varchar(64) not null, password varchar(64), primary key (username) ); /*==============================================================*/ /* Table: sys_user_role */ /*==============================================================*/ create table sys_user_role ( id varchar(64) not null, username varchar(64), role_code varchar(64), primary key (id) ); alter table sys_user_role add constraint FK_Reference_1 foreign key (username) references sys_user (username) on delete restrict on update restrict; alter table sys_user_role add constraint FK_Reference_2 foreign key (role_code) references sys_role (role_code) on delete restrict on update restrict; 在3张表中插入一些测试数据。 INSERT INTO `sys_user` VALUES ('admin', 'admin'); INSERT INTO `sys_user` VALUES ('kevin', '6998'); INSERT INTO `sys_user` VALUES ('roy', '3525'); INSERT INTO `sys_role` VALUES ('ROLE_ADMIN', '管理角色'); INSERT INTO `sys_role` VALUES ('ROLE_OTHER', '其他角色'); INSERT INTO `sys_role` VALUES ('ROLE_USER', '用户角色'); INSERT INTO `sys_user_role` VALUES ('1', 'admin', 'ROLE_ADMIN'); INSERT INTO `sys_user_role` VALUES ('2', 'admin', 'ROLE_USER'); INSERT INTO `sys_user_role` VALUES ('3', 'kevin', 'ROLE_USER'); INSERT INTO `sys_user_role` VALUES ('4', 'roy', 'ROLE_OTHER'); 12.2.5.2 创建实体类 根据数据库设计，创建3个实体类，供后续MyBatis输出据库操作用。 创建SysUser实体类（对应sys_user表）。 package com.example.security.db.entity; public class SysUser { private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 创建SysRole实体类（对应sys_role表）。 package com.example.security.db.entity; public class SysRole { private String roleCode; private String roleName; public String getRoleCode() { return roleCode; } public void setRoleCode(String roleCode) { this.roleCode = roleCode; } public String getRoleName() { return roleName; } public void setRoleName(String roleName) { this.roleName = roleName; } } 创建SysUserRole实体类（对应sys_user_role表）。 package com.example.security.db.entity; public class SysUserRole { private String id; private String username; private String roleCode; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getRoleCode() { return roleCode; } public void setRoleCode(String roleCode) { this.roleCode = roleCode; } } 12.2.5.3 创建DAO 最简起见，我们创建SysUser和SysUserRole对应的DAO（mapper）。 SysUser的mapper.xml： select * from sys_user where username = #{username} SysUser的Mapper： package com.example.security.db.mapper; import org.springframework.stereotype.Repository; import com.example.security.db.entity.SysUser; @Repository public interface SysUserMapper { SysUser selectSysUser(String username); } SysUserRole的mapper.xml： select * from sys_user_role where username = #{username} SysUserRole的Mapper： package com.example.security.db.mapper; import java.util.List; import org.springframework.stereotype.Repository; import com.example.security.db.entity.SysUserRole; @Repository public interface SysUserRoleMapper { List selectSysUserRole(String username); } 以上两个mapper，完成用户的用户角色关系这两张表的访问。 12.2.5.4 创建CustomUserService CustomUserService实现org.springframework.security.core.userdetails.UserDetailsService接口，完成用户及用户所拥有的角色信息从数据库中获取的功能。 创建CustomUserService类： package com.example.security.db.service; import java.util.ArrayList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import com.example.security.db.entity.SysUser; import com.example.security.db.entity.SysUserRole; import com.example.security.db.mapper.SysUserMapper; import com.example.security.db.mapper.SysUserRoleMapper; public class CustomUserService implements UserDetailsService { @Autowired SysUserMapper sysUserMapper; @Autowired SysUserRoleMapper sysUserRoleMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { SysUser sysUser = sysUserMapper.selectSysUser(username); String password = sysUser.getPassword(); List sysUserRoles = sysUserRoleMapper.selectSysUserRole(username); List authorities = new ArrayList<>(); for (SysUserRole sysUserRole : sysUserRoles) { authorities.add(new SimpleGrantedAuthority(sysUserRole.getRoleCode())); } return new User(username, password, authorities); } } 12.2.5.5 创建Controller 按照上一小节创建页面访问的控制器PagesController： package com.example.security.db.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.servlet.ModelAndView; @Controller public class PagesController { @RequestMapping(\"/index\") public String index() { return \"/index\"; } @RequestMapping(value = \"/login\", method = RequestMethod.GET) public String login() { return \"/login\"; } @RequestMapping(\"/admin/hello\") public ModelAndView adminHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"admin\"); mv.setViewName(\"/admin/hello\"); return mv; } @RequestMapping(\"/user/hello\") public ModelAndView userHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"kevin\"); mv.setViewName(\"/user/hello\"); return mv; } @RequestMapping(\"/other/hello\") public ModelAndView otherHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"other\"); mv.setViewName(\"/other/hello\"); return mv; } } 12.2.5.6 Thymeleaf页面 复用上一小节（12.2.4）中的Thymeleaf页面。 12.2.5.7 Spring Security配置 创建配置类SecurityConfiguration，其中关键的一句代码（将数据库访问用户信息的CustomUserService类注入）是auth.userDetailsService(customUserService()); package com.example.security.db.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.NoOpPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import com.example.security.db.service.CustomUserService; @Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Bean UserDetailsService customUserService(){ return new CustomUserService(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(customUserService()); } @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() .loginPage(\"/login\") .usernameParameter(\"login_username\") .passwordParameter(\"login_password\") .failureUrl(\"/login?error\") .defaultSuccessUrl(\"/index\") .permitAll() .and().logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/login?logout\") .clearAuthentication(true) .invalidateHttpSession(true) .permitAll() .and().authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/user/**\").hasRole(\"USER\") .anyRequest() .authenticated(); } @Override public void configure(WebSecurity web) { web.ignoring().antMatchers(\"/config/**\", \"/css/**\", \"/images/**\", \"/js/**\"); } } 在学习过程中为了方便往数据库中录入用户密码信息（明文），所以上面的配置中使用了NoOpPasswordEncoder这个奇葩的密码编码器，一如既往地强调：严禁在非学习系统中使用这个（明文的）密码编码器。 Spring Security配置中使用角色默认前缀为“ROLE_”，例如使用角色“ADMIN”，在数据库表中应该存储为“ROLE_ADMIN”。参考org.springframework.security.access.vote.RoleVoter类中的rolePrefix属性。 12.2.5.8 启动类 启动类中别忘了MyBatis的@MapperScan注解。 package com.example.security.db; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\"com.example.security.db.mapper\") public class SpringBootSecurityDbApplication { public static void main(String[] args) { SpringApplication.run(SpringBootSecurityDbApplication.class, args); } } 12.2.5.9 测试 启动项目测试，和上一小节（12.2.4）效果一致。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-security-db "},"第12章 Spring Boot安全控制/12.3securityOauth2.html":{"url":"第12章 Spring Boot安全控制/12.3securityOauth2.html","title":"12.3 OAuth 2","keywords":"","body":"12.3 OAuth 2 OAuth （Open Authorization，开放授权）是一个关于授权的开放网络标准，它为用户资源的授权定义了一个安全、开放及简单的标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而不需要将用户名和密码提供给第三方应用。 OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站在特定的时段内访问特定的资源。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。 目前 OAuth 最新版本是 2.0，在全世界得到了广泛地应用，在国内主流的QQ，微信等第三方授权登录方式都是基于OAuth 2 实现的。 OAuth 2 在“客户端”与“服务提供商”之间，设置了一个授权层（authorization layer）。“客户端”不能直接登录“服务提供商”，只能登录授权层，以此将用户与客户端分离。“客户端”登录需要 OAuth 提供的令牌，否则将提示认证失败而导致客户端无法访问服务。 为了方便理解，可以想象 OAuth2.0 就是在用户资源和第三方应用之间的一个中间层（授权层 authorization layer），它把资源和第三方应用隔开，使得第三方应用无法直接访问资源，从而起到保护资源的作用。 本小节我们学习 Spring Boot 项目中是如何配置使用 OAuth 2 服务器端，并让 OAuth 2 整合 Spring Security 来保护我们的 REST 服务接口。 12.3.1 基本概念 OAuth 2 标准中定义了以下几种角色： 资源所有者（Resource Owner）：代表授权客户端访问本身资源信息的用户（User），如微信用户其具有头像、照片、朋友圈等资源。 资源服务器（Resource Server）：资源服务器托管了受保护的用户账号信息，可以向第三方提供资源，如头像、照片、朋友圈等资源。 授权服务器（Authorization Server）：授权服务器用来验证用户身份然后为客户端派发资源访问令牌。资源服务器接受此令牌并验证您的身份。 客户端（Client）：代表意图访问受限资源的第三方应用。在访问实现之前，它必须先经过用户者授权，并且获得的授权凭证将进一步由授权服务器进行验证。 为了便于理解，现在假设有一个名叫“脸盆网”的社交网站，用户在首次登陆时会要求导入用户在facebook的好友列表，以便于快速建立社交关系。具体的授权流程如下： 用户登陆脸盆网，脸盆网试图访问facebook上的好友列表； 脸盆网发现该资源是facebook的受保护资源，于是返回302将用户重定向至facebook登陆页面； 用户完成认证后，facebook提示用户是否将好友列表资源授权给脸盆网使用（如果本来就是已登陆facebook状态则直接显示是否授权的页面）； 用户确认后，脸盆网通过授权码模式获取了facebook颁发的access_token； 脸盆网携带该token访问facebook的获取用户接口https://api.facebook.com/user,facebook验证token无误后返回了与该token绑定的用户信息； 脸盆网的 Spring Security 安全框架根据返回的用户信息构造出了 principal 对象并保存在session中； 脸盆网再次携带该token访问好友列表，facebook根据该token对应的用户返回该用户的好友列表信息； 该用户后续在脸盆网发起的访问facebook上的资源，只要在token有效期及权限范围内均可以正常获取（比如想访问一下保存在facebook里的相册）。 不难看出，这个假设的场景中，脸盆网就是第三方应用（客户端 Client），而facebook既充当了认证服务器，又充当了资源服务器，资源所有者就是用户（用户持有的资源，就是用户再facebook上的好友列表）。 OAuht 2 解决问题的关键在于使用授权服务器提供一个访问凭据给到第三方应用，让第三方应用可以在不知道资源所有者在资源服务器上的账号和密码的情况下，能获取到资源所有者在资源服务器上的受保护资源（这里的受保护资源就是用户在facebook上的好友列表）。 客户端向用户（资源所有者）请求其授权； 用户单击客户端所呈现的服务授权页面上的同意授权按钮后，客户端收到用户的授权许可，这个授权许可是一个代表资源所有者授权的凭据； 客户端向授权服务器请求访问令牌，并出示授权许可； 授权服务器对客户端身份进行认证，并校验授权许可，如果都是有效的，则发放访问令牌； 客户端向资源服务器请求受保护的资源，并出示访问令牌； 资源服务器校验访问令牌，如果令牌有效，则提供服务。 OAuth 2.0 提供了4种授权模式： 授权码 Authorization Code：是最常使用的一种授权许可类型，它适用于第三方应用类型为server-side型应用的场景。Authorization Code授权流程基于重定向跳转，客户端必须能够与User-agent（即用户的 Web 浏览器）交互并接收通过User-agent路由发送的实际authorization code值。适合普通服务器端应用使用； 简化（隐式）许可 Implicit：和Authorization Code基于重定向跳转的授权流程十分相似，但它适用于移动应用和 Web App，这些应用与普通服务器端应用相比有个特点，即client secret不能有效保存和信任； 资源所有者密码凭证 Resource Owner Password Credentials：适用于用户与客户端具有信任关系的情况，例如设备操作系统或同一组织的内部及外部应用。用户与应用交互表现形式往往体现为客户端能够直接获取用户凭据（用户名和密码，通常使用交互表单）； 客户端凭证 Client Credentials：是最简单的一种授权流程。客户端可以直接使用它的client credentials或其他有效认证信息向授权服务器发起获取access token的请求。 上面这4种授权模式，各有各的适用场景，我们在实际项目种需要根据项目类型选择使用。 授权码模式：第三方Web服务器端应用与第三方原生App； 简化模式：第三方单页面应用； 密码模式：第一方单页应用与第一方原生App； 客户端模式：没有用户参与的，完全信任的服务器端服务。 12.3.2 集成示例 Spring Boot 对 OAuth 2.0 提供了良好的集成，官方文档提供了简要的说明，官方示例提供了详细的指导。 12.3.2.1 官方示例 下面我们以官方示例来介绍如何在 Spring Boot 中使用 OAuth 2。 到https://github.com/spring-guides/tut-spring-boot-oauth2 clone 版本库到本地。 git clone https://github.com/spring-guides/tut-spring-boot-oauth2.git 这些示例在后端使用 Spring Boot 和 Spring Security 的单页应用程序，在前端使用 jQuery 和 bootstrap。 所有示例都是使用 Spring Boot 中的原生 OAuth 2.0 支持来实现的。 官方示例版本库里面包含的5个示例，后一个示例都比前一个示例添加了新功能。 simple：一个非常基本的静态应用程序，只有一个主页，通过 Spring Boot 的 OAuth 2.0 配置属性无条件登录（如果您访问主页，您将被自动重定向到GitHub）。 click：添加用户必须单击才能登录的显式链接。 logout：为经过身份验证的用户添加注销链接。 two-providers：添加第二个登录提供程序，以便用户可以在主页上选择要使用哪一个。 custom-error：为未经身份验证的用户添加错误消息，并基于 GitHub 的 API 添加自定义身份验证。 12.3.2.1.1 simple 示例项目 我们先用 simple 项目来讲解如何在 Spring Boot 应用来介绍如何将 github 作为一个认证服务器，完成单点登录（Single Sign On），然后再介绍 logout 示例项目。 在 github 上注册一个新的 OAuth 应用。 打开https://github.com/settings/developers，注册一个新的应用： 在 OAuth 新应用注册页面，填写对应的信息，需要注意两个地方： 主页URL：http://localhost:8080 认证回调URL：http://localhost:8080/login/oauth2/code/github 其他信息按照需要填写。 填写完成后，单击“Register application”按钮，完成注册后，github 生成两个ID：Client ID 和 Client Secret，保存这两个ID值，供后续在 Spring Boot 中配置 OAuth 认证用。 打开 simple 应用的 application.yml 配置文件，使用上面生成的两个 ID 值填充 client-id 和 client-secret 两个属性。 spring: security: oauth2: client: registration: github: client-id: your-github-client-id client-secret: your-github-client-secret 启动应用，打开浏览器，输入http://localhost:8080/，如果你没有登录过 github 则会跳转到 github 的登录页。 如果你本机浏览器登录过 github 则直接授权当前 github 用户（下图中的用户就是 gyzhang）登录应用。 完成授权后，返回系统的首页。 主页 index.html 文件中引用了 jquery 和 bootstrap 脚本和样式。 Demo Demo 前端页面能够引用这些 js 和 css 是因为项目pom文件中的如下依赖： org.webjars jquery 2.1.1 org.webjars bootstrap 3.2.0 org.webjars webjars-locator-core 项目中几乎没有自己写的代码，是因为使用了spring-boot-starter-oauth2-client这个启动器依赖。 org.springframework.boot spring-boot-starter-oauth2-client 这里，使用 Spring Boot 使用的是“授权码”认证方式。 +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- & Redirection URI ---->| | | User- | | Authorization | | Agent -+----(B)-- User authenticates --->| Server | | | | | | -+----(C)-- Authorization Code ------(D)-- Authorization Code ---------' | | Client | & Redirection URI | | | | | |上面 simple 示例（运行中，如截图所示）中的4个 OAuth 2.0 角色如下： 资源所有者（Resource Owner）：github 用户 gyzhang； 资源服务器（Resource Server）：github； 授权服务器（Authorization Server）：github； 客户端（Client）：simple 项目。 虽然在 simple 项目中，并没有在页面上引用 github 的资源，但是下面的logout 项目会演示如何引用资源服务器上的用户资源。 12.3.2.1.2 logout 示例项目 在 simple 的基础上，进一步增加了登录和注销链接和用户全名等信息的 logout 项目，更加清晰的描述了如何使用资源服务器的资源。 在 SocialApplication 启动类上添加 @RestController 注解，并提供 user 方法，向页面返回登录 github 用户的全名。 @SpringBootApplication @RestController public class SocialApplication extends WebSecurityConfigurerAdapter { @RequestMapping(\"/user\") public Map user(@AuthenticationPrincipal OAuth2User principal) { return Collections.singletonMap(\"name\", principal.getAttribute(\"name\")); } @Override protected void configure(HttpSecurity http) throws Exception { // @formatter:off http .authorizeRequests(a -> a .antMatchers(\"/\", \"/error\", \"/webjars/**\").permitAll() .anyRequest().authenticated() ) .exceptionHandling(e -> e .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)) ) .csrf(c -> c .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) ) .logout(l -> l .logoutSuccessUrl(\"/\").permitAll() ) .oauth2Login(); // @formatter:on } public static void main(String[] args) { SpringApplication.run(SocialApplication.class, args); } } 当然，上述方法中OAuth2User principal参数封装了用户（github 用户 gyzhang）在 github 上的资源，比如说用户的全名“Kevin Zhang”和自我介绍“喜欢凑热闹的高龄程序猿，攻城狮。”等信息，可供第三方应用客户端取用。下图是用 github 用户 gyzhang 登录后的信息： 启动类上的 configure 方法，提供了 Spring Security 相关配置。 页面 index.html 中添加了登录和注销的，并在登录后显示用户名称（Kevin Zhang，这就是资源服务器提供的用户资源）。 Demo Login With GitHub: click here Logged in as: Logout $ .ajaxSetup({ beforeSend : function(xhr, settings) { if (settings.type == 'POST' || settings.type == 'PUT' || settings.type == 'DELETE') { if (!(/^http:.*/.test(settings.url) || /^https:.*/ .test(settings.url))) { // Only send the token to relative URLs i.e. locally. xhr.setRequestHeader(\"X-XSRF-TOKEN\", Cookies.get('XSRF-TOKEN')); } } } }); $.get(\"/user\", function(data) { $(\"#user\").html(data.name); $(\".unauthenticated\").hide(); $(\".authenticated\").show(); }); var logout = function() { $.post(\"/logout\", function() { $(\"#user\").html(''); $(\".unauthenticated\").show(); $(\".authenticated\").hide(); }) return true; } 运行应用，访问http://localhost:8080/，效果如下： 单击“click here”链接，通过 github 认证返回后的页面上使用用户的资源，显示用户名称（Kevin Zhang）。 本小节示例项目代码： https://github.com/spring-guides/tut-spring-boot-oauth2 12.3.2.2 用户名密码认证 在这一小节，我们学习如何自己搭建“授权服务器”来以“资源所有者密码凭证 Resource Owner Password Credentials”方式完成 OAuth 2 的认证，并访问收权限管理的资源。 Spring Security OAuth 2 主要包含认证服务器（@EnableAuthorizationServer）和资源服务器（ @EnableResourceServer）这两大块的实现： 认证服务器主要包含了四种授权模式的实现和 Token 的生成与存储，我们也可以在认证服务器中自定义获取 Token 的方式；资源服务器主要是在 Spring Security 的过滤器链上加了 OAuth2AuthenticationProcessingFilter 过滤器，即使用 OAuth 2 协议发放令牌认证的方式来保护我们的资源。 创建一个新的 Spring Boot 应用。 选择 Spring Security + Spring Web + Thymeleaf 启动器依赖。 在项目的pom文件中，手工添加spring-security-oauth2-autoconfigure依赖。 org.springframework.security.oauth.boot spring-security-oauth2-autoconfigure 2.2.4.RELEASE 为了更好地了解 OAuth 2 的配置过程，我们先将项目配置为一个带授权功能的可以运行的应用，然后再一步一步地添加 OAuth 2 相关功能。 12.3.2.2.1 配置 Spring Security 功能 参照“12.2.4 登录表单/注销配置”小节，创建可访问的页面文件login.html、index.html和hello.html文件。 为登录页面提供 LoginController 控制器： @Controller public class LoginController { @RequestMapping(value = \"/login\", method = RequestMethod.POST) public String login() { return \"login\"; } } 为页面导航提供 PagesController 控制器： @Controller public class PagesController { @RequestMapping(\"/index\") public ModelAndView index(Authentication authentication) { ModelAndView mv = new ModelAndView(); mv.addObject(\"authInfo\", authentication); mv.setViewName(\"/index\"); return mv; } @RequestMapping(value = \"/login\", method = RequestMethod.GET) public String login() { return \"/login\"; } @RequestMapping(\"/admin/hello\") public ModelAndView adminHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"admin\"); mv.setViewName(\"/admin/hello\"); return mv; } @RequestMapping(\"/user/hello\") public ModelAndView userHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"kevin\"); mv.setViewName(\"/user/hello\"); return mv; } @RequestMapping(\"/other/hello\") public ModelAndView otherHello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"other\"); mv.setViewName(\"/other/hello\"); return mv; } } 创建登录用户实体类： public class SysUser implements Serializable { private static final long serialVersionUID = -7518056168386655741L; private String username; private String password; private boolean accountNonExpired = true; private boolean accountNonLocked= true; private boolean credentialsNonExpired= true; private boolean enabled= true; ...getter & setter 创建用户服务类UserDetailService，实现动态获取用户。 这里的逻辑是，可以输入任何用户名，密码都是 123456 在实际工作中，通过这个类中去数据库表中获取用户及权限，并对用户做更多的控制（或修饰）。 需要注意的是，这个的角色 ROLE 要记得添加前缀，例如 ROLE_ADMIN 后面就用做 ADMIN 角色。 @Service public class UserDetailService implements UserDetailsService { @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { SysUser user = new SysUser(); user.setUsername(username); user.setPassword(this.passwordEncoder.encode(\"123456\")); return new User(username, user.getPassword(), user.isEnabled(), user.isAccountNonExpired(), user.isCredentialsNonExpired(), user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList(\"ROLE_ADMIN,ROLE_USER,ROLE_OTHER\")); } } 创建 WebSecurityConfig 类配置 @Configuration @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Autowired PasswordEncoder passwordEncoder; @Autowired private UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable() .formLogin() .loginPage(\"/login\") .failureUrl(\"/login?error\") .defaultSuccessUrl(\"/index\") .permitAll() .and().logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/login?logout\") .clearAuthentication(true) .invalidateHttpSession(true) .permitAll() .and().authorizeRequests() .antMatchers(\"/oauth/**\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/other/**\").hasRole(\"OTHER\") .anyRequest() .authenticated(); } } 运行项目，应该和“12.2.4 登录表单/注销配置”小节效果基本一致。 12.3.2.2.2 配置授权服务器 创建 AuthorizationServerConfig 授权服务器配置类。 @Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired private AuthenticationManager authenticationManager; @Autowired private UserDetailService userDetailService; @Autowired private PasswordEncoder passwordEncoder; @Autowired TokenStore tokenStore; // 使用 jwt @Bean public TokenStore tokenStore() { return new JwtTokenStore(jwtTokenEnhancer()); } // 配置 jwt 生成 策略 @Bean public JwtAccessTokenConverter jwtTokenEnhancer() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(\"123456\"); // 密钥 return converter; } // 配置客户端信息 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory().withClient(\"client_123456\")// 这里直接把配置信息保存在内存中 .secret(passwordEncoder.encode(\"secret_123456\"))// 这里必须使用加密 .authorizedGrantTypes(\"authorization_code\", \"refresh_token\", \"password\", \"implicit\").scopes(\"all\"); } // 配置 Token 的节点 和 Token 服务 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(tokenStore()).authenticationManager(authenticationManager) .userDetailsService(userDetailService).accessTokenConverter(jwtTokenEnhancer()); } // 配置 Token 节点的安全策略 @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security .tokenKeyAccess(\"permitAll()\") .checkTokenAccess(\"isAuthenticated()\") .allowFormAuthenticationForClients(); } } 在public void configure(ClientDetailsServiceConfigurer clients) throws Exception方法中配置 Client ID 和 Secret ID，使得客户端可以与授权服务器正常通讯； 在public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception方法中配置用户认证并产生 token，完成用户身份认证； 在public void configure(AuthorizationServerSecurityConfigurer security) throws Exception方法中，配置认证服务器的安全策略。 完成这一步，就可以向认证服务器请求 token 了，比如，在 Postman 中以 Post 方式发起对http://localhost:8080/oauth/token?username=kevin&password=123456&grant_type=password&client_id=client_123456&client_secret=secret_123456的请求，可以获取到 token 令牌。 12.3.2.2.3 创建资源服务器 创建 ResourceServerConfig 资源服务器配置类。 @Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override public void configure(HttpSecurity http) throws Exception { http.csrf().disable() .formLogin() .loginPage(\"/login\") .failureUrl(\"/login?error\") .defaultSuccessUrl(\"/index\") .permitAll() .and().logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/login?logout\") .clearAuthentication(true) .invalidateHttpSession(true) .permitAll() .and().authorizeRequests() .antMatchers(\"/oauth/**\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/other/**\").hasRole(\"OTHER\") .anyRequest() .authenticated(); } } 在资源服务器中的 http 安全配置，默认情况下会被 WebSecurityConfigurerAdapter 的配置覆盖。 12.3.2.2.4 测试验证 启动项目，打开 Postman，在其中输入如下 url，以Post方式提交 http://localhost:8080/oauth/token?username=kevin&password=123456&grant_type=password&client_id=client_123456&client_secret=secret_123456 可以正确地看到授权服务器返回的 token，如下图： 使用 Post 或 Get 方式访问 http://localhost:8080/admin/hello 地址，注意为该请求携带上一步获取到的“access_token”，认证类型需要正确选定。 发送请求后，可以看到服务器端正确返回受 ADMIN 角色限制的 Admin Page 页面。 我们访问 index 首页，可以看到其输出的认证方式为 OAuth2Authentication，并且拥有 ROLE_ADMIN, ROLE_USER, ROLE_OTHER 这三种角色。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-oauth2 12.3.2.3 资源服务器分离 在很多情况下，我们是将认证服务器和资源服务器分离开部署的。 这个示例里面，我们将把上个项目拆分成两个新的应用： spring-boot-oauth2-auth：认证服务器， spring-boot-oauth2-res：资源服务器。 12.3.2.3.1 认证服务器 在认证服务器 spring-boot-oauth2-auth 项目 application.properties 中配置 “server.port=8000” 服务器端口。 删除多余的类及页面文件，只保留如下五个类： SysUser：存放用户名密码等信息； UserDetailService：获取用户信息； WebSecurityConfig：Spring Security配置类； AuthorizationServerConfig：认证服务器配置； SpringBootOauth2AuthApplication：Spring Boot 应用启动类。 12.3.2.3.2 资源服务器 在资源服务器 spring-boot-oauth2-res 项目中删除认证服务相关文件，保留资源服务相关文件： 保留如下三个类： ResourceServerConfig：资源服务器配置； PagesController：页面控制器； SpringBootOauth2ResApplication：Spring Boot 应用启动类。 资源服务器和认证服务器是分离开的，所以，资源服务器会使用获取到的 token 到认证服务器上校验 token 是否正确，代码如下： @Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Bean public RemoteTokenServices tokenServices() { final RemoteTokenServices tokenService = new RemoteTokenServices(); tokenService.setCheckTokenEndpointUrl(\"http://localhost:8000/oauth/check_token\"); tokenService.setClientId(\"client_123456\"); tokenService.setClientSecret(\"secret_123456\"); return tokenService; } @Override public void configure(HttpSecurity http) throws Exception { http.csrf().disable() .formLogin() .loginPage(\"/login\") .failureUrl(\"/login?error\") .defaultSuccessUrl(\"/index\") .permitAll() .and().logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/login?logout\") .clearAuthentication(true) .invalidateHttpSession(true) .permitAll() .and().authorizeRequests() .antMatchers(\"/oauth/**\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/other/**\").hasRole(\"OTHER\") .anyRequest() .authenticated(); } } 方法 public RemoteTokenServices tokenServices() 中设定了 RemoteTokenServices 需要持有 ClientId 和 ClientSecret 去http://localhost:8000/oauth/check_token 认证服务器上校验 token 是否合法。 其他内容和前面的示例保持不变。 12.3.2.3.3 测试验证 启动认证服务器和资源服务器，认证服务器在 8000 端口提供服务，资源服务器在 8080 端口提供服务。 我们先去认证服务器上获取 token，在 Postman 中以 Post 方式访问 http://localhost:8000/oauth/token?username=kevin&password=123456&grant_type=password&client_id=client_123456&client_secret=secret_123456 这个地址。 可以看到认证服务器正确完成了认证，并返回 token 等信息，复制获得的“access_token”令牌。 使用在认证服务器上获取的 token 访问资源服务器上的 http://localhost:8080/index 这个网址，可以正常访问。 也能正常访问 http://localhost:8080/admin/hello ADMIN 角色的页面资源。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-oauth2-auth https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-oauth2-res 12.3.2.4 授权码认证 如前面介绍的，授权码模式是最安全的一种模式。 用户访问客户端，后者将前者导向认证服务器，认证服务器返回认证页面（账号密码或者其他认证方式） 用户选择是否给予客户端授权。 假设用户给予授权，认证服务器将用户导向客户端事先指定的\"重定向URI\"（redirection URI），同时附上一个授权码。 客户端收到授权码，附上早先的\"重定向URI\"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 下面，我们对上小节的认证服务器进行改造，来学习授权码认证模式。 12.3.2.4.1 访问百度 对授权服务器配置类 AuthorizationServerConfig 进行修改，在 public void configure(ClientDetailsServiceConfigurer clients) throws Exception 方法中添加重定向 url 到百度。 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory().withClient(\"client_123456\")// 这里直接把配置信息保存在内存中 .secret(passwordEncoder.encode(\"secret_123456\"))// 这里必须使用加密 .authorizedGrantTypes(\"authorization_code\", \"refresh_token\", \"password\", \"implicit\").scopes(\"all\") .redirectUris(\"http://www.baidu.com\") .accessTokenValiditySeconds(30*60) .refreshTokenValiditySeconds(60*60); } 然后运行授权服务器项目。 打开浏览器，访问 http://localhost:8000/oauth/authorize?client_id=client_123456&response_type=code&scope=all&redirect_uri=http://www.baidu.com 这个地址，输入任何用户名，密码固定为“123456”，登录。 授权服务器完成认证后，在授权页面，点击“授权”按钮。 然后，就正确跳转到跳转到百度。 我们可以看到地址栏的 url 地址 https://www.baidu.com/?code=7wH47G 携带了 code=7wH47G 这样一个 code 字符串。 可以通过 Postman 使用 http://localhost:8000/oauth/token?client_id=client_123456&client_secret=secret_123456&grant_type=authorization_code&redirect_uri=http://www.baidu.com&code=7wH47G 地址，以 Post 方式获取 Token 令牌。 12.3.2.4.2 访问资源服务器 对授权服务器配置类 AuthorizationServerConfig 进行修改，在 public void configure(ClientDetailsServiceConfigurer clients) throws Exception 方法中添加重定向资源服务器上的 “http://localhost:8080/callback” 这个 url 地址。 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory().withClient(\"client_123456\")// 这里直接把配置信息保存在内存中 .secret(passwordEncoder.encode(\"secret_123456\"))// 这里必须使用加密 .authorizedGrantTypes(\"authorization_code\", \"refresh_token\", \"password\", \"implicit\").scopes(\"all\") .redirectUris(\"http://localhost:8080/callback\") .accessTokenValiditySeconds(30*60) .refreshTokenValiditySeconds(60*60); } 对资源服务器配置类 ResourceServerConfig 进行修改，在 public void configure(HttpSecurity http) throws Exception 方法中添加无权限访问 “/callback” 地址。 @Override public void configure(HttpSecurity http) throws Exception { http.csrf().disable() .authorizeRequests() .antMatchers(\"/callback\").permitAll() //允许无权限访问 callback .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/other/**\").hasRole(\"OTHER\") .anyRequest() .authenticated(); } 新添加 CallbackController 控制器，对 “/callback” 提供处理逻辑：使用 code 去授权服务器上获取 “access_token” 并转到 index 首页。 // 用code到授权服务器获取access_token，然后访问index主页 @RequestMapping(value = \"/callback\", method = RequestMethod.GET) public ResponseEntity callback(@RequestParam(\"code\") String code) throws JsonProcessingException, IOException { ResponseEntity response = null; System.out.println(\"Authorization Code: \" + code); RestTemplate restTemplate = new RestTemplate(); String access_token_url = \"http://localhost:8000/oauth/token\"; access_token_url += \"?client_id=client_123456&code=\" + code; access_token_url += \"&client_secret=secret_123456\"; access_token_url += \"&grant_type=authorization_code\"; access_token_url += \"&redirect_uri=http://localhost:8080/callback\"; System.out.println(\"access_token_url: \" + access_token_url); response = restTemplate.exchange(access_token_url, HttpMethod.POST, null, String.class); ObjectMapper mapper = new ObjectMapper(); JsonNode node = mapper.readTree(response.getBody()); String token = node.path(\"access_token\").asText(); System.out.println(\"access_token: \" + token); String url = \"http://localhost:8080/index\"; HttpHeaders headers = new HttpHeaders(); headers.add(\"Authorization\", \"Bearer \" + token); HttpEntity entity = new HttpEntity<>(headers); ResponseEntity result = restTemplate.exchange(url, HttpMethod.GET, entity, String.class); return result; } 启动授权服务器和资源服务器，通过浏览器访问 http://localhost:8000/oauth/authorize?client_id=client_123456&response_type=code&scope=all&redirect_uri=http://localhost:8080/callback 在授权服务器上登录完成授权。 授权服务器完成授权后重定向到 http://localhost:8080/callback?code=RxLewi，后台 CallbackController 拿到 “RxLewi” 这个 code 到授权服务器上请求 access_token 令牌，然后 get 资源服务器的 index 首页。 效果如下： 当然，callback 这段代码，在实际项目中一般会做成公用的过滤器。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-oauth2-auth https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-oauth2-res "},"第12章 Spring Boot安全控制/12.4homework.html":{"url":"第12章 Spring Boot安全控制/12.4homework.html","title":"12.4 课后作业","keywords":"","body":"12.4 课后作业 了解 Spring Security 的相关概念和基本原理。 练习使用 MyBatis + Spring Security + Tymeleaf 完成认证和授权。 练习使用 Spring Security + Tymeleaf 的 OAuth 2 的“验证码方式”认证授权，要求“授权服务器”和“资源服务器”是分离的，也就是说是两个项目。 "},"第13章 Spring Boot应用监控/Monitor.html":{"url":"第13章 Spring Boot应用监控/Monitor.html","title":"第13章 Spring Boot应用监控","keywords":"","body":"第13章 Spring Boot应用监控 当我们开发的应用程序上线运行后，开发者（或运维人员）需要对其运行情况进行实时监控，在项目出错（或即将出错）时能够自动报警，提醒运维（开发）人员进行处理，以保证业务运行的连续性。 Spring Boot通过Actuator（执行器）组件来帮助开发者获取应用运行时的实时数据。这样，我们就可以通过HTTP端点（Endpoints）或JMX来监控应用程序的状态，例如应用程序的健康情况、应用运行过程中需要输出的业务信息（一般而言，这个级别的监控都是自定义端点）、内存使用情况等。 百度的奇葩翻译，倒是歪打正着，弹簧靴执行器，蛮有“从光脚到穿靴，弹性应变”的意味，也算是另样的“信达雅”境界了吧。 在本章中，我们首先通过使用Spring Boot提供的内置端点来熟悉Actuator的监控机制，然后遵循Spring Boot规范添加自定义端点，最后学习如何保护这些监控端点 。 "},"第13章 Spring Boot应用监控/13.1monitorOverview.html":{"url":"第13章 Spring Boot应用监控/13.1monitorOverview.html","title":"13.1 应用监控介绍","keywords":"","body":"13.1 应用监控介绍 Spring Boot包含了许多附加功能，可以帮助你在将应用程序部署到生产环境时监视和管理它。你可以选择使用HTTP端点或与JMX一起管理和监视应用程序。你可以在你的应用程序中收集审计数据、运行状况和度量（如，性能）数据。SpringBoot自带的监控功能Actuator（执行器）组件，就可以帮助开发人员实现对程序内部运行情况的监控，比如监控服务器状况、Bean加载情况、环境变量、日志信息、线程信息等。 执行器是一个制造业术语，指的是用于移动或控制东西的一个机械装置，一个很小的改变就能让执行器产生大量的运动。 13.1.1 启用Actuator Spring Boot Actuator模块为应用在生产场景（Production-ready）的监控内置提供了大量的便捷服务。 启动SpringBoot的Actuator模块，最简单的方式就是添加spring-boot-starter-actuator启动器（spring boot starter）。 org.springframework.boot spring-boot-starter-actuator 13.1.2 端点 执行器端点（endpoints）可用于监控应用及与应用进行交互，Spring Boot包含很多内置的端点，你也可以添加自己的。例如，health端点提供了应用的基本健康信息。 每个端点都可以启用或禁用。你可以通过配置文件（application.properties或application.yml）控制是否启用每一个内置的端点。然后，通过JMX或HTTP远程访问这些启用并暴露的端点。端点的ID映射到一个带/actuator前缀的URL。例如，health端点默认映射到/actuator/health。 在Spring Boot 2.2中，默认HTTP上打开的端点只有health和info，其他端点默认关闭。 id 描述 auditevents 显示当前应用程序的审计事件信息，需要配置有AuditEventRepository Bean beans 显示应用中Spring Beans的完整列表 caches 显示可用缓存信息 conditions 显示自动装配类的状态及及应用信息 configprops 显示所有 @ConfigurationProperties 列表 env 显示 ConfigurableEnvironment 中的属性 flyway 显示 Flyway 数据库迁移信息 health 显示应用的健康信息（未认证只显示status，认证显示全部信息详情） httptrace 显示HTTP跟踪信息（默认显示最后100个HTTP请求 - 响应交换） info 显示任意的应用信息 integrationgraph 显示Spring Integration graph， 需要依赖 spring-integration-core。 loggers 显示或修改应用程序内的日志配置。 liquibase 展示Liquibase 数据库迁移 metrics 展示当前应用的 metrics 信息 mappings 显示所有 @RequestMapping 路径集列表 scheduledtasks 显示应用程序中的计划任务 sessions 允许从Spring会话支持的会话存储中检索和删除用户会话。 shutdown 允许应用以优雅的方式关闭（默认情况下不启用） threaddump 执行一个线程dump 如果你的应用是一个web应用（Spring MVC，Spring WebFlux或者Jersey），你还能使用如下的这几个额外的监控端点： ID Description heapdump 返回一个hprof堆dump文件。Returns an hprof heap dump file. jolokia 通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用）。需要依赖 jolokia-core。 logfile 返回日志文件内容（如果设置了logging.file.name or logging.file.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息。 prometheus 以可以被Prometheus服务器抓取的格式显示度量（metrics）信息。需要依赖 micrometer-registry-prometheus。 13.1.3 启用端口 默认情况下，除shutdown以外的所有端点均已启用。要配置单个端点的启用，请使用management.endpoint..enabled属性。以下示例启用shutdown端点： management.endpoint.shutdown.enabled=true 另外可以通过management.endpoints.enabled-by-default来修改全局端点默认配置，以下示例启用info端点并禁用所有其他端点： management.endpoints.enabled-by-default=false management.endpoint.info.enabled=true 需要注意的是，禁用的端点将从应用程序上下文中完全删除。如果您只想更改端点暴露情况，请改为使用include和exclude属性。 include属性列出了公开的端点的ID，exclude属性列出了不应该公开的端点的ID； exclude属性优先于include属性。包含和排除属性都可以使用端点ID列表进行配置。 management.endpoints.web.exposure.include=* management.endpoints.web.exposure.exclude=env,beans 由于端点可能包含敏感信息，因此应仔细考虑如何暴露它们。 Spring Boot默认暴露端点情况如下表所示： ID JMX Web auditevents Yes No beans Yes No caches Yes No conditions Yes No configprops Yes No env Yes No flyway Yes No health Yes Yes heapdump N/A No httptrace Yes No info Yes Yes integrationgraph Yes No jolokia N/A No logfile N/A No loggers Yes No liquibase Yes No metrics Yes No mappings Yes No prometheus N/A No scheduledtasks Yes No sessions Yes No shutdown Yes No threaddump Yes No 以下为在学习过程中的配置：启用了shutdown端点，暴露除了info之外的所有端口： management: endpoint: shutdown: enabled: true endpoints: web: exposure: include: \"*\" exclude: - info 13.1.4 保护端点 我们应该时刻注意保护HTTP端点，其保护方式与使用其他任何敏感网址的方式相同。如果存在Spring Security，则默认使用Spring Security的内容协商策略（content-negotiation strategy）保护端点。例如，如果你希望为HTTP端点配置自定义的安全性，比方说只允许具有特定角色的用户访问它们，Spring Boot提供了一些方便的RequestMatcher对象，可以与Spring Security结合使用。 一个典型的Spring Security配置可能看起来像下面的例子： @Configuration(proxyBeanMethods = false) public class ActuatorSecurity extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) -> requests.anyRequest().hasRole(\"ENDPOINT_ADMIN\")); http.httpBasic(); } } 上例使用EndpointRequest.toAnyEndpoint()将请求与所有端点进行匹配，然后确保所有端点都具有ENDPOINT_ADMIN角色。 当然，如果我们的应用程序部署在防火墙后面，可能更喜欢所有的执行器端点都可以在无需验证的情况下进行访问。但是也要注意的是，内网有时候也不是很安全，应用程序可能会遇到有意或无意的危险操作。 我们可以通过更改management.endpoints.web.exposure.include属性来完成此操作。 management.endpoints.web.exposure.include=* 此外，如果存在Spring Security，则需要添加自定义安全配置，以允许对端点进行未经身份验证的访问，如以下示例所示： @Configuration(proxyBeanMethods = false) public class ActuatorSecurity extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) -> requests.anyRequest().permitAll()); } } "},"第13章 Spring Boot应用监控/13.2monitorUse.html":{"url":"第13章 Spring Boot应用监控/13.2monitorUse.html","title":"13.2 使用应用监控","keywords":"","body":"13.2 使用应用监控 Spring Boot应用在启用Actuator后，提供了非常原始的监控信息（json数据），当然我们也可以使用Spring Boot Admin来以一种直观的方式监控Spring Boot应用中的各种信息。 13.2.1 使用Actuator 创建新的Spring Boot应用，引入需要的启动器依赖，特别是spring-boot-starter-actuator。 在配置文件application.yml中，添加数据库连接及MyBatis配置信息。 # mysql数据源配置 spring: datasource: url: jdbc:mysql://localhost:3306/ssdemo?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver # mybatis 配置信息 mybatis: mapper-locations: classpath:mapping/*Mapper.xml type-aliases-package: com.example.actuator.entity configuration: map-underscore-to-camel-case: true Spring Starter项目向导生成的项目pom依赖配置信息如下，最主要的启动器依赖是spring-boot-starter-actuator依赖配置项。 org.springframework.boot spring-boot-starter-actuator org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.1 org.springframework.boot spring-boot-devtools runtime true mysql mysql-connector-java runtime 根据监控需要，在application.yml配置文件中打开除了info之外的所有（为了方便学习）监控端点。 # Actuator 端口配置 management: endpoint: shutdown: enabled: true endpoints: web: exposure: include: \"*\" exclude: - info 启动应用后，访问http://localhost:8080/actuator/，查看监控端点信息。 在浏览器中进一步访问http://localhost:8080/actuator/beans端点，可以查看应用中注册的所有的bean。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-actuator 13.2.2 使用Spring Boot Admin Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。 应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册（通过HTTP）或使用SpringCloud注册中心（例如Eureka，Consul）发现。 UI是的AngularJs应用程序，展示Spring Boot Admin Client的Actuator端点上的一些监控。常见的功能或者监控如下： 显示健康状况 显示详细信息，例如 JVM和内存指标 micrometer.io指标 数据源指标 缓存指标 显示构建信息编号 关注并下载日志文件 查看jvm系统和环境属性 查看Spring Boot配置属性 支持Spring Cloud的postable / env-和/ refresh-endpoint 轻松的日志级管理 与JMX-beans交互 查看线程转储 查看http跟踪 查看auditevents 查看http-endpoints 查看计划任务 查看和删除活动会话（使用spring-session） 查看Flyway / Liquibase数据库迁移 下载heapdump 状态变更通知（通过电子邮件，Slack，Hipchat，......） 状态更改的事件日志（非持久性） 当前Spring Boot Admin最新版本为2.2.1版。 13.2.2.1 创建服务器端 创建Spring Boot Admin监控服务器。 选择Spring Web和Spring Boot Admin Server启动依赖。 其pom依赖文件主要内容如下： org.springframework.boot spring-boot-starter-web de.codecentric spring-boot-admin-starter-server 在配置文件application.yml中设置应用名称和服务器端口。 spring: application: name: admin-server server: port: 8769 在启动类中添加@EnableAdminServer注解。 package com.example.admin.server; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import de.codecentric.boot.admin.server.config.EnableAdminServer; @SpringBootApplication @EnableAdminServer public class SpringBootAdminServerApplication { public static void main(String[] args) { SpringApplication.run(SpringBootAdminServerApplication.class, args); } } 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-admin-server 13.2.2.2 创建客户端 创建被监控的客户端。 添加Actuator和Spring Boot Admin Client启动器依赖。 在application.yml配置文件中添加Actuator配置，打开所有的监控端点。并将监控客户端注册到监控服务器上。 spring: application: name: admin-client boot: admin: client: url: http://localhost:8769 server: port: 8768 management: endpoints: web: exposure: include: '*' endpoint: health: show-details: ALWAYS 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-admin-client 13.2.2.3 测试验证 依次启动server和client两个应用，打开浏览器，访问http://localhost:8769/ Spring Boot Admin Server，可以看到监控了1个客户端。 可以通过Spring Boot Admin Server提供的界面，方便地查看client应用通过Actuator输出的监控数据，相比原生的监控（json）数据友好多了。 "},"第13章 Spring Boot应用监控/13.3monitorCustomize.html":{"url":"第13章 Spring Boot应用监控/13.3monitorCustomize.html","title":"13.3 自定义端点","keywords":"","body":"13.3 自定义端点 在项目中，我们可能需要根据实际情况来自定义监控端点，特别是一些和业务相关的监控端点。 13.3.1 自定义健康监控端点 自定义健康监测的端点有两种方式： 继承AbstractHealthIndicator类； 实现HealthIndicator接口。 通过查看HealthIndicator接口源码，可以看到，系统内置的众多健康检测端点都是从AbstractHealthIndicator抽象类继承而来的。 在spring-boot-actuator项目的application.yml配置文件中添加Actuator健康监控总是显示详细信息配置。 # Actuator 端口配置 management: endpoint: health: show-details: always 13.3.1.1 继承AbstractHealthIndicator类 创建一个监控端点类CustomHealthEndPoint继承AbstractHealthIndicator类。 在其中获取磁盘使用信息并输出监控信息。 package com.example.actuator.custom; import java.io.File; import org.springframework.boot.actuate.health.AbstractHealthIndicator; import org.springframework.boot.actuate.health.Health.Builder; import org.springframework.stereotype.Component; /** * 自定义监控示例，监控磁盘容量 * @author Kevin * */ @Component(\"myHealth\") public class CustomHealthEndPoint extends AbstractHealthIndicator { @Override protected void doHealthCheck(Builder builder) throws Exception { File[] rootFiles = File.listRoots(); if (rootFiles != null && rootFiles.length != 0) { long total = 0, free = 0; for (File file : rootFiles) { total += file.getTotalSpace(); // 磁盘总量 free += file.getUsableSpace(); // 可用容量 } long user = total - free; // 已用容量 double userRate = total == 0 ? 0 : ((double) user / total);// 磁盘利用率 builder.up() .withDetail(\"磁盘总量\", total) // 这里是你要显示的具体健康监测信息 .withDetail(\"可用容量\", free) .withDetail(\"利用率%\", userRate * 100).build(); } else { builder.down().build(); } } } 运行Spring Boot应用程序，访问监控监控端点http://localhost:8080/actuator/health，查看自定义监控端点输出的监控信息。 13.3.1.2 实现HealthIndicator接口 创建一个AnotherCustomHealthEndPoint类，实现HealthIndicator接口。实现public Health health()方法，在其中生成一个随机数，然后根据这个随机数是否为零来输出健康状态。 package com.example.actuator.custom; import java.util.Random; import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.HealthIndicator; import org.springframework.stereotype.Component; @Component(\"anotherCustomHealthEndPoint\") public class AnotherCustomHealthEndPoint implements HealthIndicator { @Override public Health health() { int errorCode = new Random().nextInt(5); // 定义一个错误代码 随机产生 if (errorCode != 0) { return Health.down().withDetail(\"错误码：\", errorCode).build(); } else { return Health.up().withDetail(\"正确代码：\", errorCode).build(); } } } 运行Spring Boot应用程序，访问监控监控端点http://localhost:8080/actuator/health，查看自定义监控端点输出的监控信息。 13.3.2 自定义Metrics端点 自定义Metrics是通过实现MeterBinder接口完成的。 新建一个DiskspaceMetrics类，实现MeterBinder接口，代码如下： package com.example.actuator.custom; import java.io.File; import org.springframework.stereotype.Component; import io.micrometer.core.instrument.Gauge; import io.micrometer.core.instrument.MeterRegistry; import io.micrometer.core.instrument.binder.MeterBinder; @Component(\"diskspaceMetrics\") public class DiskspaceMetrics implements MeterBinder { private File rootFilePath; public DiskspaceMetrics() { this.rootFilePath = new File(\".\"); } @Override public void bindTo(MeterRegistry registry) { Gauge.builder(\"磁盘已用容量\", rootFilePath, File::getTotalSpace).register(registry); Gauge.builder(\"磁盘剩余容量\", rootFilePath, File::getFreeSpace).register(registry); Gauge.builder(\"磁盘使用率\", rootFilePath, c -> { long totalDiskSpace = rootFilePath.getTotalSpace(); if (totalDiskSpace == 0) { return 0.0; } long usedDiskSpace = totalDiskSpace - rootFilePath.getFreeSpace(); return (double) usedDiskSpace / totalDiskSpace * 100; }).register(registry); } } 运行Spring Boot应用程序，访问监控监控端点http://localhost:8080/actuator/metrics，查看自定义监控端点输出的监控信息。 13.3.3 完全自定义端点 我们也可以通过Spring Boot提供的@Endpoint、 @ReadOperation、@WriteOperation、@DeleteOperation注解完全自定义监控端点，例如和业务运行状态相关的端点。 创建一个PersonEndpoint类： package com.example.actuator.custom; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import org.springframework.boot.actuate.endpoint.annotation.Endpoint; import org.springframework.boot.actuate.endpoint.annotation.ReadOperation; import org.springframework.boot.actuate.endpoint.annotation.Selector; import org.springframework.boot.actuate.endpoint.annotation.WriteOperation; import org.springframework.stereotype.Component; @Endpoint(id = \"person\") @Component public class PersonEndpoint { private final Map people = new HashMap<>(); PersonEndpoint() { this.people.put(\"kevin\", new Person(\"Kevin Zhang\")); this.people.put(\"roy\", new Person(\"Roy Zhang\")); this.people.put(\"lily\", new Person(\"Lily Huang\")); } @ReadOperation public List getAll() { return new ArrayList<>(this.people.values()); } @ReadOperation public Person getPerson(@Selector String person) { return this.people.get(person); } @WriteOperation public void updatePerson(@Selector String name, String person) { this.people.put(name, new Person(person)); } public static class Person { private String name; Person(String name) { this.name = name; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } } } 运行Spring Boot应用程序，访问监控监控端点http://localhost:8080/actuator/person，查看自定义监控端点输出的监控信息。 进一步访问http://localhost:8080/actuator/person/kevin，查看针对kevin用户的监控信息。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-actuator "},"第13章 Spring Boot应用监控/13.4homework.html":{"url":"第13章 Spring Boot应用监控/13.4homework.html","title":"13.4 课后作业","keywords":"","body":"13.4 课后作业 了解Spring Boot Actuator相关概念，阅读官方文档。 练习开发自定义监控端口。 练习使用Spring Boot Admin管理和监控SpringBoot应用程序。 "},"第14章 企业级开发/Enterprise.html":{"url":"第14章 企业级开发/Enterprise.html","title":"第14章 企业级开发","keywords":"","body":"第14章 企业级开发 在企业应用中，有很多和具体业务不相关的必须功能，例如在某些业务的审批节点发送邮件，日终定时调度批处理等。这些通用功能统称为企业级开发功能。 Spring Boot在企业级开发方面提供或整合了很多便利的基础技术支持框架，如Spring Batch，Quartz等。 本章我们学习一些如何通过Spring Boot整合常用的企业级开发支持框架，以方便在实际工作中应用。 "},"第14章 企业级开发/14.1mail.html":{"url":"第14章 企业级开发/14.1mail.html","title":"14.1 邮件发送","keywords":"","body":"14.1 邮件发送 邮件发送，是企业开发中最经常使用到的通用功能，例如用户注册时的身份认证，审批节点任务通知，库存低报警通知邮件等。 Spring提供了org.springframework.mail.javamail.JavaMailSender接口（实现类JavaMailSenderImpl）来发送邮件，Spring Boot则提供spring-boot-starter-mail起步器依赖来完成邮件发送功能的集成。 14.1.1 邮件基本概念 在邮件发送开发中，有一些基本概念，理解这些基本概念，有助于理解如何编写应用代码及配置。 14.1.1.1 SMTP SMTP全称为Simple Mail Transfer Protocol（简单邮件传输协议），它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP认证要求必须提供账号和密码才能登陆服务器，其设计目的在于避免用户受到垃圾邮件的侵扰。 SMTP的默认端口为25。 14.1.1.2 IMAP IMAP全称为Internet Message Access Protocol（互联网邮件访问协议），IMAP允许从邮件服务器上获取邮件的信息、下载邮件等。IMAP与POP类似，都是一种邮件获取协议。 IMAP的默认端口为143。 14.1.1.3 POP3 POP3全称为Post Office Protocol 3（邮局协议），POP3支持客户端远程管理服务器端的邮件。POP3常用于“离线”邮件处理，即允许客户端下载服务器邮件，然后服务器上的邮件将会被删除。目前很多POP3的邮件服务器只提供下载邮件功能，服务器本身并不删除邮件，这种属于改进版的POP3协议。 POP3的默认端口为110。 14.1.1.4 IMAP和POP3的区别 两者最大的区别在于，IMAP允许双向通信，即在客户端的操作会反馈到服务器上，例如在客户端收取邮件、标记已读等操作，服务器会跟着同步这些操作。而对于POP协议虽然也允许客户端下载服务器邮件，但是在客户端的操作并不会同步到服务器上面的，例如在客户端收取或标记已读邮件，服务器不会同步这些操作。 14.1.2 注册邮箱 本示例使用163邮箱。 首先，请注册邮箱，例如springbootcourse@163.com，设置登录密码。 然后，通过https://mail.163.com/ 登录新注册的163邮箱，设置打开POP3/SMTP等邮件发送接收服务，在设置时会结合手机发送短信验证设置“授权码”。 记录好邮箱账号、密码、授权码及163邮箱服务器地址（pop.163.com，smtp.163.com，imap.163.com）以备在后续代码中配置使用。 14.1.3 集成邮件发送 首先，创建Spring Boot应用。 选择Spring Web，Thymeleaf和Java Mail Sender起步器依赖。 示例项目的主要pom依赖如下： org.springframework.boot spring-boot-starter-mail org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 在application.yml文件中配置邮件发送属性： spring: mail: host: smtp.163.com port: 25 username: springbootcourse@163.com password: 授权码，不是邮箱登录密码，切记 default-encoding: UTF-8 properties: mail: smtp: auth: true starttls: enable: true required: true 创建发送邮件的服务类SendMailService，在其中封装邮件发送SimpleMailMessage对象。 package com.example.mail.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.stereotype.Service; @Service public class SendMailService { @Autowired private JavaMailSender mailSender; @Value(\"${spring.mail.username}\") private String from; public String sendMail(String to, String subject, String text) { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(text); mailSender.send(message); return \"Mail Sended.\"; } } 创建与用户交互的控制器类SendMailController，为了简单起见，我们不从用户界面上收集邮件信息，直接在sendMail处理器方法中提供接收者，主题和邮件内容。 package com.example.mail.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.mail.service.SendMailService; @RestController @RequestMapping(\"/mail/\") public class SendMailController { @Autowired private SendMailService sendMailService; @RequestMapping(\"/send\") public String sendMail() { String to = \"xxx@163.com\";//一个可用的邮件地址 String subject = \"你好，Spring Boot.\"; String text = \"这是一封由Spring Boot应用程序自动发送的测试邮件，无可用信息，请直接删除。\"; return sendMailService.sendMail(to, subject, text); } } 运行项目，打开浏览器，访问http://localhost:8080/mail/send，测试发送邮件。 在https://mail.163.com/ 上登录接收邮件的用户，查看是否正确收到邮件。 发送HTML格式邮件的参考代码： public void sendHtmlMail(String subject, String content) { //使用MimeMessage，MIME协议 MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper; //MimeMessageHelper帮助我们设置更丰富的内容 try { helper = new MimeMessageHelper(message, true); helper.setFrom(mailConfig.getFrom()); helper.setTo(mailConfig.getRecipient()); helper.setSubject(\"HTML格式邮件\"); helper.setText(content, true);//true代表支持html mailSender.send(message); } catch (MessagingException e) {//发送HTML邮件失败 e.printStackTrace(); } } 发送带附件邮件的参考代码： public void sendAttachmentMail(String subject, String content, File file) { MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper; try { helper = new MimeMessageHelper(message, true);//true代表支持多组件，如附件，图片等 helper.setFrom(mailConfig.getFrom()); helper.setTo(mailConfig.getRecipient()); helper.setSubject(\"带附件的HTML格式邮件\"); helper.setText(content, true);//true代表支持html FileSystemResource file1 = new FileSystemResource(file); String fileName = file1.getFilename(); helper.addAttachment(fileName, file1);//添加附件，可多次调用该方法添加多个附件 mailSender.send(message); } catch (MessagingException e) { e.printStackTrace(); } } 发送带静态资源（一般指的是图片）的邮件示例代码： public void sendInlineResourceMail(String subject, String content, String rscPath, String rscId) { MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper; try { helper = new MimeMessageHelper(message, true); helper.setFrom(mailConfig.getFrom()); helper.setTo(mailConfig.getRecipient()); helper.setSubject(\"静态资源邮件\"); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res);//重复使用添加多个图片 mailSender.send(message); } catch (MessagingException e) { e.printStackTrace(); } } 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-mail "},"第14章 企业级开发/14.2schedule.html":{"url":"第14章 企业级开发/14.2schedule.html","title":"14.2 定时任务","keywords":"","body":"14.2 定时任务 在Java领域中，调度（Schedule）定时任务可以简单的在Spring 框架中使用注解@Scheduled来完成，比如 @Scheduled(cron = \"0 0/10 * * * ?\")，也可以使用专用的调度框架。 常用的调度框架有Quartz、Elastic-Job和xxl-job。 Quartz：Java上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。当前版本2.3.0，官方组织持续更新中。 Elastic-Job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，目前是版本2.1.5，并且可以支持云开发。 xxl-job：是大众点评员工徐雪里于2015年发布的分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。当前版本2.1.2，并在持续更新中。 本小节介绍这3种调度框架，并做简单对比，然后学习如何在Spring Boot中集成Quartz调度框架。其他两种分布式调度框架，请读者阅读官方文档和示例。 14.2.1 Quartz Quartz是用来实现定时任务的一个框架。 Quart的定时任务可以随时修改。即使任务已经在调度系统中了。你还是可以随时去改变任务的实行时间(@scheduled实现该功能就比较麻烦了)。 服务重启之后Quartz的任务会自动拉起来，自动在调度系统里面根据触发器设置的时间执行。 Quartz支持集群(多台服务器部署了quartz任务，只有有一台服务器执行。而且一台服务器挂了相应的会转到其他服务器执行)。 Quartz种最重要的类是Scheduler、Job 、JobDetail、Trigger这四个类。 Scheduler 调度程序，只有安排进执行计划的Job（通过 scheduler.scheduleJob 方法安排），才有可能被调度执行。 常用的cron表达式参考，供读者选择使用。 0 0 12 * * ? 每天12点执行 0 15 10 ? * * 每天的10:15执行 0 15 10 * * ? 每天的10:15执行 0 15 10 * * ? * 每天的10:15执行 0 15 10 * * ? 2005 2005年每天的10:15执行 0 * 14 * * ? 每天的14:00到14:59期间每分钟执行 0 0/5 14 * * ? 每天的14:00到14:55每隔5分钟执行 0 0/5 14,18 * * ? 每天的14:00到14:55每隔5分钟执行和18:00到18:55每隔5分钟执行 0 0-5 14 * * ? 每天的14:00到14:05执行 0 10,44 14 ? 3 WED 三月的每一个周三的14:10和14:44执行 0 15 10 ? * MON-FRI 工作日每天的10:15:00执行 0 15 10 15 * ? 每个月的第15天的10:15:00执行 0 15 10 L * ? 每个月最后一天的10:15:00执行 0 15 10 ? * 6L 每个月最后一个周五的10:15:00执行 0 15 10 ? * 6L 2002-2005 2002, 2003, 2004, 和2005年每个月最后一个周五的10:15:00执行 0 15 10 ? * 6#3 每个月的第三个周五的10:15:00执行 0 0 12 1/5 * ? 每个月的第一天的12:00:00开始执行，每隔5天间隔执行 0 11 11 11 11 ? 每年的11月11日11:11:00执行 14.2.1.1 Job Job用于定义任务具体的逻辑。简单来说就是用来定义定时任务需要干的事情。比如我们想每天早上10点给某某人发一封邮件。Job干的事情就是发邮件的事情。每个任务对应一个Job（我们一般会自定义一个Job，继承QuartzJobBean，通过实现里面的executeInternal方法实现具体的任务逻辑）。这样调度器(Scheduler)会根据触发器(Trigger)设置的时间调度这个任务（Job）执行其中的业务逻辑。 在Job类里面怎么获取到外部参数呢？ 首先我们会在定义任务详情的时候给这个Job的JobDataMap属性里面设置一些参数。 然后在Job执行的时候，我们通过JobDataMap jobDataMap = jobExecutionContext.getMergedJobDataMap();获取到JobDataMap，取出相应的参数了。 /** * 模拟任务：定时发送邮件任务 */ public class SendEmailJob extends QuartzJobBean { @Override protected void executeInternal(JobExecutionContext jobExecutionContext) { JobDataMap jobDataMap = jobExecutionContext.getMergedJobDataMap(); if (jobDataMap != null && !jobDataMap.isEmpty()) { String level= jobDataMap.get(\"JOB_LEVEL\");//获取参数 ... System.out.println(\"开始发送邮件了\"); } } } 14.2.1.2 JobDetail JobDetail定义任务详情。包含执行任务的Job，任务的一些身份信息（可以帮助找到这个任务），给任务设置JobDataMap（把参数带到任务里面去）。 JobDetail实例一般是通过JobBuilder来创建（Build设计模式）。 JobDetail jobDetail = JobBuilder .newJob(SendEmailJob.class) .withIdentity(\"sendEmail\", \"groupName\")//JobKey是任务的唯一标识。修改任务，删除任务都是需要通过这个JobKey来找到指定的任务。 .build(); // 参数使用 JobDataMap map = jobDetail.getJobDataMap(); map.put(\"JOB_NAME\", \"sendEmail\"); map.put(\"JOB_LEVEL\", \"B9+\");//设置参数 ... 14.2.1.3 Trigger Trigger触发器，设置Job什么时候执行。Quartz框架默认给咱们提供了四种触发器。 触发器 试用场景 SimpleTrigger 简单触发器，适用于 按指定的时间间隔执行多少次任务的情况 CronTrigger Cron触发器，通过Cron表达式来控制任务的执行时间 DailyTimeIntervalTrigger 日期触发器，在给定的时间范围内或指定的星期内以秒、分钟或者小时为周期进行重复的情况 CalendarIntervalTrigger 日历触发器，根据一个给定的日历时间进行重复 一个Trigger只能绑定一个Job，但是一个Job可以被多个Trigger绑定。 以下以灵活的CronTrigger为例来说明如何创建一个触发器。 CronTrigger使用Cron表达是来定义任务的触发时间。相对来说比较灵活，对于复杂的业务需求来说更加的实用。 String cronExpression = String.format(\"0 %d %d ? * *\", 15, 30);//每天15:30执行 CronTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\"trigger1\", \"trigger_group1\")// 触发器名,触发器组 .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression)) .build(); Job和Trigger是通过Scheduler绑定起来的。scheduler.scheduleJob(job, trigger); 14.2.1.4 Scheduler Scheduler调度器，是Quartz框架的心脏，用来管理Trigger和Job，并保证Job能在Trigger设置的时间被触发执行。 Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.scheduleJob(job, trigger); 调度程序创建之后，处于“待机”状态，必须调用 scheduler 的 start() 方法启用调度程序。可以使用 shutdown() 方法关闭调度程序，使用 isShutdown() 方法判断该调度程序是否已经处于关闭状态。通过 Scheduler.scheduleJob(…) 方法将任务纳入调度程序中，当任务触发时间到了的时候，该任务将被执行。 14.2.2 Elastic-Job Elastic-Job是一个分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成。 14.2.2.1 Elastic-Job-Lite Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务。 其特点为： 分布式调度协调 弹性扩容缩容 失效转移 错过执行作业重触发 作业分片一致性，保证同一分片在分布式环境中仅一个执行实例 自诊断并修复分布式不稳定造成的问题 支持并行调度 支持作业生命周期操作 丰富的作业类型 Spring整合以及命名空间提供 运维平台 14.2.2.2 Elastic-Job-Cloud Elastic-Job-Cloud使用Mesos + Docker的解决方案，额外提供资源治理、应用分发以及进程隔离等服务。 其特点为： 应用自动分发 基于Fenzo的弹性资源分配 分布式调度协调 弹性扩容缩容 失效转移 错过执行作业重触发 作业分片一致性，保证同一分片在分布式环境中仅一个执行实例 支持并行调度 支持作业生命周期操作 丰富的作业类型 Spring整合 运维平台 基于Docker的进程隔离(TBD) 14.2.3 xxl-job XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 官方文档介绍的特点如下： 1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手； 2、动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效； 3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA； 4、执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA； 5、注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址； 6、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务； 7、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等； 8、故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。 9、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度； 10、任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务； 11、任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试； 12、任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式； 13、分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务； 14、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 15、事件触发：除了”Cron方式”和”任务依赖方式”触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。 16、任务进度监控：支持实时监控任务进度； 17、Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志； 18、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。 19、脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本; 20、命令行任务：原生提供通用命令行任务Handler（Bean任务，”CommandJobHandler”）；业务方只需要提供命令行即可； 21、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔； 22、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行； 23、自定义任务参数：支持在线配置调度任务入参，即时生效； 24、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞； 25、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性； 26、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件； 27、推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用; 28、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等； 29、全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行； 30、跨平台：原生提供通用HTTP任务Handler（Bean任务，”HttpJobHandler”）；业务方只需要提供HTTP链接即可，不限制语言、平台； 31、国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文； 32、容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用； 33、线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性； 34、用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色； 35、权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作； 如需要在项目上使用，请进一步阅读官方文档进行学习。 14.2.4 对比总结 上面介绍了3种调度框架，对比如下，供读者选择使用。 对比项 Quartz elastic-job xxl-job 依赖 mysql jdk1.7+, zookeeper 3.4.6+ ,maven3.0.4+ ,mesos mysql ,jdk1.7+ , maven3.0+ 集群、弹性扩容 多节点部署，通过竞争数据库锁来保证只有一个节点执行任务 通过zookeeper的注册与发现，可以动态的添加服务器。 支持水平扩容 使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力 任务分片 不支持 支持 支持 管理界面 无 支持 支持 高级功能 无 弹性扩容，多种作业模式，失效转移，运行状态收集，多线程处理数据，幂等性，容错处理，spring命名空间支持 弹性扩容，分片广播，故障转移，Rolling实时日志，GLUE（支持在线编辑代码，免发布）,任务进度监控，任务依赖，数据加密，邮件报警，运行报表，国际化 缺点 没有管理界面，以及不支持任务分片等。不适用于分布式场景 需要引入zookeeper , mesos, 增加系统复杂度, 学习成本较高 调度中心通过获取 DB锁来保证集群中执行任务的唯一性， 如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。 任务不能重复执行 数据库锁 将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。 使用Quartz基于数据库的分布式功能 并行调度 采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。 调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。 失败处理策略 弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。 调度失败时的处理策略，策略包括：失败告警（默认）、失败重试（界面可配置） 动态分片策略 支持多种分片策略，可自定义分片策略。 默认包含三种分片策略： 基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略。elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：a、新的Job实例加入集群b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行）c、主节点选举” 分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务； quartz 调用API的的方式操作任务，不人性化； 需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。 调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务； Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。 elastic-job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用。 xxl-job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用。 14.2.5 集成Quartz 在下面的示例中，为了集中学习Quartz的用法，使用内存存储job对象（RAMJobStore）不涉及数据库。 在Spring Boot中创建一个新的应用。 添加“Quartz Scheduler”启动器依赖。 项目的pom主要依赖如下： org.springframework.boot spring-boot-starter-quartz org.springframework.boot spring-boot-starter-web 配置文件application.yml中设置Quartz的任务存储类型。 spring: quartz: job-store-type: memory 14.2.5.1 传统集成方式 传统集成方式为直接使用Quartz的API，方便我们理解Quartz的4个主要的类。 创建HelloJob类，继承Job接口。 package com.example.quartz.job; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; /** * 创建一个示例任务 * @author Kevin * */ public class HelloJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { System.out.println(System.currentTimeMillis() + \" - HelloJob 执行\"); } } 创建一个TestQuartz类，在其中创建JobDetail，Trigger和Scheduler。 其中的Trigger为CronTrigger，其Cron表达式为“0 0/1 22,23 ?”含义为“每晚10点-11点，每隔1分钟执行1次”。 package com.example.quartz.scheduler; import org.quartz.CronScheduleBuilder; import org.quartz.CronTrigger; import org.quartz.JobBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SchedulerException; import org.quartz.TriggerBuilder; import org.quartz.impl.StdSchedulerFactory; import org.springframework.stereotype.Service; import com.example.quartz.job.HelloJob; /** * Quartz调度器示例 * @author Kevin * */ @Service public class TestQuartz { public TestQuartz() { Scheduler scheduler; try { scheduler = StdSchedulerFactory.getDefaultScheduler(); System.out.println(scheduler.getSchedulerName() + \" - \" + scheduler.getSchedulerInstanceId()); JobDetail jobDetail = JobBuilder .newJob(HelloJob.class) .withIdentity(\"helloJob\", \"groupName\") .build(); String cronExpression = \"0 0/1 22,23 * * ?\";//每晚10点-11点，每隔1分钟执行1次 CronTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\"helloTrigger\", \"trigger_group\")// 触发器名,触发器组 .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression)) .build(); scheduler.scheduleJob(jobDetail, trigger);//Scheduler绑定job和trigger scheduler.start(); } catch (SchedulerException e) { e.printStackTrace(); } } } 启动应用，通过控制台，查看任务执行效果： 14.2.5.2 Spring集成方式 Spring为Quartz提供了API扩展支持，在实际项目中使用起来更方便。 首先创建一个SpringQuartzJob，在其中接收任务参数（name）。 package com.example.quartz.job; import java.util.Date; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.springframework.scheduling.quartz.QuartzJobBean; /** * 使用Spring提供的Quartz集成API方式 * @author Kevin * */ public class SpringQuartzJob extends QuartzJobBean { private String name; public void setName(String name) { this.name = name; } @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException { System.out.println(\"Spring Quartz Job say hello to \" + name + \": \" + new Date()); } } 创建一个Configuration配置类，在其中设置JobDetail，Trigger和Scheduler。 package com.example.quartz.config; import org.quartz.CronTrigger; import org.quartz.JobDataMap; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.quartz.CronTriggerFactoryBean; import org.springframework.scheduling.quartz.JobDetailFactoryBean; import org.springframework.scheduling.quartz.SchedulerFactoryBean; import com.example.quartz.job.SpringQuartzJob; @Configuration public class SpringQuartzConfig { @Bean JobDetailFactoryBean jobDetail() { JobDataMap jobDataMap = new JobDataMap(); jobDataMap.put(\"name\", \"Kevin Zhang\"); JobDetailFactoryBean bean = new JobDetailFactoryBean(); bean.setJobClass(SpringQuartzJob.class); bean.setJobDataMap(jobDataMap); return bean; } @Bean CronTriggerFactoryBean cronTrigger() { CronTriggerFactoryBean bean = new CronTriggerFactoryBean(); bean.setCronExpression(\"0/30 * * * * ?\");//每隔30秒执行1次 bean.setJobDetail(jobDetail().getObject()); return bean; } @Bean SchedulerFactoryBean scheduler() { SchedulerFactoryBean bean = new SchedulerFactoryBean(); CronTrigger trigger = cronTrigger().getObject(); bean.setTriggers(trigger); return bean; } } 以上代码： 在jobDetail方法中，为Job提供了name参数的值，Kevin Zhang； 在cronTrigger方法中，为Trigger提供cron表达式，并将JobDetail绑定到Trigger上； 在scheduler方法中，将前面创建的Trigger注册到scheduler中。 然后启动应用，观察控制台输出信息，可以看到每隔30秒，SpringQuartzJob执行1次，并可以正确获取name参数的值（Kevin Zhang）。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-quartz "},"第14章 企业级开发/14.3batch.html":{"url":"第14章 企业级开发/14.3batch.html","title":"14.3 批处理","keywords":"","body":"14.3 批处理 在日常的项目开发过程中，批处理是一个非常常见的企业级开发功能，比如日终结息，日终对账，日终盘点库存等业务需求。 Spring Batch 是一款开源的基于 Spring 的企业批处理框架。通过它可以构建出健壮的企业级批处理应用，比如我们可以将csv文件中的数据（数据量几百万甚至几千万都是没问题的）批处理插入保存到数据库中。 Spring Batch 提供了统一的读写接口、丰富的任务处理方式、灵活的事务管理及并发处理，包括日志/跟踪(tracing)，事务管理，任务处理(processing)统计，任务重启， 忽略(skip)，和资源管理等功能。 此外还提供了许多高级服务和特性，使之能够通过优化(optimization ) 和分片技术(partitioning techniques)来高效地执行超大型数据集的批处理任务。这些功能对大数据量处理来说是必不可少的，并且大大简化了批处理应用开发，将开发人员从复杂的任务配置管理过程中解放出来，使他们可以更多地去关注核心的业务处理过程。 正如我们知道的，Spring Batch 是一款批处理应用框架，而不是调度框架。它只关注批处理任务相关的问题，如事务、并发、监控、执行等，并不提供相应的调度功能。因此，如果我们希望批处理任务定期执行（一般的企业应用都有这样的需求，也都是这么做的），可结合 Quartz 等成熟的调度框架实现。 比如Quartz结合Spring Batch完成日终对账功能。更大的业务场景（如结息）可能需要Elastic-Job分布式调度框架。 14.3.1 基本概念 Spring Batch框架的组成部分有： JobRepository：用来注册Job容器，设置数据库相关属性。 JobLauncher：用来启动Job的接口。 Job：我们要实际执行的任务，包含一个或多个。 Step：即步骤，包括：ItemReader->ItemProcessor->ItemWriter。 ItemReader：用来读取数据，做实体类与数据字段之间的映射。比如读取csv文件中的人员数据，之后对应实体person的字段做mapper。 ItemProcessor：用来处理数据的接口，同时可以做数据校验（设置校验器，使用JSR-303(hibernate-validator)注解），比如将中文性别男/女，转为M/F。同时校验年龄字段是否符合要求等。 ItemWriter：用来输出数据的接口，设置数据库源。编写预处理SQL插入语句。 一个典型的处理过程如下图所示： 14.3.2 集成 在Spring Boot中集成Spring Batch一如既往地方便。 Spring Batch 本身较为复杂，本示例演示如何在Spring Boot中集成使用Spring Batch，并不深入演示Spring Batch的使用，感兴趣的读者请自行寻找Spring Batch更进一步的学习资料。 创建一个Spring Boot项目。 选择Spring Batch等启动器依赖。 项目的pom主要依赖如下： org.springframework.boot spring-boot-starter-batch org.springframework.boot spring-boot-starter-jdbc org.springframework.boot spring-boot-starter-web mysql mysql-connector-java runtime 在application.yml配置文件中设置数据源及Spring Batch配置信息。 spring: datasource: url: jdbc:mysql://localhost:3306/batch?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver batch: job: enabled: false #需要jobLaucher.run执行 initialize-schema: always 在src/main/resources文件夹中创建user.csv文件，添加5条记录，以供Spring Batch读取并存入数据库。 id,username,gender,age 1,张三丰,男,99 2,张无忌,男,28 3,东方不败,女,16 4,李寻欢,男,22 5,唐伯虎,男,21 创建user数据库表，以存储Spring Batch从csv文件读取到的数据。 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL, `username` varchar(255) DEFAULT NULL, `gender` varchar(8) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 创建数据库user表对应的实体类User。 package com.example.batch.entity; public class User { private Integer id; private String username; private String gender; private int age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 创建SpringBatchConfig配置类，在其中通过@EnableBatchProcessing注解打开Spring Batch支持。 package com.example.batch.config; import javax.sql.DataSource; import org.springframework.batch.core.Job; import org.springframework.batch.core.Step; import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing; import org.springframework.batch.core.configuration.annotation.JobBuilderFactory; import org.springframework.batch.core.configuration.annotation.StepBuilderFactory; import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider; import org.springframework.batch.item.database.JdbcBatchItemWriter; import org.springframework.batch.item.file.FlatFileItemReader; import org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper; import org.springframework.batch.item.file.mapping.DefaultLineMapper; import org.springframework.batch.item.file.transform.DelimitedLineTokenizer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.io.ClassPathResource; import com.example.batch.entity.User; /** * Spring Batch示例 * @author Kevin * */ @Configuration @EnableBatchProcessing // 开启批处理的支持 public class SpringBatchConfig { @Autowired DataSource dataSource; @Autowired JobBuilderFactory jobBuilderFactory; @Autowired StepBuilderFactory stepBuilderFactory; /** * 定义Reader，读取ClassPath下的user.csv，并封包到User实体类 * @return */ @Bean FlatFileItemReader itemReader() { FlatFileItemReader reader = new FlatFileItemReader(); reader.setLinesToSkip(1);// 跳过表头 reader.setResource(new ClassPathResource(\"user.csv\")); reader.setLineMapper(new DefaultLineMapper() {// entity与csv数据做映射 { setLineTokenizer(new DelimitedLineTokenizer() { { setNames(new String[] { \"id\", \"username\", \"gender\", \"age\" }); setDelimiter(DELIMITER_COMMA); } }); setFieldSetMapper(new BeanWrapperFieldSetMapper() { { setTargetType(User.class); } }); } }); return reader; } /** * 定义Writer，用给定的sql将User实体类写入数据库 * @return */ @Bean JdbcBatchItemWriter jdbcBatchItemWriter() { JdbcBatchItemWriter writer = new JdbcBatchItemWriter<>(); writer.setDataSource(dataSource); writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider()); writer.setSql(\"insert into user(id,username,gender,age) values(:id,:username,:gender,:age)\"); return writer; } /** * 定义步骤，在步骤中绑定Reader和Writer，每读到2条数据及写入数据库 * @return */ @Bean Step myStep(FlatFileItemReader reader, JdbcBatchItemWriter writer) { return stepBuilderFactory.get(\"myStep\") .chunk(2) .reader(reader) .writer(writer) .build(); } /** * 创建任务，使用上面的步骤 * @return */ @Bean Job myJob(Step step) { return jobBuilderFactory.get(\"myJob\") .start(step) .build(); } } Spring Batch使用的一般步骤就是：创建Reader，创建Writer，创建步骤绑定Reader和Writer，创建任务（绑定步骤）。 创建一个Controller，以JobLauncher.run启动Spring Batch，运行Job，从csv文件中读取数据，并写入数据库。 package com.example.batch.controller; import org.springframework.batch.core.Job; import org.springframework.batch.core.JobParametersBuilder; import org.springframework.batch.core.launch.JobLauncher; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/batch/\") public class JobController { @Autowired JobLauncher jobLauncher; @Autowired Job job; @RequestMapping(\"/run\") public String run() { String result = \"STOP\"; try { jobLauncher.run(job, new JobParametersBuilder().toJobParameters()); result = \"RUN\"; } catch (Exception e) { e.printStackTrace(); } return result; } } 运行Spring Boot应用，打开浏览器访问http://localhost:8080/batch/run，启动JobLauncher，观察控制台输出的日志信息。 2020-01-22 21:46:57.137 INFO 10692 --- [nio-8080-exec-1] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=myJob]] launched with the following parameters: [{}] 2020-01-22 21:46:57.193 INFO 10692 --- [nio-8080-exec-1] o.s.batch.core.job.SimpleStepHandler : Executing step: [myStep] 2020-01-22 21:46:57.288 INFO 10692 --- [nio-8080-exec-1] o.s.batch.core.step.AbstractStep : Step: [myStep] executed in 95ms 2020-01-22 21:46:57.303 INFO 10692 --- [nio-8080-exec-1] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=myJob]] completed with the following parameters: [{}] and the following status: [COMPLETED] in 140ms 通过数据库管理工具，可以看到Spring Batch创建了9张以batch_开头的表。并且，user表中插入了5条数据，这5条数据来源于user.csv文件。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-batch "},"第14章 企业级开发/14.4validation.html":{"url":"第14章 企业级开发/14.4validation.html","title":"14.4 数据校验","keywords":"","body":"14.4 数据校验 在我们的日常工作中，对于任何一个应用而言，数据绝大多数情况下都会从客户端（前端，如浏览器）与服务端（后端，如tomcat）之间来回传输，如果只做客户端数据校验是远远不够的，是不安全的。我们必须在后台对数据进行验证，然后才将其持久化存储（如新增或更新到数据库）。 数据校验是一个企业级项目架构上最为基础的功能模块。 Spring Boot 对数据校验提供了完美的集成，框架本身大量使用了数据校验功能，我们在实际项目中也应该大量使用数据校验功能以保护后台数据的安全。 14.4.1 概念 JSR-303 Bean Validation 是一个运行时的数据验证规范，为 JavaBean 验证定义了相应的元数据模型和 API。缺省的元数据是 Java Annotations，通过使用 XML 可以对原有的元数据信息进行覆盖和扩展。在应用程序中，通过使用 Bean Validation 或是你自己定义的 constraint，例如 @NotNull, @Max, @ZipCode， 就可以确保数据模型（JavaBean）的正确性。constraint 可以附加到字段，getter 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 constraint。Bean Validation 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。 Hibernate Validator 是 Bean Validation 的参考实现。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。 Spring's JSR-303 规范，是标准 JSR-303 的一个变种（默认使用Hibernate Validator）。Spring Validation 验证框架对参数的验证机制提供了@Validated，javax提供了@Valid（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。 常用的数据校验注解如下表： 限制 说明 @Null 限制只能为null @NotNull 限制必须不为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max(value) 限制必须为一个不大于指定值的数字 @Min(value) 限制必须为一个不小于指定值的数字 @Past 限制必须是一个过去的日期 @Pattern(value) 限制必须符合指定的正则表达式 @Size(max,min) 限制字符长度必须在min到max之间 @Past 验证注解的元素值（日期类型）比当前时间早 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 14.4.2 原理 请参考 Spring 校验处理器org.springframework.validation.beanvalidation.BeanValidationPostProcessor类的源码。 BeanValidationPostProcessor 类内部有个boolean类型的属性afterInitialization，默认是false，如果是false，在postProcessBeforeInitialization过程中对bean进行验证，否则在postProcessAfterInitialization过程对bean进行验证。 @Nullable private Validator validator; private boolean afterInitialization = false; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (!this.afterInitialization) { doValidate(bean); } return bean; } public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if (this.afterInitialization) { doValidate(bean); } return bean; } 真正处理校验的方法是doValidate方法，缺省使用ValidatorFactory的默认Validator（校验器）。 在Spring Boot中，默认校验器框架是HibernateValidator，所以 Spring 默认调用org.hibernate.validator.internal.engine.ValidatorFactoryImpl来生成validator供Spring Boot校验使用。 protected void doValidate(Object bean) { Assert.state(this.validator != null, \"No Validator set\"); Object objectToValidate = AopProxyUtils.getSingletonTarget(bean); if (objectToValidate == null) { objectToValidate = bean; } Set> result = this.validator.validate(objectToValidate); if (!result.isEmpty()) { StringBuilder sb = new StringBuilder(\"Bean state is invalid: \"); for (Iterator> it = result.iterator(); it.hasNext();) { ConstraintViolation violation = it.next(); sb.append(violation.getPropertyPath()).append(\" - \").append(violation.getMessage()); if (it.hasNext()) { sb.append(\"; \"); } } throw new BeanInitializationException(sb.toString()); } } 在Spring Boot中添加spring-boot-starter-validation后，支持方法级别的JSR-303规范： Spring Boot 自动配置（org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration）添加org.springframework.validation.beanvalidation.MethodValidationPostProcessor到Spring 容器中； 类上加上@Validated注解； 在方法的参数中加上验证注解，比如@Max、@Min、@NotEmpty、@NotNull等。 @Service @Validated public class MyBean { public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code, Author author) { ... } } 14.4.3 自动装配 spring-boot-starter-web 依赖的 spring-boot-starter-validation 会在项目中添加 hibernate-validator-6.0.18.Final.jar 包。 hibernate-validator-6.0.18.Final.jar 包中会使用 HibernateValidator 校验器。 Spring Boot 自动装配类 ValidationAutoConfiguration 上的注解 @ConditionalOnResource(resources = \"classpath:META-INF/services/javax.validation.spi.ValidationProvider\") 检测到存在 hibernate-validator-6.0.18.Final.jar 包中的spi配置，就启动 Spring Boot 中的 Validation 自动配置，将 LocalValidatorFactoryBean 和 MethodValidationPostProcessor 装载（@Bean）到 Spring 容器中。 @Configuration(proxyBeanMethods = false) @ConditionalOnClass(ExecutableValidator.class) @ConditionalOnResource(resources = \"classpath:META-INF/services/javax.validation.spi.ValidationProvider\") @Import(PrimaryDefaultValidatorPostProcessor.class) public class ValidationAutoConfiguration { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) @ConditionalOnMissingBean(Validator.class) public static LocalValidatorFactoryBean defaultValidator() { LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean(); MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory(); factoryBean.setMessageInterpolator(interpolatorFactory.getObject()); return factoryBean; } @Bean @ConditionalOnMissingBean public static MethodValidationPostProcessor methodValidationPostProcessor(Environment environment, @Lazy Validator validator) { MethodValidationPostProcessor processor = new MethodValidationPostProcessor(); boolean proxyTargetClass = environment.getProperty(\"spring.aop.proxy-target-class\", Boolean.class, true); processor.setProxyTargetClass(proxyTargetClass); processor.setValidator(validator); return processor; } } 这样，在运行时，Spring 就会调用校验器对数据进行校验。 14.4.4 集成 创建一个Spring Boot应用。 添加Spring Web启动器依赖。 在项目的pom中查看maven依赖，可以看到数据校验依赖（spring-boot-starter-validation）是直接包含在spring-boot-starter-web里面的，并且使用了hibernate-validator，所以我们在web应用中可以直接使用JSR-303规范的数据校验功能。 新建一个User类，用来接收客户端传过来的数据。 @Validated public class User { @Size(min = 2, max = 10, message = \"用户名必须大于2个字，并且小于10个字。\") private String name; @Length(min = 6, max = 12, message = \"密码长度必须在1~12位之间。\") private String password; @Max(value = 100, message = \"非法年龄。\") private int age; //getter & setter ... } 创建UserController，接收客户端Post传递过来的数据，验证测试。 @RestController @RequestMapping(\"/validation/\") public class UserController { @PostMapping(\"/hello\") public String sayHello(@Valid @RequestBody User user, BindingResult results) { if (results.hasErrors()) { return \"请求参数校验错误：\" + results.getFieldError().getDefaultMessage(); } return \"success\"; } } 在 Postman 中输入请求参数（json），访问http://localhost:8080/validation/hello地址： { \"name\": \"Kevin Zhang\", \"password\": \"123456\", \"age\": 18 } 检查返回的校验结果“请求参数校验错误：用户名必须大于2个字，并且小于10个字。”，符合预期。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-validation "},"第14章 企业级开发/14.5websocket.html":{"url":"第14章 企业级开发/14.5websocket.html","title":"14.5 WebSocket","keywords":"","body":"14.5 WebSocket 在某些内部管理系统中，有些服务端消息需要及时通知到当前用户，比如审批工作流中的审批任务，或某种公告要通知到一批人（某些角色/岗位的用户），又或是系统内置的聊天系统。在这些场景下，可以使用 WebSocket 技术。 14.5.1 介绍 以前，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 你可以用var Socket = new WebSocket(url, [protocol] );创建 WebSocket 对象，第一个参数 url, 指定连接的 URL，第二个参数 protocol 是可选的，指定可接受的子协议。。 WebSocket 与 Socket 的区别： 软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。 基于这个通信结构的概念。Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。 WebSocket 则是一个典型的应用层协议。 总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。 WebSocket具有如下特点： WebSocket使用时需要先创建连接，这使得WebSocket成为一种有状态的协议，在之后的通行过程中可以省略部分状态信息（例如身份认证等）； WebSocket连接在端口80（ws）或者443（wss）上连接，与HTTP使用的端口相同，这样基本所有的防火墙都不会阻止WebSocket的连接； WebSocket使用HTTP协议进行握手，因此可以直接集成到网络浏览器和HTTP服务器中，不需要额外的成本； 心跳消息（ping和pong）将被反复推送，保持WebSocket一致处于活跃状态； 使用该协议，当消息启动或者到达时，服务端和客户端都可以知道； Websocket连接关闭时将发送一个特殊的关闭消息； WebSocket支持跨域，可以避免Ajax的限制； HTTP规范要求浏览器将并发连接限制为每个主机名两个连接，但是当我们使用WebSocket的时候，当握手完成后，该限制就不存在了，因为此时的连接已经不再是HTTP连接了； WebSocket协议支持扩展，用户可以扩展协议，实现部分自定义的子协议； 更好的二进制支持以及更好的压缩效果。 14.5.2 集成 Spring Boot 一如既往地提供了WebSocket的启动器依赖来支持方便地集成。 我们通过聊天室及点对点聊天来示例如何使用WebSocket技术。 创建一个Spring Boot 应用。 添加 WebSocket 等必要的启动器依赖。项目中添加 Spring Security 是为了方便地使用不同的用户，以演示用户之间的聊天功能。 项目pom文件中添加了一些前端依赖库方便前端页面引用，依赖配置信息如下。 org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-websocket org.webjars webjars-locator-core org.webjars sockjs-client 1.1.2 org.webjars stomp-websocket 2.3.3 org.webjars jquery 3.3.1 例如上面的stomp-websocket依赖，打开 stomp-websocket-2.3.3.jar 可以看到其内部包含了 stomp.min.js 文件，可以在页面上引用，而不用再单独提供，这样方便统一依赖版本管理。 14.5.2.1 聊天室 首先创建 WebSocketConfig 配置类，配置 @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker(\"/topic\"); registry.setApplicationDestinationPrefixes(\"/app\"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); } } 自定义WebSocketConfig继承自WebSocketMessageBrokerConfigurer进行WebSocket配置，然后通过@EnableWebSocketMessageBroker注解开启了WebSocket消息代理； registry.enableSimpleBroker(\"/topic\")表示设置消息代理的前缀，即如果消息的前缀是”/topic”，就会将消息转发给代理（broker），再由消息代理将消息广播给当前连接的客户端（通俗的讲就后台向前台发送消息的地址要加上/topic前缀）； registry.setApplicationDestinationPrefixes(\"/app\")表示配置一个或多个前缀，通过这些前缀过滤出需要被注解方法处理的消息（通俗的讲就前台向后台发送消息的地址要加上/app前缀）； registry.addEndpoint(\"/chat\").withSockJS()表示定义一个前缀为”/chat”的endPoint，并开启sockjs支持，sockjs可以解决浏览器对WebSocket的兼容性问题，客户端将通过这里配置的URL来建立WebSocket连接（确切的说就是通过/chat连接后台）。 创建消息类Message，添加需要的属性。 public class Message { private String name; private String content; private String time; ... } 定义一个Controller来处理消息。 @Controller public class GreetingController { @MessageMapping(\"/hello\") @SendTo(\"/topic/greetings\") public Message greeting(Message message) throws Exception { Calendar calendar = Calendar.getInstance(); DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); Date date = calendar.getTime(); message.setTime(df.format(date));//添加发送时间 return message; } } 根据前面配置类中的配置，上面Controller中 @MessageMapping(\"/hello\") 注解的方法用来接收“/app/hello”路径发送过来的消息，在对消息进行处理后，再将消息转发到 @SendTo(\"/topic/greetings\") 定义的路径上，这个路径上有“/topic”前缀，所以由消息代理进行广播。 构建聊天室页面app.html，存放到到项目的 resources/static 路径下。 群聊 请输入用户名： 连接 断开连接 请输入聊天内容： 发送 群聊进行中... 创建聊天室用的前端js文件app.js，存放到到项目的 resources/static 路径下。 var stompClient = null; function setConnected(connected) { $(\"#connect\").prop(\"disabled\", connected); $(\"#disconnect\").prop(\"disabled\", !connected); if (connected) { $(\"#conversation\").show(); $(\"#chat\").show(); } else { $(\"#conversation\").hide(); $(\"#chat\").hide(); } $(\"#greetings\").html(\"\"); } function connect() { if (!$(\"#name\").val()) { return; } var socket = new SockJS('/chat'); stompClient = Stomp.over(socket); stompClient.connect({}, function(frame) { setConnected(true); stompClient.subscribe('/topic/greetings', function(greeting) { showGreeting(JSON.parse(greeting.body)); }); }); } function disconnect() { if (stompClient !== null) { stompClient.disconnect(); } setConnected(false); } function sendName() { stompClient.send(\"/app/hello\", {}, JSON.stringify({ 'name' : $(\"#name\").val(), 'content' : $(\"#content\").val() })); } function showGreeting(message) { $(\"#greetings\") .append(\"\" + message.name + \": \" + message.content + \" [\" + message.time + \"] \"); } $(function() { $(\"#connect\").click(function() { connect(); }); $(\"#disconnect\").click(function() { disconnect(); }); $(\"#send\").click(function() { sendName(); }); }); connect方法表示建立一个WebSocket连接，在建立WebSocket连接时，用户必须先输入用户名，然后才能建立连接； 方法体中的意思：使用SockJS建立连接，然后创建一个STOMP实例发起请求，在连接成功回调方法中，首先调用setConnected(true)；方法进行页面设置，然后调用STOPM中的subscribe方法订阅服务端发送回来的消息，并将服务端发送来的消息展示出来（使用showGreeting方法）； 调用STOMP中的disconnect方法可以断开一个WebScoket连接。 运行聊天室应用，通过两个浏览器来模拟两个人在聊天室中的聊天。 在Chrome浏览器中输入http://localhost:8080/app.html，使用kevin用户名连接后，参与聊天。 在Edge浏览器中输入http://localhost:8080/app.html，使用roy用户名连接后，参与聊天。 经测试，可以看到 WebSocket 聊天室功能正常。 14.5.2.2 点对点聊天 由于点对点聊天涉及具体的用户，所以，添加Spring Security配置类。 @Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"admin\")).roles(\"ADMIN\", \"USER\") .and() .withUser(\"kevin\").password(new BCryptPasswordEncoder().encode(\"6998\")).roles(\"USER\") .and() .withUser(\"roy\").password(new BCryptPasswordEncoder().encode(\"3525\")).roles(\"OTHER\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() .permitAll() .and().authorizeRequests() .anyRequest() .authenticated(); } } 以上代码只是最简单的Spring Security配置，目的是支持用户登录，并让登录的用户具有用户身份。 改造WebSocketConfig配置类，添加 \"/queue\" 代理（broker）。 @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker(\"/topic\", \"/queue\"); registry.setApplicationDestinationPrefixes(\"/app\"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); } } 创建消息类，用来封装消息发送者，接收者，消息内容和消息发送时间。 public class ChatMsg { private String from; private String to; private String content; private String time; ... } 创造一个ChatController控制器，用来处理点对点的聊天消息， @Controller public class ChatController { @Autowired SimpMessagingTemplate template; @MessageMapping(\"/chat\") public void chat(Principal principal, ChatMsg msg) throws Exception { String from=principal.getName(); msg.setFrom(from); Calendar calendar = Calendar.getInstance(); DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); Date date = calendar.getTime(); msg.setTime(df.format(date));//添加发送时间 template.convertAndSendToUser(msg.getTo(), \"/queue/chat\", msg);; } } @MessageMapping(\"/chat\")表示来自”/app/chat”路径的消息（客户端chat.js中的sendMsg方法代码stompClient.send(\"/app/chat\"...）将被chat方法处理，chat方法的第一个参数Principal 可以用来获取当前登录用户的信息，第二个参数则是客户端发送来的消息； 在chat方法中，首先获取当前登录用户的用户名，设置给msg对象的from属性，然后设置消息的发送时间，再将消息发送出去，发送的目标就是msg的to属性； 消息发送使用的方法是convertAndSendToUser，该方法内部调用了convertAndSend方法，并对消息路径做了处理（SimpMessagingTemplate类中private String destinationPrefix = \"/user/\"，所以后续客户端订阅消息中需要添加user前缀，即/user/queue/chat）。 convertAndSend(this.destinationPrefix + user + destination, payload, headers, postProcessor); 创建一个聊天页面chat.html文件，存放到到项目的 resources/static 路径下。 单聊 请输入聊天内容： 目标用户： 发送 创建chat.js，存放到到项目的 resources/static 路径下，处理连接WebSocket、发送和接收聊天信息。 var stompClient = null; function connect() { var socket = new SockJS('/chat'); stompClient = Stomp.over(socket); stompClient.connect({}, function(frame) { stompClient.subscribe('/user/queue/chat', function(chat) { showChatMsg(JSON.parse(chat.body)); }); }); } function sendMsg() { stompClient.send(\"/app/chat\", {}, JSON.stringify({ 'to' : $(\"#to\").val(), 'content' : $(\"#content\").val() })); } function showChatMsg(message) { $(\"#chatsContent\") .append(\"\" + message.from + \": \" + message.content + \" [\" + message.time + \"] \"); } $(function() { connect(); $(\"#send\").click(function() { sendMsg(); }); }); 连接成功后，订阅地址为”/user/queue/chat”，该地址比服务端配置的地址多了”/user”前缀，这是因为，SimpMessagingTemplate类中自动添加了路径前缀； 聊天消息发送路径为”/app/chat”； 发送的消息内容中有一个to字段，该字段用来描述消息发送的目标用户。 启动项目运行聊天程序，通过两个浏览器来模拟两个人点对点聊天。 在Chrome浏览器中输入http://localhost:8080/chat.html，使用kevin用户名密码6998登录后（自动连接），在roy用户登录后向其发送聊天信息。 在Edge浏览器中输入http://localhost:8080/chat.html，使用roy用户名密码3525登录后（自动连接），在接收到kevin用户发送的消息后回复信息。 经测试，可以看到kevin和roy两个用户可以完成点对点的聊天。 在我们实际工作中，上面的聊天室功能和企业管理类系统中的通知类似，点对点聊天功能就是一种小型的即时通讯功能。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-websocket "},"第14章 企业级开发/14.6swagger2.html":{"url":"第14章 企业级开发/14.6swagger2.html","title":"14.6 Swagger 2","keywords":"","body":"14.6 Swagger 2 当前，前后端分离已经逐渐成为企业级应用项目的一种标准的开发方式，前端与后端交给不同的人员开发，但是项目开发中的沟通成本也随之升高，这部分沟通成本主要在于前端开发人员与后端开发人员对后台开发功能接口的沟通。通常情况下，后端开发人员会制作一份API接口文档发放给前端开发人员，但是企业级应用在开发阶段API通常会有较大变化，随变化维护一份API开发接口文档成本相当高，并且不方便测试。 Swagger2 是一个规范和完整的框架，用于生成、描述、调用和可视化Restful风格的Web服务，它可以动态生成Api接口文档，这样就能很好地解决功能和API接口一致性的问题，从而降低沟通成本，促进项目高效开发。 14.6.1 常用注解 Swagger2常用注解： @Api 注解可以用来标记后台接口类的功能。 @ApiOperation 注解用来标记一个方法的作用。 @ApilmplicitParam 注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。 @ApilmplicitParams 如果有多个参数，则需要使用多个 @ApilmplicitParam 注解来描述， 多个 @ApilmplicitParam 注解需要放在一个 @ApilmplicitParams 注解中。 @ApiModel 如果参数是一个对象，则需要在对象所在的类上加上此注解。 @ApiModelProperty 如果参数是一个对象，则需要在对应的属性上加上此注解，还需要在对象所在的类上加上 @ApiModel。 @ApiIgnore 注解标识此参数可以忽略。 14.6.2 集成 Spring Boot 集成 Swagger2 非常方便，官方提供了监控界面，也有第三方提供的更为漂亮的监控界面。 首先创建一个Spring Boot应用。 选择Spring Web启动器依赖。 添加swagger2依赖，官方提供了监控界面，也有第三方提供的更漂亮的监控界面。 监控界面需要二选一。 io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 com.github.xiaoymin swagger-bootstrap-ui 1.9.6 创建一个Swagger2配置类。 package com.example.swagger2.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.github.xiaoymin.swaggerbootstrapui.annotations.EnableSwaggerBootstrapUI; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 @EnableSwaggerBootstrapUI //官方监控UI需要删除这一句 public class Swagger2Config { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.example.swagger2\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"Spring Boot 培训教程\") //标题 .description(\"示例API文档\") //描述 .termsOfServiceUrl(\"https://www.xprogrammer.net\") //这里配置的是服务网站 .contact(new Contact(\"Kevin Zhang\", \"https://www.xprogrammer.net\", \"goodman@example.com\")) // 三个参数依次是姓名，个人网站，邮箱 .version(\"1.0\") //版本 .build(); } } 创建一个示例Controller，其中使用Swagger2的注解，对类，方法和参数进行标注。 package com.example.swagger2.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiOperation; @Api(value = \"Demo控制器\", tags = \"学习模块\") @RestController @RequestMapping(\"/demo/\") public class DemoController { @ApiOperation(value = \"对你说Hello\", notes = \"根据传入的用户名，向你说Hello。\") @ApiImplicitParam(name = \"name\", value = \"用户名\", required = true, dataType = \"String\") @RequestMapping(\"/sayHello\") public String sayHello(String name) { return \"Say hello to \" + name + \".\"; } } 启动应用，访问官方监控UIhttp://localhost:8080/swagger-ui.html，查看在线API文档。因为这个API接口文档是系统在启动时Swagger2读取代码中的注解生成的，所以一定是和代码保持一致的。 如果使用的是第三方监控UI依赖，启动应用后，访问监控地址http://localhost:8080/doc.html，可以看到更漂亮的监控界面。 可以在监控界面直接测试接口，检查后台功能是否正确。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-swagger2 "},"第14章 企业级开发/14.7homework.html":{"url":"第14章 企业级开发/14.7homework.html","title":"14.7 课后作业","keywords":"","body":"14.7 课后作业 练习发送带附件的HTML格式邮件。 练习在Spring Boot中以RAMJobStore（内存存储Job）方式集成Quartz调度器。 扩展作业：尝试在Spring Boot中以JobStoreTX（数据库存储Job）方式集成Quartz调度器。 练习Spring Batch的使用。 练习数据校验，并在其中使用Swagger2标注API接口文档。 使用WebSocket创建登录用户之间的点对点聊天。 "},"第15章 多环境配置与部署/MultEnv.html":{"url":"第15章 多环境配置与部署/MultEnv.html","title":"第15章 多环境配置与部署","keywords":"","body":"第15章 应用的多环境配置与部署 我们在实际工作过程中，项目通常会经历开发、测试和生产几个阶段，不同的阶段会配置单独的环境。针对这些环境，不同的组织有不同的管理策略，但是都会使用不同的软硬件环境并做一定的隔离，也就是说，会在保持基础软件（操作系统、JDK版本、应用服务器等）环境不变的情况下，缩减硬件配置，一般而言，开发环境硬件资源最小，测试环境适中，生产环境最好。 在很久以前，开发人员面对这样不同的环境时，通常都是针对不同的环境现场修改配置参数（IP地址，数据库连接，文件存放的本地路径或文件服务器路径等），不仅麻烦而且容易出错，特别是其他维护人员（非项目开发人员）在修改配置参数时忽略了系统维护手册的详细配置说明的情况，时有发生。 现在，通过 Spring Boot 中提供的配置文件（application.properties）和概要文件（profile）机制可以方便地进行多环境的统一配置。更进一步，Spring Cloud 中的配置中心可以提供分布式的统一集中配置。 当项目组完成一个项目的开发后，就需要部署到测试环境或生产环境，Spring Boot 的spring-boot-maven-plugin maven 插件能够将后端项目（通常是一个web应用，通过rest接口提供服务）打包成内置web服务器的可执行jar包（fat jar），可直接部署到服务器上通过nohup java -jar xxx.jar &（Linux命令）方式运行，大大简化了部署工作。 本章，我们简要介绍 Spring Boot 对多环境配置profile和部署的支持。 "},"第15章 多环境配置与部署/15.1multEnvUse.html":{"url":"第15章 多环境配置与部署/15.1multEnvUse.html","title":"15.1 使用多环境配置","keywords":"","body":"15.1 使用多环境配置 Spring Boot 是通过概要文件（profile）机制对多环境配置提供支持的。 典型的用法是，通过在resources目录下提供多个application-xxx.properties文件，然后再application.properties中设置spring.profiles.active=xxx之类的配置或在运行时提供--spring.profiles.active=xxx参数来激活某个概要文件。 还有一种不常用的方法是通过在启动类中设置激活的概要文件。 @SpringBootApplication public class SpringBootConfigApplication { public static void main(String[] args) { SpringApplicationBuilder builder = new SpringApplicationBuilder(SpringBootConfigApplication.class); builder.application().setAdditionalProfiles(\"dev\"); builder.run(args); } } 创建一个Spring Boot 应用。 选择支持数据库的Web应用启动器依赖。 提供4个配置文件application.properties、application-dev.properties、application-prod.properties和application-test.properties， 开发环境概要文件application-dev.properties内容如下： server.port=8080 spring.datasource.url=jdbc:mysql://localhost:3306/ssdev?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 测试环境概要文件application-test.properties内容如下： server.port=7070 spring.datasource.url=jdbc:mysql://localhost:3306/sstest?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 生产环境概要文件application-prod.properties内容如下： server.port=9090 spring.datasource.url=jdbc:mysql://localhost:3306/ssprod?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 项目配置文件application.properties中设置激活的概要文件，其内容如下： spring.profiles.active=dev 添加entiy、dao、service和controller类，以便测试配置文件是否生效。数据库结构和代码复用“5.1 Spring Boot集成JdbcTemplate”小节的对应代码。 数据库表结构DDL语句： DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(32) NOT NULL AUTO_INCREMENT, `userName` varchar(32) NOT NULL, `passWord` varchar(50) NOT NULL, `realName` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 实体User类： public class User { private Integer id; private String userName; private String passWord; private String realName; //...setter & getter @Override public String toString() { return \"User{\" + \"id=\" + id + \", userName='\" + userName + '\\'' + \", passWord='\" + passWord + '\\'' + \", realName='\" + realName + '\\'' + '}'; } } 数据访问UserDAO类： @Repository public class UserDAO { @Autowired JdbcTemplate jdbcTemplate; public User getUser(int id) { String sql = \"select * from user where id=\" + id; return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<>(User.class)); } } 服务UserService类： @Service public class UserService { @Autowired UserDAO userDAO; public User getUser(int id) { return userDAO.getUser(id); } } 控制器UserController类： @RestController @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @RequestMapping(\"get/{id}\") public String getUser(@PathVariable int id) { return userService.getUser(id).toString(); } } 清空配置文件application.properties内容，使用启动类中的代码配置方式激活“dev”概要文件，应用程序在8080端口提供服务，在浏览器中访问测试，情况如下： 在配置文件application.properties中添加“spring.profiles.active=prod”激活生产环境概要文件，应用程序在9090端口提供服务，在浏览器中访问测试，情况如下： 应用打包后，在项目的“spring-boot-config\\target”下，通过启动参数java -jar config-0.0.1-SNAPSHOT.jar --spring.profiles.active=test激活测试环境概要文件。 java -jar config-0.0.1-SNAPSHOT.jar --spring.profiles.active=test . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.4.RELEASE) ... 2020-01-31 10:40:31.269 INFO 12344 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 7070 (http) with context path '' 2020-01-31 10:40:31.275 INFO 12344 --- [ main] c.e.config.SpringBootConfigApplication : Started SpringBootConfigApplication in 3.369 seconds (JVM running for 4.134) 应用程序在测试环境的7070端口提供服务，在浏览器中访问测试，情况如下： 通过上述示例，我们可以知道如何配置概要文件，和如何激活概要文件。也验证了概要文件的激活优先顺序： 启动命令行参数--spring.profiles.active=test最优先； 配置配置文件application.properties中spring.profiles.active=prod的设置次之； 启动类种SpringApplicationBuilder.application().setAdditionalProfiles(\"dev\")优先级最低。 这也是符合开发运维的通行做法：命令优先于配置，配置优先于代码。这样的原则或做法，在 Spring 体系内大量存在，广泛使用。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-config "},"第15章 多环境配置与部署/15.2multEnvDeploy.html":{"url":"第15章 多环境配置与部署/15.2multEnvDeploy.html","title":"15.2 打包部署应用","keywords":"","body":"15.2 打包部署应用 Spring Boot 项目可以如传统的web应用一样打包成war包，部署到不同的应用服务器（如tomcat，jetty，WebSphere Application Server，WebLogic等）中，也可以使用内嵌服务器（tomcat，jetty，Undertow 等开源容器），以直接可运行的可执行jar包（Spring Boot 官方称之为fat jar）方式部署。 由于我们在绝大多数情况下使用 Spring Boot 开发前后端分离的企业级应用，所以这里介绍的 Spring Boot 项目特指 Spring Boot Web项目，即使用 Spring MVC 通过REST方式在HTTP上提供服务的后端项目。 本小节对这两种打包部署方式进行介绍。 官方文档介绍，其支持 Maven 和 Gradle 两种构建系统，本小节只介绍我们在项目中经常使用的 Maven 构建系统。 在Maven构建系统中，Spring Boot 是通过 Maven 插件的方式提供打包支持的。 org.springframework.boot spring-boot-maven-plugin 15.2.1 Fat JAR 为了分析 Spring Boot Fat JAR 的启动机制，添加“spring-boot-loader”依赖，以便打开 Spring Boot 对应的源码。 org.springframework.boot spring-boot-loader provided 在 Spring Boot 项目的pom.xml文件中指定项目打包类型为 jar（jar，不提供打包类型，默认就是打包为jar），然后添加spring-boot-maven-plugin插件，在项目上运行 Maven Build... 在 Goals 输入package 构建命令（可选跳过测试），然后运行。Maven就开始编译打包。 在STS中新建 Spring Starter 项目，默认就添加了spring-boot-maven-plugin插件。 Maven 打包完成后，在项目的 target 目录中就生成了两个jar包： config-0.0.1-SNAPSHOT.jar.original：原始的jar包，包含项目代码编译后的内容； config-0.0.1-SNAPSHOT.jar：spring-boot-maven-plugin 插件添加依赖的其他jar包（如内嵌tomcat服务器，Spring MVC，MySQL驱动等）的“Fat Jar”文件。 使用 WinRAR 压缩工具打开这个 Fat Jar 文件，可以看到在BOOT-INF下的lib子目录下包含了tomcat内嵌服务器及其他依赖jar包。在 BOOT-INF\\classes 目录下就是我们在项目中配置文件、Java 类编译后的 class 字节码文件。 ├── BOOT-INF # 存放项目中开发的业务相关类和配置文件，和依赖的jar │ ├── classes # 项目业务代码及配置文件 │ └── lib # 存放项目的依赖库，如Spring MVC，MySQL JDBC驱动，Tomcat内嵌服务器 ├── META-INF # 包括 MANIFEST.MF 描述文件和 maven 的构建信息 │ ├── MANIFEST.MF │ └── maven └── org # Spring Boot 相关的类 └── springframework 根据 Java jar 的运行规范，查看/META-INF/MANIFEST.MF，找到的Main-Class是org.springframework.boot.loader.JarLauncher，这是 Spring Boot 提供的一个启动类。 Manifest-Version: 1.0 Implementation-Title: spring-boot-config Implementation-Version: 0.0.1-SNAPSHOT Start-Class: com.example.config.SpringBootConfigApplication Spring-Boot-Classes: BOOT-INF/classes/ Spring-Boot-Lib: BOOT-INF/lib/ Build-Jdk-Spec: 1.8 Spring-Boot-Version: 2.2.4.RELEASE Created-By: Maven Archiver 3.4.0 Main-Class: org.springframework.boot.loader.JarLauncher 打开 JarLauncher 源码，可以看到其继承自 ExecutableArchiveLauncher 类，并提供了 \"BOOT-INF/classes/\" 和 \"BOOT-INF/lib/\" 常量。 public class JarLauncher extends ExecutableArchiveLauncher { static final String BOOT_INF_CLASSES = \"BOOT-INF/classes/\"; static final String BOOT_INF_LIB = \"BOOT-INF/lib/\"; public JarLauncher() { } protected JarLauncher(Archive archive) { super(archive); } @Override protected boolean isNestedArchive(Archive.Entry entry) { if (entry.isDirectory()) { return entry.getName().equals(BOOT_INF_CLASSES); } return entry.getName().startsWith(BOOT_INF_LIB); } public static void main(String[] args) throws Exception { new JarLauncher().launch(args); } } 查看 ExecutableArchiveLauncher 类，可以看到 getMainClass 方法获取 Start-Class（/META-INF/MANIFEST.MF文件中提供的：Start-Class: com.example.config.SpringBootConfigApplication），这个就是我们在项目中用 @SpringBootApplication 注解标注的 SpringBootConfigApplication 启动类。 @Override protected String getMainClass() throws Exception { Manifest manifest = this.archive.getManifest(); String mainClass = null; if (manifest != null) { mainClass = manifest.getMainAttributes().getValue(\"Start-Class\"); } if (mainClass == null) { throw new IllegalStateException(\"No 'Start-Class' manifest entry specified in \" + this); } return mainClass; } 简单的说，jar 包中的 Main-Class JarLauncher 找到 Start-Class（就是@SpringBootApplication 注解标注的的启动类），使用 Fat JAR 文件中 BOOT-INF/lib/ 路径下的依赖jar包，运行 Spring Boot 应用程序。 一旦打包好了 Fat JAR，就可以 ssh 到工作机/堡垒机然后通过 scp 将这个Fat JAR 拷贝到部署服务器上，通过nohup java -jar xxx.jar & 即可启动 Spring Boot 应用。以上几个命令，都为 Linux 下的命令。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-config 15.2.2 WAR 在较少遇到的一些特殊情况下，我们需要将 Spring Boot 后端项目打包部署到客户指定的服务器上，比如WebSphere Application Server、WebLogic上，这种传统部署方式就需要传统的war包。 Spring Starter 新建项目向导提供了完善的支持，可以快速的开发测试项目，并将项目打包为传统war包。 首先创建一个 Spring Boot 项目，打包类型选择“War”。 选择 Spring Web 启动器依赖。 Spring Starter新建项目向导为项目pom文件中添加打包类型war和spring-boot-starter-tomcat依赖。 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.4.RELEASE com.example war 0.0.1-SNAPSHOT war spring-boot-war Spring Boot War Example. 1.8 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat provided org.springframework.boot spring-boot-starter-test test org.junit.vintage junit-vintage-engine org.springframework.boot spring-boot-maven-plugin Spring 为我们生成了一个ServletInitializer类，在 configure 方法中完成初始化操作。 package com.example.war; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(SpringBootWarApplication.class); } } 在开发环境下可按照“Spring Boot App”方式正常运行，和传统内嵌tomcat容器运行方式一样。 服务器启动后，访问http://localhost:8080/hello/greeting?name=Kevin可按照预期返回结果。 也可以在 STS 中添加 tomcat 9，然后选择“Run on Server”按照传统Web应用开发方式运行。 在 STS 内打开的浏览器地址栏中输入http://localhost:8080/war/hello/greeting?name=Kevin可正确的返回期望的结果。 执行 maven package 打包操作后，在项目 target 目录下生成两个 war 包文件，和传统内嵌web容器的 jar 包类似，一个为原始封包，一个为可运行 war 包。 通过 WinRAR 打开 war-0.0.1-SNAPSHOT.war 文件，可以看到熟悉的 war 包结构和 Spring Boot 的 Fat JAR 的 org.springframework.boot.loader.JarLauncher 类等类似结构。 查看“/META-INF/MANIFEST.MF”文件，可以看到 Main-Class 变更为 Main-Class: org.springframework.boot.loader.WarLauncher ，通过 java -jar war-0.0.1-SNAPSHOT.war 可运行内嵌服务器版的 Spring Boot war 应用。 Manifest-Version: 1.0 Implementation-Title: spring-boot-war Implementation-Version: 0.0.1-SNAPSHOT Start-Class: com.example.war.SpringBootWarApplication Spring-Boot-Classes: WEB-INF/classes/ Spring-Boot-Lib: WEB-INF/lib/ Build-Jdk-Spec: 1.8 Spring-Boot-Version: 2.2.4.RELEASE Created-By: Maven Archiver 3.4.0 Main-Class: org.springframework.boot.loader.WarLauncher 将打包后的 war-0.0.1-SNAPSHOT.war 文件拷贝到“apache-tomcat-9.0.30\\webapps”目录下，启动 tomcat，打开浏览器访问http://localhost:8080/war-0.0.1-SNAPSHOT/hello/greeting?name=Kevin可正确的返回期望的结果。 Spring Boot 为我们打包的war文件，即可单独运行（使用内嵌web容器），也可以部署到web服务器（如tomcat 9）中运行。 所以，我们可以将 Spring Boot 打包出来的 war 包称之为 Fat WAR。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-war "},"第15章 多环境配置与部署/15.3homework.html":{"url":"第15章 多环境配置与部署/15.3homework.html","title":"15.3 课后作业","keywords":"","body":"15.3 课后作业 在Spring Boot Web 项目中练习多环境部署，至少提供开发、测试和生产3个环境的配置概要文件，并了解在代码、配置和运行参数中激活概要文件的优先级。 了解 Fat JAR 和 Fat WAR 打包的基本原理，并以 Spring Boot Web 项目为例，将打包的 war 文件部署到Tomcat 9 上面，测试能正确运行。 "},"Postscript.html":{"url":"Postscript.html","title":"后记","keywords":"","body":"后记 谨以此书与Roy.大象共勉。 我和大象约定，2019年11月我坚持每天写作，他坚持每天写日记。 我做到了，他也做到了。 12月，我们也做到了坚持。 希望将来他能有一个爱好写作、爱好分享的好习惯，做知识的贡献者，做知识的传播者。 --Kevin & Roy 由于时间关系，删除了计划中的第16章 综合示例，后续版本一定会补上。 另外，在写作后期，还计划在本书的下一版本中添加两个专题：规则引擎和流程引擎。 恭喜各位，一路学习到这里，你了解了 Spring Boot 的生态，可以在实际工作中实战啦！ 能冠以“编程思想”的书，都是相当有分量的（参考Java编程思想），小马哥的这本Spring Boot编程思想（核心篇）值得你认真仔细的阅读/操练（代码）3遍。 当然，万变不离其宗，你最应该看的是 Spring Boot官方文档 和其源码。只有到了这一步，才能自豪地说：我掌握了Spring Boot（还谈不上精通）。 所以，你的简历上尽量不要写精通Spring Boot。 推荐大家继续学习我的下一份教程：Spring Cloud 培训教程。 最后的感慨： 坚持写作101天，跨过大年三十，走过正月初一；在火车站写过，在机场休息室写过，在火车上写过，在飞机上也写过；家里写过，酒店也写过。绝大部分内容都是在忙完白天的事儿晚上抽时间写的，周末和放假就多花些时间多写点儿，总体来看，平均每天有2小时，整本书写完应该超过200小时； 从第一天开始，这本书就在 github 上开源，欢迎你传播，但是不能据为己有，后面修改的版本，我还想找个出版社出版呢； 至少第1版是一本 Open Book，附加的示例项目，都可以供你在工作中 CTRL+C，快速开始； 为啥？兴趣使然。 张光勇，2020年2月7日22点，成都。 "},"附录1 前后端分离的vue急速入门/Vue.html":{"url":"附录1 前后端分离的vue急速入门/Vue.html","title":"附录1 前后端分离的vue急速入门","keywords":"","body":"A1 前后端分离的vue急速入门 随着互联网应用的越来越普遍，传统的业务管理软件也越来越注重用户体验，多终端也逐渐成为一个常态。企业内部的大型应用，也逐渐上到云上，无论这朵云是共用云还是私有云。 在这种背景下，统一的一套后端服务逻辑，服务于多个前端具有很好的工程实践价值。所以，最近几年前后端分离的MVVM架构模式应用变得越来越广泛。 在前后端分离这种架构模式下，在Java EE领域，后端REST服务方式，Spring Boot几乎成了事实上的标准。 前端也有不少优秀的框架，React、Angular和Vue.js都各有侧重点。其中国人开发的开源Vue.js框架，由于简单、上手快，在国内有较好的开源社区生态的原因，越来越受到国内开发者的喜爱，成为国内在企业级应用领域应用最多的前端js框架。 本章，我们简要介绍Vue的用法，并和Spring Boot后端连接起来，能够脱离开发环境进行部署。读者如果需要更进一步学习vue，官方文档 是一个不错的开始。Vue.js实战这本书能帮助你更进一步理解vue是如何设计的，以及如何扩展开发vue的组件。 "},"附录1 前后端分离的vue急速入门/0.1vueOverview.html":{"url":"附录1 前后端分离的vue急速入门/0.1vueOverview.html","title":"A.1 Vue介绍","keywords":"","body":"A1.1 Vue介绍 A1.1.1 vue 简史 Vue.js 的创始人是国人尤雨溪，他的开发初衷是想做一个自己喜欢的框架。作者受 Angular 的启发，vue 于 2013 年年底成型，于 2014 年 01 月 24 日正式对外发布，版本号 0.8.0。2015 年 06 月 13 日 vue 第一个里程碑 V1.0.0 正式发布，同年 vue 相关产品 vue-router、vuex、vue-cli 相继发布，随后 vue 社区也在持续更新中，现在 vue 版本已经到 4.0.0 。 A1.1.2 vue 是什么？ vue 是一款友好，多用途且高性能的渐进式 JavaScript 框架，换言之，如果已有一个现成的服务端应用，你可以将 vue 作为一部分嵌入其中，带来更丰富的交互体验。如果需要前端实现更多的业务逻辑，vue 的核心库和生态系统即可满足。vue 和其他前端框架一样，可定义复用组件，每个文件包含 html、JavaScript、css 三部分可以渲染网页中相应的位置。 vue 官网：https://cn.vuejs.org/ "},"附录1 前后端分离的vue急速入门/0.2vueConfig.html":{"url":"附录1 前后端分离的vue急速入门/0.2vueConfig.html","title":"A.2 Vue开发环境配置","keywords":"","body":"A1.2 Vue开发环境配置 运行环境 node.js，官网下载 LTS 最新版本安装。 开发工具推荐 Visual Studio Code（VSCode），官网下载最新版本即可。也可以使用其它任何 html 编辑器。 vue 安装 此处采用 CDN 方式安装： 直接 引入：官网下载 vue.js 文件，在页面中直接引入 CDN：官网提供开发环境、生产环境和原生 ES modules 的引入地址 NPM：使用 node.js 的包管理工具 npm 下载最新稳定版的 vue npm install vue 命令行工具（CLI）：vue 提供一个官方的 CLI ，是单页面应用快速搭建繁杂的脚手架。作为后期快速搭建单页面应用的工具。 "},"附录1 前后端分离的vue急速入门/0.3helloVue.html":{"url":"附录1 前后端分离的vue急速入门/0.3helloVue.html","title":"A.3 Hello Vue","keywords":"","body":"A1.3 Hello Vue 本小节使用 vue + Spring Boot 演示一个前后端分离的场景下读取和展示信息的项目，是使用vue前后端分离的“Hello World.”。 本示例使用的后台代码如下，其中需要关注的是@CrossOrigin(origins = \"*\")这个注解，它注解了这个方法（sayHello）是支持跨域访问的。 package com.example.hello.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class SayHelloController { @Value(\"${net.xprogrammer.author}\") private String author; @Value(\"${net.xprogrammer.book}\") private String book; @RequestMapping(\"/hello\") @CrossOrigin(origins = \"*\") public String sayHello() { return \"Hello Spring Boot. Author=\" + author + \", Book=\" + book; } } 上面给出的后台代码访问返回的数据情况如下： 首先，在tomcat的ROOT应用下直接建立一个hello.html，方便我们测试。 例如，这个路径：C:\\Java\\apache-tomcat-8.5.47\\webapps\\ROOT\\hello.html，非常简单粗暴。 Hello Vue 最简单的前后端分离应用：访问后台Spring Boot服务，返回一个字符串消息显示在下面。 访问后台 var app = new Vue({ el: '#app', data: { helloSpringBoot: '请点击“访问后台”按钮。' }, methods: { sayHello() { var vm = this; axios({ method: 'get', url: 'http://localhost:8080/hello', }).then(function (res) { vm.helloSpringBoot = res.data; }).catch(function (error) { console.log(error); }); } } }) 在创建的 hello.html 文件内，引入 vue.js，此处采用 CDN 方式直接引入 vue.js 。当引入 vue.js 后，会声明一个 Vue 全局变量，通过 new Vue() 的方式可以获得一个 vue 应用。 vue.js 没有集成 ajax 功能，要使用 ajax 功能，可以使用 vue 官方推荐的 axios.js 库来做 ajax 的交互，这个示例中我们也通过CDN引入axios。 在页面声明一个 id=\"app\" 的 div 标签，在 div 内部使用 vue 常见的文本插值方式插入一个 helloSpringBoot 变量。 使用 ID 选择器将 #app 赋给 Vue 的选项的 el 属性，即绑定 vue 视图。 在vue内部的data部分，定义helloSpringBoot并为其赋一个初始值“请点击“访问后台”按钮。”。 添加一个按钮，绑定到sayHello方法。 在sayHello方法内访问后台服务（http://localhost:8080/hello），将返回的数据赋给helloSpringBoot 变量（vm.helloSpringBoot = res.data;）。 vue自行处理更新页面上的数据。 访问Tomcat的hello.html页面，显示的是页面及vue初始化后的效果，其中helloSpringBoot显示的是初始值。 点击“访问后台”按钮后，页面通过axios发起ajax请求后台服务，获取数据，并显示，效果如下： 补充内容：跨域 跨域问题的产生是出于浏览器的同源策略限制。 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。 当前页面url 被请求页面url 是否跨域 原因 http://www.test.com/ http://www.test.com/index.html 否 同源（协议、域名、端口号相同） http://www.test.com/ https://www.test.com/index.html 是 协议不同（http/https） http://www.test.com/ http://www.baidu.com/ 是 主域名不同（test/baidu） http://www.test.com/ http://blog.test.com/ 是 子域名不同（www/blog） http://www.test.com:8080/ http://www.test.com:7001/ 是 端口号不同（8080/7001） 跨域请求的时候，客户端会自动发起一个 OPTIONS 方法到服务器，客户端发起的这个 OPTIONS 可以说是一个“预请求”，用于探测后续真正需要发起的跨域请求对于服务器来说是否是安全可接受的。 请求头 Access-Control-Request-Method 用于提醒服务器在接下来的请求中将会使用什么样的方法来发起请求： Access-Control-Allow-Method 和 Access-Control-Allow-Origin 分别告知客户端，服务器允许客户端用于跨域的方法和域名。 当你的请求地址和浏览器上的url地址不一样的时候，由于同源策略，将请求不到资源，将无法“跨域”获取资源。ajax，vue中的axios都会出现跨域问题。 Spring后台支持CORS跨域的办法有如下3种： 通过配置类，为整个应用提供CORS跨域支持。 @Configuration public class MyConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\"); } }; } } 控制器或控制器方法提供CORS跨域支持。 @CrossOrigin(maxAge = 3600) @RestController @RequestMapping(\"/account\") public class AccountController { @CrossOrigin(origins = \"http://domain2.com\") @GetMapping(\"/{id}\") public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(\"/{id}\") public void remove(@PathVariable Long id) { // ... } } 基于过滤器的CORS跨域支持。 @Configuration public class MyConfiguration { @Bean public FilterRegistrationBean corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin(\"http://domain1.com\"); config.addAllowedHeader(\"*\"); config.addAllowedMethod(\"*\"); source.registerCorsConfiguration(\"/**\", config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; } } 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-vue "},"附录1 前后端分离的vue急速入门/0.4vueRouter.html":{"url":"附录1 前后端分离的vue急速入门/0.4vueRouter.html","title":"A.4 Vue路由示例","keywords":"","body":"A1.4 Vue路由示例 本小节使用 Vue + Vue-router + Spring Boot 演示一个前后端分离场景下实现用户注册、展示用户列表的路由切换项目，引入 vue-router 技术。 示例中使用的后端代码如下，其中需要关注的是@CrossOrigin(origins = \"*\")这个注解，它注解了这个方法（register、getUsers）是支持跨域访问的。 为了集中讲解vue的处理，简化处理后台数据处理逻辑，将注册的用户数据存入ServletContex的application的属性中。并且所有的业务逻辑都写在Controller中了。 package com.example.vue.controller; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletContext; import javax.servlet.http.HttpServletRequest; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class UserController { @RequestMapping(\"/register\") @CrossOrigin(origins = \"*\") public String register(String name, HttpServletRequest request) { ServletContext application = request.getServletContext(); @SuppressWarnings(\"unchecked\") List users = (List) application.getAttribute(\"users\"); if (users == null || users.size() (); } users.add(name); application.setAttribute(\"users\", users); return name + \" Registered.\"; } @RequestMapping(\"/getUsers\") @CrossOrigin(origins = \"*\") public List getUsers(HttpServletRequest request) { ServletContext application = request.getServletContext(); @SuppressWarnings(\"unchecked\") List users = (List) application.getAttribute(\"users\"); if (users == null || users.size() (); } return users; } } 上面的后台服务代码给出了两个接口：注册用户（@RequestMapping(\"/register\")）、查询用户（@RequestMapping(\"/getUsers\")）信息列表。其中查询用户信息列表返回的数据结构如下： [ \"Kevin\", \"Roy\", \"GoodMan\", \"Happy Zhang\" ] 本示例前端代码如下： 为了简化示例过程，我们直接在 TOMCAT 下的 ROOT 文件夹下创建 router.html，以便于测试。 例如，这个路径：C:\\Java\\apache-tomcat-8.5.47\\webapps\\ROOT\\router.html vue 路由示例 Vue路由示例：访问后台Spring Boot服务，实现用户注册、查看功能。 注册新用户 查看用户列表 用户名： 返回 保存 已注册用户列表 返回 // 定义主页面组件 const index_component = { template: '#index', }; // 定义注册组件 const regist_component = { template: '#regist', data() { return { name: '' } }, methods: { save() { var vm = this; axios({ method: 'get', url: 'http://localhost:8080/register?name=' + vm.name }).then(function(res) { alert(res.data) }).catch(function(error) { console.log(error); }); } } }; // 定义用户列表组件 const user_component = { template: '#showUser', data() { return { user_arr: [] } }, mounted() { var vm = this; axios({ method: 'get', url: 'http://localhost:8080/getUsers' }).then(function(res) { vm.user_arr = res.data; }).catch(function(error) { console.log(error); }); } }; // 创建 router 实例，配置 routes const router = new VueRouter({ routes: [{ path: '/', component: index_component }, { path: '/regist', component: regist_component }, { path: '/showUser', component: user_component }] }); // 创建 Vue 实例 var vm = new Vue({ el: '#app', router }) 实现 vue 路由的跳转功能分为4个步骤： 引入 vue、axios、vue-router 的 js 文件。 在文件 router.html 内，采用 CDN 方式直接引入vue.js 。 vue 官方推荐的axios.js库来做 ajax 的交互，本示例中我们也通过 CDN 方式引入 axios。 引入 vue-router.js , 直接在 Vue 实例中通过 router 配置参数注入路由。 定义组件。 创建一个组件的配置对象，该对象即为一个 vue 实例对象，包含属性同 vue 配置项相同，其属性为 vue 生命周期中的钩子函数。 组件配置对象中的 template 通过 id 选择器绑定注册界面组件。 创建路由实例。 引入的 vue-router.js 文件声明了一个全局变量 VueRouter， 通过 new VueRouter() 创建路由实例。实例创建成功后，自带两个全局注册的组件：入口组件 router-view 导航组件 router-link 。 配置路由对象，其中需要注意的是 path、components 两个属性，path 在一个路由实例中必须全局唯一、components 必须指向一个具体的组件。 创建 vue 实例 引入 vue.js 时，即存在一个全局的 Vue，通过 new Vue() 的方式可以获得一个 vue 应用，即 vue 实例。 使用 ID 选择器将 #app 赋给 Vue 的选项的 el 属性，即绑定 vue 视图。 实现本示例功能需要三个界面组件： 主页面组件（index）： 提供【注册新用户】和【查看用户列表】两个功能按钮，分别跳转到对应的界面。界面如下： 界面上两个按钮使用路由的导航组件 router-link 包裹，分别指向“regist”组件和“showUser”组件。 注册新用户 查看用户列表 用户注册界面组件： 点击主界面的【注册新用户】按钮进入该界面，界面如下： 【保存】按钮绑定 save 方法。 save 方法内访问后台服务 （http://localhost:8080/register），携带参数 name 。该服务返回数据直接打印到浏览器 alert(res.data) 。 用户信息列表界面组件： 点击主界面的【查看用户列表】按钮进入该界面，界面如下： mounted() 是 vue 生命周期的一个钩子函数，是指数据挂在到标签上以后执行，即挂载完成。在该方法内访问后台服务（http://localhost:8080/hello）获取用户列表信息数据，将返回的数据赋给 user_arr 变量（user_arr = res.data;）。 vue自行处理更新页面上的数据。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-vue "},"附录1 前后端分离的vue急速入门/0.5deploy.html":{"url":"附录1 前后端分离的vue急速入门/0.5deploy.html","title":"A.5 前后端分离应用的部署","keywords":"","body":"A1.5 前后端分离应用的部署 前后端分离部署，一般前端会部署在Nginx（或Apache Httpd）上。后端部署在Tomcat上或Spring Boot的Fat Jar（含内嵌Tomcat服务器）直接部署。 在某种情况下，我们为了架构统一，使用前后端分离的方式开发的应用，又需要部署把前后端部署在一个Fat Jar包中。 比如，使用统一开发平台开发的产品，有的客户规模大，是前端后端分布式微服务化部署。有的客户规模下，采用单体架构部署。 A1.5.1 前端部署 将开发好的前端页面（如html及其js、图片等），部署到web服务器中，例如下图的Tomcat（不推荐前端用Tomcat，这里只是为了方便学习，不引入过多的技术）。 然后启动前端服务器，就可以供客户访问了。 A1.5.2 后端部署 Spring Boot中打包可执行的Fat Jar，内嵌Tomcat服务器，直接通过java -jar命令启动服务器。 A1.5.3 退化为单体部署 将开发完成的前端资源（html、js、图片等）拷贝到后端Spring Boot应用的/src/main/resources/static下，然后再导出可执行jar包（含内嵌服务器）或war包（可部署到指定的服务器下）。 "},"附录1 前后端分离的vue急速入门/0.6vueSummary.html":{"url":"附录1 前后端分离的vue急速入门/0.6vueSummary.html","title":"A.6 急速入门总结","keywords":"","body":"A1.6 急速入门总结 vue 和其他前端框架一样，可定义复用组件，每个文件包含 html、JavaScript、css 三部分可以渲染网页中相应的位置。 单页面下直接引入 vue： vue 的应用可以简单分为两个重要组成部分：一个是视图 (html)，一个是脚本(script)。 声明变量创建一个新的 Vue 对象，使用 vue 常见的文本插值方式插入一个 message 变量。使用 ID 选择器标签赋给 Vue 的选项的 el 属性，绑定视图。 使用 axios 与后端交互，单页面下使用 引入： axios 中 method 属性指定请求方式； url 属性指定请求地址，data属性向后端传输数据。 vue 中使用 axios 会涉及到跨域问题，需在前端配置 proxyTable 或在后端做跨域支持。 vue 路由的引入： vue 路由步骤： 定义组件： const Component_1 = { template: 'this is component 1' } 或通过 template 的 id 来 定义组件： this is component 1 const Component_1 = { template: '#component_1' } 定义路由，映射组件： const router = new VueRouter({ routes: [ { path: '/component_1', component: Component_1 } ] }); 创建 Vue 实例，注入路由并挂载实例： var vm = new Vue({ router }).$mount('#app'); 在视图中使用 router-link 组件来导航，通过传入 to 属性指定链接： component_1 在视图中使用 router-view 组件定义路由出口，匹配到的组件将渲染在这里： "},"附录1 前后端分离的vue急速入门/0.7homework.html":{"url":"附录1 前后端分离的vue急速入门/0.7homework.html","title":"A.7 课后作业","keywords":"","body":"A.7 课后作业 了解vue的概念。 练习vue的简单用法。 尝试使用vue+Spring Boot完成“用户注册”应用的开发。 "},"附录2 Spring Boot配置大全/Configuration.html":{"url":"附录2 Spring Boot配置大全/Configuration.html","title":"附录2 Spring Boot配置大全","keywords":"","body":"A2 Spring Boot配置大全 我只是Spring Boot官方文档的搬运工（还是只搬运文档目录的那种）。 详细文档在这里：Spring Boot官方文档，这篇附录出现在这里的目的，只是为了方便查找而已。 1. Core properties 2. Cache properties 3. Mail properties 4. JSON properties 5. Data properties 6. Transaction properties 7. Data migration properties 8. Integration properties 9. Web properties 10. Templating properties 11. Server properties 12. Security properties 13. RSocket properties 14. Actuator properties 15. Devtools properties 16. Testing properties 官方宣称：最后更新时间 2019-11-06 21:59:20 UTC 。 离线文档，请移步到这里。 这个附录出现在这里的主要原因是我接触了太多的开发人员，有些开发人员有这样一个特点：不爱看官方文档，尤其不爱看英文的官方文档。如果由于这一篇附录，能够引导这些开发人员开始习惯于查阅（临时应急）或浏览（日常学习）官方文档，那就善莫大焉。 "},"附录3 在Docker中部署Spring Boot应用/Docker.html":{"url":"附录3 在Docker中部署Spring Boot应用/Docker.html","title":"附录3 在Docker中部署Spring Boot应用","keywords":"","body":"A3 在Docker中部署Spring Boot应用 Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker属于Linux容器的一种封装，提供简单易用的容器使用接口，它是目前最流行的Linux容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样，有了Docker，就再也不用担心环境问题了。 和Docker经常一起提到的是虚拟机，不严格的可以将Docker与虚拟机类比于线程与进程。在宿主机器中启动一个Docker容器的系统开销远远小于启动一个虚拟机。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境； 在分布式微服务架构场景下弹性扩容部署。 本附录中，我们将使用一个最简单的Spring Boot项目来讲解如何在macOS的Docker容器中部署应用。 为什么不选择Windows？因为Docker天生就是为Linux开发的，在macOS中使用也很方便。在很长一段时间内，都没有直接在Windows上直接运行的Docker环境，在Windows中需要通过Linux虚拟机间接的使用。当前官方为最新的Docker提供了在Windows 10的某些版本（专业版）上直接运行的环境。 所以本附录中的示例使用macOS，所有的操作和命令与Linux中的操作保持一致。 A3.1 概念 Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。大部分情况下，docker服务端和客户端运行在一台机器上。 Docker daemon：Docker守护进程，运行在宿主机上（如本附录写作时，其运行在我的MacBook Pro上），用户通过Docker Client（在其中使用Docker 命令）与Docker daemon交互。 Docker client：Docker命令行工具，是用户使用Docker的主要方式。Docker client与Docker daemon通信并将结果返回给用户，Docker client也可以通过socket或者RESTful API访问远程的Docker daemon。 Docker image：镜像是只读的，镜像中包含有需要运行的文件。镜像用来创建 container，一个镜可以运行多个container（image和container可以简单的类比于类和对象的关系）；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载。 Docker container：容器是Docker的运行组件，可以被创建、启动、停止、删除、暂停等。启动一个镜像就是创建运行一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。 Docker hub/registry：保存、共享和管理Docker镜像的仓库（类似于github，或者maven中央仓库），用户可以上传或者下载上面的镜像，官方地址https://registry.hub.docker.com，也可以搭建自己私有的 Docker registry（类似于私服）。 A3.2 安装 到Docker官方下载Docker Desktop，如果下载速度太慢，建议使用下载工具下载，如迅雷。 双击下载完成的Docker.dmg磁盘镜像文件，将Docker.app拖动到Applicatios文件夹中完成安装。 启动Docker，第一次启动可能需要你输入当前mac用户的密码。 打开终端，输入docker version命令，检查Docker环境是否正确安装。 Last login: Fri Dec 13 23:37:16 on console kevin@KevindeMacBook-Pro ~ % docker version Client: Docker Engine - Community Version: 19.03.5 API version: 1.40 Go version: go1.12.12 Git commit: 633a0ea Built: Wed Nov 13 07:22:34 2019 OS/Arch: darwin/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.5 API version: 1.40 (minimum version 1.12) Go version: go1.12.12 Git commit: 633a0ea Built: Wed Nov 13 07:29:19 2019 OS/Arch: linux/amd64 Experimental: true containerd: Version: v1.2.10 GitCommit: b34a5c8af56e510852c35414db4c1f4fa6172339 runc: Version: 1.0.0-rc8+dev GitCommit: 3e425f80a8c931f88e6d94a8c831b9d5aa481657 docker-init: Version: 0.18.0 GitCommit: fec3683 kevin@KevindeMacBook-Pro ~ % Docker Hub 提供众多镜像，我们可以从中自由地下载数十万计的免费应用镜像， 这些镜像作为 docker 生态圈的基石，是我们使用和学习 docker 不可或缺的资源。但是，在国内访问Docker Hub速度较慢，为Docker添加国内镜像源，可以非常有效地提高镜像的下载速度。 当前比较快的国内镜像源推荐http://f1361db2.m.daocloud.io。 打开Docker的首选项。 添加国内镜像源，然后\"Apply & Restart\"。 打开终端，输入docker pull nginx命令，拉取nginx镜像，测试下载速度。 A3.3 使用 在日常管理使用Docker的过程中，常用的Docker命令有镜像的拉取、创建、删除，容器的创建、启动、停止、删除等。 A3.3.1 拉取镜像 当我们需要某一镜像时，可以去官方“Docker hub”：https://registry.hub.docker.com上查找需要的镜像，然后使用命令docker pull IMAGE_NAME拉取镜像。 A3.3.2 查看镜像 使用命令docker images查看当前宿主机上的容器。 如下图，可以看到刚才拉取下来的centos镜像。 A3.3.3 删除镜像 使用命令docker rmi IMAGE_NAME/IMAGE_ID删除镜像，例如docker rmi 3fa112fd3642删除3年前下载的“registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g”镜像。 A3.3.4 创建起停容器 使用命令docker run xxx创建并运行容器。 docker run --name SpringBootCourseRedis -p 6379:6379 -v ~/data:/data -d redis 启动参数说明： --name：指定容器别名，指定后可直接通过别名操作该容器 -p：将容器端口与本地端口进行映射，冒号前边为本地端口，后边的为容器端口 -v： 将本地目录映射到容器目录，这里将本机用户目录～/data映射到容器中的/data -d：后台运行 最后的参数'redis'是镜像名称 前置条件：本机已经通过'docker pull redis'下载了redis镜像 使用命令docker stop container_name/container_id停止容器。 使用命令docker start container_name/container_id启动容器。 使用命令docker restart container_name/container_id重启容器。 A3.3.5 查看容器 使用命令docker ps查看当前运行的容器，使用docker ps -a查看宿主机上的所有容器（包含创建后停止的，没有运行的容器）。 A3.3.6 删除容器 使用命令docker rm container_name/container_id删除容器。 A3.4 集成 创建Spring Boot项目，在其pom依赖中添加Dockerfile Maven Plugin插件。 com.spotify dockerfile-maven-plugin 1.4.13 springboot-docker ./ ${project.version} target/${project.build.finalName}.jar 在项目根目录（和pom.xml同一目录）下创建Dockerfile文件，内容如下： # 基础镜像 FROM openjdk:8 # 对应pom.xml文件中的dockerfile-maven-plugin插件buildArgs配置项JAR_FILE的值 ARG JAR_FILE # 复制打包完成后的jar文件到/opt目录下 COPY ${JAR_FILE} /opt/app.jar # 启动容器时执行 ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/opt/app.jar\"] # 使用8080端口 EXPOSE 8080 修改启动类，在其上添加一个用户交互地址/docker/hello用来测试程序是否正确运行。 package com.example.docker; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/docker/\") @SpringBootApplication public class SpringBookDockerApplication { public static void main(String[] args) { SpringApplication.run(SpringBookDockerApplication.class, args); } @RequestMapping(\"/hello\") public String hello() { return \"Hello Docker.\"; } } 在STS中运行maven构建任务。 构建目标为clean package dockerfile:build，可以选择跳过测试。 构建成功后使用命令docker images检查构建的镜像。 使用springboot-docker镜像创建并运行容器。 docker run --name SpringBootDockerHello -p 8080:8080 springboot-docker:0.0.1-SNAPSHOT 打开浏览球，访问http://localhost:8080/docker/hello地址，检查Docker容器是否正常工作。 本小节示例项目代码： https://github.com/gyzhang/SpringBootCourseCode/tree/master/spring-boot-docker "},"EnrollmentAd.html":{"url":"EnrollmentAd.html","title":"广告 融宝大学堂招生","keywords":"","body":"融宝大学堂招生广告 身处软件开发行业中的程序猿/媛小哥哥小姐姐们，每天都在为工作忙碌着，日常加班几乎是常态，通宵上线也不罕见。 参加工作2-3年的你是否“今天重复着昨天的故事”：参考项目组核心骨干完成的类似功能或在网上搜索一些短平快的文章，熟练地使用拷贝和复制，迅速地完成工作任务。看着键盘上锃亮锃亮的CTRL、C和V三个键，在感叹“时间过得很快，技能提升有限”中跨入了21世纪20年代，内心却开始质疑：这就是程序员的工作？ 但是，业界不会等你！ 这几年层出不穷的技术，一个接一个的技术大词，你是否已经看得眼花缭乱？ 当你终于鼓起勇气、下定决心，到网上购买了一系列的课程（感谢这个年代技术牛人们的分享，网上有一批物美价廉的课程），准备放手大干一场。却发现，每前进一步，都感觉自己不会的东西更多，效果就是“一顿操作猛如虎，定睛一看原地杵”。 终于明白，在开发领域，自己的知识是不成体系的！ 多么痛的领悟… 文思海辉融宝大学堂想你所想，急你所急，推出了一系列“传帮带”风格的 Java 开发培训课程，涵盖初中高级，从Core Java 到 Spring Boot 再到 Spring Cloud，总有一款适合你。 本课程是一套 Spring Boot快速入门培训教程，面向的学员是有一定的 Java 基础，会Spring 传统开发（SSM）的初级Java开发工程师。其目的是通过2-3个月的时间，在辅导教员的引导下每周完成1个章节的学习，达到能够应用 Spring Boot 进行开发的程度，向中级开发工程师进阶，进而打好后续学习 Spring Cloud 的基础。 教程特点： 面向初中级 Java 开发工程师设计，紧跟技术发展，使用最新的 Spring Boot 2.2 版本； 每一课都尽量聚焦在当前讨论的知识点范围内，示例也设计为最简，让你集中火力快速掌握当前知识； 教程注重实战，会适量介绍背景理论，但不涉及 Spring Boot 的深层次实现机制和如何扩展 Spring Boot 框架； 教程包括： Spring Boot 背景及基本原理介绍； 开发环境配置 + Hello World，快速上手无难事； 数据库、事务和 Web 开发； NoSQL 之 Redis 和 MongoDB； 异步消息：ActiveMQ + RabbitMQ + RocketMQ + Kafka； 异常处理，应用监控，安全管控：OAuth 2、SSO； 单元测试、热部署、多环境配置及打包上线部署； 企业级开发：邮件、调度、批处理、数据校验和 WebSocket。 本教程在构建你的知识体系基础上提升学习力，你值得拥有。 "}}